<!DOCTYPE html>
<html>
<head>
  <link rel = "icon"  href = "images/favicon.png" type = "image/png">
  <link rel = "stylesheet" href = "stylesheets/main.css">
  <title>Test Bed ~ e4494s</title>
  <style>
    canvas {
      width: 300px;
      height: 300px;
      border: 2px solid black;
    }
    
    hr {
      border: 1px solid black;
    }
    
    .desc {
      background-color: silver;
      margin: 5px;
      padding: 5px;
      border-radius: 5px;
    }
    .desc mark {
      background-color: #ffff4d;
    }
  </style>
</head>
<body>
<script src = "scripts/main.js"></script>
<h1>The Island of Misfit Code</h1>
<!--
<canvas id = "canvas0"></canvas>
<button onclick = "startCanvas0()">Start/Stop</button>
<hr><hr>
<script>
  const ctx0 = canvas0.getContext("2d");
  canvas0.width = canvas0.height = 300;
  let canvas0Running = false;
  
  function frame0() {
    ctx0.clearRect(0, 0, canvas0.width, canvas0.height);
    
    if (canvas0Running) requestAnimationFrame(frame0);
  }
  frame0();
  
  function startCanvas0() {
    if (canvas0Running) canvas0Running = false;
    else {
      canvas0Running = true;
      frame0();
    }
  }
</script>
-->
<div style = "font-size: 16px; background-color: rgba(255, 255, 100); padding: 8px; margin-top: 25px; margin-bottom: 25px; border-radius: 10px"><b><i>Reached 99 canvases! (6/30/2021 - 10/17/2021) Moved to <a href = "testbed2.html" target = "_blank">testbed2.html</a>.</i></b></div>
<canvas id = "canvas99" style = "background-color: black; width: 400px; height: 400px"></canvas>
<button onclick = "drawBands99()">Redraw</button>
<table>
  <tr>
    <td style = "padding: 5px">
      <div><b><u>Number of Bands:</u></b> <span id = "numBands99Txt">30</span></div>
      <input type = "range" min = "0" max = "23" value = "12" step = "1" id = "numBands99Range" oninput = "updateSettings99()">
    </td>
    <td></td>
    <td></td>
    <td rowspan = "10" style = "padding: 5px">
      <button onclick = "randomizeSettings99()">Randomize Settings</button>
      <div><b><u>Settings Presets:</u></b></div>
      <div id = "presets99Div" style = "width: 150px"></div>
    </td>
  </tr>
  <tr>
    <td style = "padding: 5px">
      <div><b><u>Min Band Offset Angle:</u></b> <span id = "minAngle99Txt">0</span>&deg;</div>
      <input type = "range" min = "0" max = "360" value = "0" step = "5" id = "minAngle99Range" oninput = "updateSettings99()">
    </td>
    <td style = "padding: 5px">
      <div><b><u>Max Band Offset Angle:</u></b> <span id = "maxAngle99Txt">360</span>&deg;</div>
      <input type = "range" min = "0" max = "360" value = "360" step = "5" id = "maxAngle99Range" oninput = "updateSettings99()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 5px">
      <div><b><u>Hue:</u></b> <span id = "hue99Txt">60</span>&deg;</div>
      <input type = "range" min = "0" max = "360" value = "60" step = "5" id = "hue99Range" oninput = "updateSettings99()">
    </td>
    <td style = "padding: 5px">
      <div><b><u>Contrast:</u></b> <span id = "contrast99Txt">75</span>%</div>
      <input type = "range" min = "0" max = "100" value = "75" step = "5" id = "contrast99Range" oninput = "updateSettings99()">
    </td>
    <td style = "padding: 5px">
      <div><b><u>Rainbow:</u></b></div>
      <input type = "checkbox" id = "rainbow99Checkbox" oninput = "updateSettings99()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 5px">
      <div><b><u>Band Thickness:</u></b> <span id = "bandThickness99Txt">5</span>px</div>
      <input type = "range" min = "1" max = "25" value = "5" step = "1" id = "bandThickness99Range" oninput = "updateSettings99()">
    </td>
    <td style = "padding: 5px">
      <div><b><u>Band Spacing:</u></b> <span id = "bandSpacing99Txt">15</span>px</div>
      <input type = "range" min = "1" max = "50" value = "15" step = "1" id = "bandSpacing99Range" oninput = "updateSettings99()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 5px">
      <div><b><u>Connect Bands:</u></b></div>
      <input type = "checkbox" id = "connectBands99Checkbox" oninput = "updateSettings99()" CHECKED>
    </td>
    <td style = "padding: 5px">
      <div><b><u>Align Bands:</u></b></div>
      <input type = "checkbox" id = "alignBands99Checkbox" oninput = "updateSettings99()" CHECKED>
    </td>
  </tr>
  <tr>
    <td style = "padding: 5px">
      <div><b><u>Band Direction:</u></b></div>
      <input type = "radio" name = "bandDirection99Radio" id = "bandDirection99Radio1" oninput = "updateSettings99()">
      <label for = "bandDirection99Radio1">Randomize Direction</label>
      <br>
      <input type = "radio" name = "bandDirection99Radio" id = "bandDirection99Radio2" oninput = "updateSettings99()">
      <label for = "bandDirection99Radio2">Same Direction</label>
      <br>
      <input type = "radio" name = "bandDirection99Radio" id = "bandDirection99Radio3" oninput = "updateSettings99()" CHECKED>
      <label for = "bandDirection99Radio3">Alternate Direction</label>
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(10/14/2021)</i></b> Simple interlocking bands generational art.<br><b><i>(10/15/2021)</i></b> Added more settings, colors, and sliders, as well as randomizing settings and settings presets.<br><b><i>(10/17/2021)</i></b> Added more presets.<br><b><i><mark>Actually finished! (11/18/2021)</mark> Moved to <a href = "bands.html" target = "_blank">bands.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx99 = canvas99.getContext("2d");
  canvas99.width = canvas99.height = 1000;
  
  let numBands99 = 30;
  let bandThickness99 = 5;
  let bandSpacing99 = 15;
  let connectBands99 = true;
  let randomizeDirection99 = false;
  let alternateDirection99 = true;
  let alignBands99 = true;
  let minAngle99 = 0;
  let maxAngle99 = 360;
  let hue99 = 60;
  let rainbow99 = false;
  let contrast99 = 75;
  
  function drawBands99() {
    ctx99.clearRect(0, 0, canvas99.width, canvas99.height);
    ctx99.lineWidth = bandThickness99;
    ctx99.lineJoin = ctx99.lineCap = "round";
    
    let currAngle = Math.random() * Math.PI * 2;
    let currX = canvas99.width / 2;
    let currY = canvas99.height / 2;
    
    if (connectBands99) ctx99.beginPath();
    for (let i = 0; i < numBands99; i++) {
      let h = rainbow99 ? ((i / numBands99) * 360) + hue99 : hue99;
      ctx99.strokeStyle = `hsl(${h}deg, 100%, ${((i / numBands99) * contrast99) + ((100 - contrast99) / 2)}%)`;
      //`hsl(${hue99}deg, 100%, ${((i / numBands99) * 70) + 15}%)`;
      
      if (!alignBands99) currAngle = Math.random() * Math.PI * 2;
      let sign = Math.random() >= 0.5 ? 1 : -1;
      if (!randomizeDirection99) {
        if (alternateDirection99) sign = i % 2 === 1 ? 1 : -1;
        else sign = 1;
      }
      
      let nextAngle = currAngle + (toRad(randBetween(minAngle99, maxAngle99)) * sign);
      let radius = i * bandSpacing99;
      let nextX1 = (canvas99.width / 2) + (radius * Math.cos(currAngle));
      let nextY1 = (canvas99.height / 2) + (radius * Math.sin(currAngle));
      let nextX2 = (canvas99.width / 2) + (radius * Math.cos(nextAngle));
      let nextY2 = (canvas99.height / 2) + (radius * Math.sin(nextAngle));
      
      ctx99.beginPath();
      ctx99.arc(canvas99.width / 2, canvas99.height / 2, radius, currAngle, nextAngle, sign === -1);
      ctx99.stroke();
      if (connectBands99) {
        ctx99.beginPath();
        ctx99.moveTo(currX, currY);
        ctx99.lineTo(nextX1, nextY1);
        ctx99.stroke();
      }
      
      currAngle = nextAngle;
      currX = nextX2;
      currY = nextY2;
    }
  }
  drawBands99();
  
  for (let i = 1; i <= 8; i++) {
    let btn = document.createElement("button");
    btn.innerHTML = i;
    btn.style.display = "inline-block";
    btn.style.margin = "5px";
    btn.style.borderRadius = "50%";
    btn.onclick = () => loadPreset99(i);
    presets99Div.appendChild(btn);
  }
  
  function randomizeSettings99() {
    let randomizeRange = element => element.value = Number(randBetween(Number(element.min), Number(element.max))).toMultipleOf(Number(element.step));
    
    randomizeRange(numBands99Range);
    randomizeRange(hue99Range);
    rainbow99Checkbox.checked = Math.random() >= 0.5;
    randomizeRange(contrast99Range);
    randomizeRange(maxAngle99Range);
    minAngle99Range.max = maxAngle99Range.value;
    randomizeRange(minAngle99Range);
    randomizeRange(bandThickness99Range);
    randomizeRange(bandSpacing99Range);
    let dir = Math.floor(Math.random() * 3);
    bandDirection99Radio1.checked = dir === 0;
    bandDirection99Radio2.checked = dir === 1;
    bandDirection99Radio3.checked = dir === 2;
    connectBands99Checkbox.checked = Math.random() >= 0.5;
    if (!connectBands99Checkbox.checked) alignBands99Checkbox.checked = Math.random() >= 0.5;
    else alignBands99Checkbox.checked = true;
    
    updateSettings99();
  }
  
  function loadPreset99(n) {
    if (n === 1) {
      numBands99Range.value = numBands99RangeArray.indexOf(30);
      hue99Range.value = 60;
      rainbow99Checkbox.checked = false;
      contrast99Range.value = 75;
      maxAngle99Range.value = minAngle99Range.max = 360;
      minAngle99Range.value = 0;
      bandThickness99Range.value = 5;
      bandSpacing99Range.value = 15;
      bandDirection99Radio1.checked = false;
      bandDirection99Radio2.checked = false;
      bandDirection99Radio3.checked = true;
      alignBands99Checkbox.checked = true;
      connectBands99Checkbox.checked = true;
    }
    else if (n === 2) {
      numBands99Range.value = numBands99RangeArray.indexOf(50);
      hue99Range.value = 300;
      rainbow99Checkbox.checked = true;
      contrast99Range.value = 0;
      maxAngle99Range.value = minAngle99Range.max = 360;
      minAngle99Range.value = 90;
      bandThickness99Range.value = 10;
      bandSpacing99Range.value = 15;
      bandDirection99Radio1.checked = true;
      bandDirection99Radio2.checked = false;
      bandDirection99Radio3.checked = false;
      alignBands99Checkbox.checked = false;
      connectBands99Checkbox.checked = false;
    }
    else if (n === 3) {
      numBands99Range.value = numBands99RangeArray.indexOf(50);
      hue99Range.value = 0;
      rainbow99Checkbox.checked = false;
      contrast99Range.value = 100;
      maxAngle99Range.value = minAngle99Range.max = 280;
      minAngle99Range.value = 235;
      bandThickness99Range.value = 5;
      bandSpacing99Range.value = 9;
      bandDirection99Radio1.checked = false;
      bandDirection99Radio2.checked = false;
      bandDirection99Radio3.checked = true;
      alignBands99Checkbox.checked = true;
      connectBands99Checkbox.checked = false;
    }
    else if (n === 4) {
      numBands99Range.value = numBands99RangeArray.indexOf(7);
      hue99Range.value = 240;
      rainbow99Checkbox.checked = false;
      contrast99Range.value = 100;
      maxAngle99Range.value = minAngle99Range.max = 270;
      minAngle99Range.value = 90;
      bandThickness99Range.value = 25;
      bandSpacing99Range.value = 50;
      bandDirection99Radio1.checked = true;
      bandDirection99Radio2.checked = false;
      bandDirection99Radio3.checked = false;
      alignBands99Checkbox.checked = false;
      connectBands99Checkbox.checked = false;
    }
    else if (n === 5) {
      numBands99Range.value = numBands99RangeArray.indexOf(150);
      hue99Range.value = 20;
      rainbow99Checkbox.checked = false;
      contrast99Range.value = 100;
      maxAngle99Range.value = minAngle99Range.max = 360;
      minAngle99Range.value = 0;
      bandThickness99Range.value = 8;
      bandSpacing99Range.value = 5;
      bandDirection99Radio1.checked = false;
      bandDirection99Radio2.checked = false;
      bandDirection99Radio3.checked = true;
      alignBands99Checkbox.checked = true;
      connectBands99Checkbox.checked = true;
    }
    else if (n === 6) {
      numBands99Range.value = numBands99RangeArray.indexOf(200);
      hue99Range.value = 100;
      rainbow99Checkbox.checked = true;
      contrast99Range.value = 75;
      maxAngle99Range.value = minAngle99Range.max = 25;
      minAngle99Range.value = 0;
      bandThickness99Range.value = 10;
      bandSpacing99Range.value = 5;
      bandDirection99Radio1.checked = false;
      bandDirection99Radio2.checked = false;
      bandDirection99Radio3.checked = true;
      alignBands99Checkbox.checked = true;
      connectBands99Checkbox.checked = true;
    }
    else if (n === 7) {
      numBands99Range.value = numBands99RangeArray.indexOf(25);
      hue99Range.value = 0;
      rainbow99Checkbox.checked = true;
      contrast99Range.value = 50;
      maxAngle99Range.value = minAngle99Range.max = 240;
      minAngle99Range.value = 120;
      bandThickness99Range.value = 3;
      bandSpacing99Range.value = 20;
      bandDirection99Radio1.checked = false;
      bandDirection99Radio2.checked = false;
      bandDirection99Radio3.checked = true;
      alignBands99Checkbox.checked = true;
      connectBands99Checkbox.checked = false;
    }
    else if (n === 8) {
      numBands99Range.value = numBands99RangeArray.indexOf(35);
      hue99Range.value = 30;
      rainbow99Checkbox.checked = true;
      contrast99Range.value = 75;
      maxAngle99Range.value = minAngle99Range.max = 180;
      minAngle99Range.value = 90;
      bandThickness99Range.value = 25;
      bandSpacing99Range.value = 20;
      bandDirection99Radio1.checked = false;
      bandDirection99Radio2.checked = false;
      bandDirection99Radio3.checked = true;
      alignBands99Checkbox.checked = true;
      connectBands99Checkbox.checked = true;
    }
    
    updateSettings99();
  }
  
  let numBands99RangeArray = [2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100, 150, 200];
  
  function updateSettings99() {
    numBands99 = numBands99Txt.innerHTML = numBands99RangeArray[Number(numBands99Range.value)];
    
    hue99 = hue99Txt.innerHTML = Number(hue99Range.value);
    
    rainbow99 = rainbow99Checkbox.checked;
    
    contrast99 = contrast99Txt.innerHTML = Number(contrast99Range.value);
    
    maxAngle99 = maxAngle99Txt.innerHTML = Number(maxAngle99Range.value);
    minAngle99Range.max = maxAngle99;
    minAngle99 = minAngle99Txt.innerHTML = Number(minAngle99Range.value);
    
    bandThickness99 = bandThickness99Txt.innerHTML = Number(bandThickness99Range.value);
    
    bandSpacing99 = bandSpacing99Txt.innerHTML = Number(bandSpacing99Range.value);
    
    randomizeDirection99 = false;
    alternateDirection99 = false;
    if (bandDirection99Radio1.checked) randomizeDirection99 = true;
    else if (bandDirection99Radio3.checked) alternateDirection99 = true;
    
    alignBands99 = alignBands99Checkbox.checked;
    connectBands99 = connectBands99Checkbox.checked;
    
    drawBands99();
  }
</script>
<canvas id = "canvas98" style = "background-color: black"></canvas>
<button onclick = "startCanvas98()">Start/Stop</button>
<button onclick = "if (!canvas98Running) frame98()">Step</button>
<div><b><u>Random Mode:</u></b> [ <span id = "randMode98Txt">random</span> ]</div>
<input type = "range" min = "1" max = "15" value = "1" step = "1" id = "randMode98Range" style = "width: 250px" oninput = "updateSettings98()">
<div><b><u>Average of 1,000 random values:</u></b> <span id = "rand98AverageTxt"></span></div>
<div class = "desc"><b><i>(10/13/2021)</i></b> Experimenting with how different random functions can have different results.<br><b><i>(10/14/2021)</i></b> Added more functions and average of 1,000 random values text.</div>
<hr><hr>
<script>
  const ctx98 = canvas98.getContext("2d");
  canvas98.width = canvas98.height = 1000;
  let canvas98Running = false;
  
  let randMode98 = 1;
  
  function rand98() {
    if (randMode98 === 1) return Math.random();
    else if (randMode98 === 2) return (Math.random() + Math.random()) / 2;
    else if (randMode98 === 3) return (Math.random() + Math.random() + Math.random()) / 3;
    else if (randMode98 === 4) return (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random()) / 10;
    else if (randMode98 === 5) return 1 / (Math.random() + 1);
    else if (randMode98 === 6) return Math.random() ** Math.random();
    else if (randMode98 === 7) return Math.random() ** (1 / Math.random());
    else if (randMode98 === 8) return Math.random() ** 2;
    else if (randMode98 === 9) return Math.random() ** 3;
    else if (randMode98 === 10) return Math.random() ** 10;
    else if (randMode98 === 11) return Math.sqrt(Math.random());
    else if (randMode98 === 12) return Math.cbrt(Math.random());
    else if (randMode98 === 13) return Math.random() ** 0.1;
    else if (randMode98 === 14) return Math.random() % Math.random();
    else if (randMode98 === 15) return Math.random().toMultipleOf(0.05);
  }
  
  let lastRandAverageTime = Date.now();
  
  function updateRand98AverageTxt() {
    let sum = 0;
    for (let i = 0; i < 1000; i++) sum += rand98();
    rand98AverageTxt.innerHTML = (sum / 1000).toFixed(16);
    lastRandAverageTime = Date.now();
  }
  
  function frame98() {
    ctx98.clearRect(0, 0, canvas98.width, canvas98.height);
    
    if (Date.now() - lastRandAverageTime >= 1000 || !canvas98Running) updateRand98AverageTxt();
    
    for (let i = 0; i < 300; i++) {
      ctx98.fillStyle = `hsl(${rand98() * 360}deg, 100%, 50%)`;
      ctx98.fillCircle(rand98() * canvas98.width, rand98() * canvas98.height, (rand98() * 20) + 5);
    }
    
    if (canvas98Running) requestAnimationFrame(frame98);
  }
  updateRand98AverageTxt();
  frame98();
  
  let randMode98TxtArray = ["random", "(2 randoms) / 2", "(3 randoms) / 3", "(10 randoms) / 10", "1 / (random + 1)", "random ^ random", "random ^ (1 / random)", "random ^ 2", "random ^ 3", "random ^ 10", "square root of random", "cube root of random", "10th root of random", "random mod random", "random rounded to multiple of 0.05"];
  
  function updateSettings98() {
    randMode98 = Number(randMode98Range.value);
    randMode98Txt.innerHTML = randMode98TxtArray[Number(randMode98Range.value) - 1];
    
    updateRand98AverageTxt();
    
    if (!canvas98Running) frame98();
  }
  
  function startCanvas98() {
    if (canvas98Running) canvas98Running = false;
    else {
      canvas98Running = true;
      frame98();
    }
  }
</script>
<canvas id = "canvas97" style = "background-color: black"></canvas>
<button onclick = "startCanvas97()">Start/Stop</button>
<button onclick = "reset97()">Reset</button>
<div><b><u>Turbo:</u></b></div>
<input type = "checkbox" id = "turbo97Checkbox" oninput = "updateSettings97()">
<div><b><u>Hue:</u></b> <span id = "hue97Txt">120</span>&deg;</div>
<input type = "range" min = "0" max = "360" value = "120" step = "15" id = "hue97Range" oninput = "updateSettings97()">
<div><b><u>Line Width:</u></b> <span id = "lineWidth97Txt">3</span>px</div>
<input type = "range" min = "1" max = "5" value = "3" step = "1" id = "lineWidth97Range" oninput = "updateSettings97()">
<div><b><u>Jitter:</u></b> <span id = "jitter97Txt">10</span>px</div>
<input type = "range" min = "0" max = "25" value = "10" step = "1" id = "jitter97Range" oninput = "updateSettings97()">
<div><b><u>Rainbow:</u></b></div>
<input type = "checkbox" id = "rainbow97Checkbox" oninput = "grayscale97Checkbox.checked = false; updateSettings97()">
<div><b><u>Grayscale:</u></b></div>
<input type = "checkbox" id = "grayscale97Checkbox" oninput = "rainbow97Checkbox.checked = false; updateSettings97()">
<div class = "desc"><b><i>(10/11/2021)</i></b> Not really sure what this is, I was originally just going to make some art thing where when you click it makes a random spiral with random shape and color, but then I discovered this, and I kinda like it. It's just a spiral with random turn speed and grow speed, but also a random jitter property that randomizes where it draws to each frame by a set amount of pixels. I also some settings and sliders. At some point I might fully flesh this out into a background generator, but for now it'll stay how it is.</div>
<hr><hr>
<script>
  const ctx97 = canvas97.getContext("2d");
  canvas97.width = canvas97.height = 1000;
  let canvas97Running = false;
  let canvas97Rect = canvas97.getBoundingClientRect();
  let canvas97Ratio = canvas97.width / 300;
  
  let spiral97StepsPerFrame = 100;
  let hue97 = 120;
  let rainbow97 = false;
  let grayscale97 = false;
  let lineWidth97 = 3;
  let jitter97 = 10;
  let running97 = true;
  
  function Spiral97(x, y) {
    running97 = true;
    this.centerX = x;
    this.centerY = y;
    this.x = this.centerX;
    this.y = this.centerY;
    this.lastX = this.x;
    this.lastY = this.y;
    this.angle = 0;
    this.radius = 0;
    this.turnSpeed = randBetween(0.5, 2);
    this.growSpeed = randBetween(0.02, 0.07);
  }
  Spiral97.prototype.render = function() {
    if (this.radius >= (canvas97.width * 0.5 * Math.SQRT2) + 25) {
      running97 = false;
      return;
    }
    for (let i = 0; i < spiral97StepsPerFrame; i++) {
      this.lastX = this.x;
      this.lastY = this.y;
      this.angle += Math.random() * this.turnSpeed;
      this.radius += Math.random() * this.growSpeed;
      let r = Math.random() * jitter97;
      let cx = this.centerX + randBetween(-r, r);
      let cy = this.centerY + randBetween(-r, r);
      this.x = cx + (this.radius * Math.cos(toRad(this.angle)));
      this.y = cy + (this.radius * Math.sin(toRad(this.angle)));
      ctx97.lineJoin = ctx97.lineCap = "round";
      ctx97.lineWidth = lineWidth97;
      ctx97.strokeStyle = rainbow97 ? `hsl(${Math.random() * 360}deg, 100%, 50%)` : `hsl(${hue97}deg, ${grayscale97 ? 0 : 100}%, ${Math.random() * 100}%)`;
      ctx97.beginPath();
      ctx97.moveTo(this.lastX, this.lastY);
      ctx97.lineTo(this.x, this.y);
      ctx97.stroke();
    }
  };
  let spiral97Array = [];
  spiral97Array.push(new Spiral97(canvas97.width / 2, canvas97.height / 2));
  
  function frame97() {
    //ctx97.clearRect(0, 0, canvas97.width, canvas97.height);
    
    for (let i = 0; i < spiral97Array.length; i++) spiral97Array[i].render();
    
    if (canvas97Running) requestAnimationFrame(frame97);
  }
  frame97();
  
  function updateSettings97() {
    spiral97StepsPerFrame = turbo97Checkbox.checked ? 500 : 100;
    hue97 = hue97Txt.innerHTML = Number(hue97Range.value);
    lineWidth97 = lineWidth97Txt.innerHTML = Number(lineWidth97Range.value);
    rainbow97 = rainbow97Checkbox.checked;
    grayscale97 = grayscale97Checkbox.checked;
    jitter97 = jitter97Txt.innerHTML = Number(jitter97Range.value);
    
    if (!running97) reset97();
  }
  
  function reset97() {
    running97 = true;
    ctx97.clearRect(0, 0, canvas97.width, canvas97.height);
    spiral97Array = [];
    spiral97Array.push(new Spiral97(canvas97.width / 2, canvas97.height / 2));
  }
  
  function startCanvas97() {
    if (canvas97Running) canvas97Running = false;
    else {
      canvas97Running = true;
      frame97();
    }
  }
</script>
<canvas id = "canvas96" style = "width: 384px; height: 317px; border: none; background-image: url('images/etch-a-sketch.png'); background-size: 100% 100%"></canvas>
<button onclick = "startCanvas96()">Start/Stop</button>
<div class = "desc"><b><i>(10/10/2021)</i></b> An attempt to make a digital Etch-a-Sketch, but I didn't get the knobs working. I'll probably fix it at some point.<br><b><i>(10/11/2021)</i></b> Got everything working right! Now the movement is calculated based on the sign of the last angle and the current angle from the mouse cursor to the knob you're dragging.</div>
<hr><hr>
<script>
  const ctx96 = canvas96.getContext("2d");
  canvas96.width = 384 * 2;
  canvas96.height = 317 * 2;
  let canvas96Running = false;
  let canvas96Rect = canvas96.getBoundingClientRect();
  let canvas96Ratio = 2;
  
  let Mouse96 = {
    down: false,
    x: 0,
    y: 0,
    angleOnClick: 0,
    draggingKnob: ""
  };
  
  let LeftKnob96 = {
    x: 58,
    y: 576,
    radius: 46
  };
  let RightKnob96 = {
    x: 712,
    y: 578,
    radius: 46
  };
  let Pen96 = {
    x: canvas96.width / 2,
    y: 306,
    lastX: canvas96.width / 2,
    lastY: 306,
    radius: 0.5,
    minX: 102,
    maxX: 656,
    minY: 99,
    maxY: 502
  };
  Pen96.move = function(x, y) {
    if (this.x + x > this.maxX || this.x + x < this.minX || this.y + y > this.maxY || this.y + y < this.minY) return;
    this.lastX = this.x;
    this.lastY = this.y;
    this.x += x;
    this.y += y;
    this.draw();
  };
  Pen96.draw = function() {
    ctx96.beginPath();
    ctx96.moveTo(this.lastX, this.lastY);
    ctx96.lineTo(this.x, this.y);
    ctx96.stroke();
    ctx96.stroke();
  };
  
  function frame96() {
    
    if (canvas96Running) requestAnimationFrame(frame96);
  }
  frame96();
  
  function startCanvas96() {
    if (canvas96Running) canvas96Running = false;
    else {
      canvas96Running = true;
      frame96();
    }
  }
  
  canvas96.addEventListener("mousedown", e => {
    if (!canvas96Running) return;
    e.preventDefault();
    Mouse96.down = true;
    canvas96Rect = canvas96.getBoundingClientRect();
    Mouse96.x = (e.clientX - canvas96Rect.left) * canvas96Ratio;
    Mouse96.y = (e.clientY - canvas96Rect.top) * canvas96Ratio;
    let dx = LeftKnob96.x - Mouse96.x;
    let dy = LeftKnob96.y - Mouse96.y;
    let distSq = (dx * dx) + (dy * dy);
    if (distSq <= LeftKnob96.radius * LeftKnob96.radius) {
      Mouse96.draggingKnob = "left";
      Mouse96.angleOnClick = Math.atan2(dy, dx);
      return;
    }
    dx = RightKnob96.x - Mouse96.x;
    dy = RightKnob96.y - Mouse96.y;
    distSq = (dx * dx) + (dy * dy);
    if (distSq <= RightKnob96.radius * RightKnob96.radius) {
      Mouse96.draggingKnob = "right";
      Mouse96.angleOnClick = Math.atan2(dy, dx);
    }
  });
  canvas96.addEventListener("mousemove", e => {
    if (!canvas96Running || !Mouse96.down) return;
    e.preventDefault();
    canvas96Rect = canvas96.getBoundingClientRect();
    Mouse96.x = (e.clientX - canvas96Rect.left) * canvas96Ratio;
    Mouse96.y = (e.clientY - canvas96Rect.top) * canvas96Ratio;
    
    if (Mouse96.draggingKnob === "left") {
      let dx = LeftKnob96.x - Mouse96.x;
      let dy = LeftKnob96.y - Mouse96.y;
      let angle = Math.atan2(dy, dx);
      let diff = angle - Mouse96.angleOnClick;
      Pen96.move(Math.sign(diff), 0);
      Mouse96.angleOnClick = angle;
      return;
    }
    else if (Mouse96.draggingKnob === "right") {
      let dx = RightKnob96.x - Mouse96.x;
      let dy = RightKnob96.y - Mouse96.y;
      let angle = Math.atan2(dy, dx);
      let diff = angle - Mouse96.angleOnClick;
      Pen96.move(0, -Math.sign(diff));
      Mouse96.angleOnClick = angle;
      return;
    }
  });
  window.addEventListener("mouseup", e => {
    Mouse96.down = false;
    Mouse96.draggingKnob = "";
  });
</script>
<canvas id = "canvas95" style = "background-color: black; width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas95()">Start/Stop</button>
<div><b><u>Connect Dots:</u></b></div>
<input type = "checkbox" id = "chain95ConnectPointsCheckbox" oninput = "updateSettings95(false)">
<div><b><u>Number of Dots:</u></b> <span id = "chain95NumPointsTxt">20</span></div>
<input type = "range" min = "5" max = "50" value = "20" step = "5" id = "chain95NumPointsRange" oninput = "updateSettings95(true)">
<div><b><u>Dot Size:</u></b> <span id = "chain95PointRadiusTxt">15</span></div>
<input type = "range" min = "5" max = "25" value = "15" step = "5" id = "chain95PointRadiusRange" oninput = "updateSettings95(false)">
<div><b><u>Dot Spacing:</u></b> <span id = "chain95TouchRatioTxt">100</span>%</div>
<input type = "range" min = "0" max = "12" value = "9" step = "1" id = "chain95TouchRatioRange" oninput = "updateSettings95(false)">
<div><b><u>Dot Speed:</u></b> <span id = "chain95DistRatioTxt">20</span>%</div>
<input type = "range" min = "0" max = "8" value = "4" step = "1" id = "chain95DistRatioRange" oninput = "updateSettings95(false)">
<div class = "desc"><b><i>(10/9/2021)</i></b> Trailing dots behind the cursor, implemented from the idea on <a href = "https://fahad-haidari.medium.com/build-a-simple-circle-based-physics-simulation-with-pi2-js-edd6d7ce857f?p=711cf788bb">https://fahad-haidari.medium.com/build-a-simple-circle-based-physics-simulation-with-pi2-js-edd6d7ce857f?p=711cf788bb</a>. Each dot follows the one before it when you click and drag.<br><b><i>(10/10/2021)</i></b> Added sliders for all the settings.</div>
<hr><hr>
<script>
  const ctx95 = canvas95.getContext("2d");
  canvas95.width = canvas95.height = 1000;
  let canvas95Running = false;
  let canvas95Rect = canvas95.getBoundingClientRect();
  let canvas95Ratio = canvas95.width / 400;
  
  let Mouse95 = {
    down: false,
    x: 0,
    y: 0
  };
  
  let Chain95 = {
    points: [],
    pointRadius: 15,
    distRatio: 0.2,
    touchRatio: 1,
    connectPoints: false,
    numPoints: 20
  };
  Chain95.render = function() {
    for (let i = 0; i < this.points.length; i++) {
      if (i !== this.points.length - 1) {
        let dx = this.points[i + 1].x - this.points[i].x;
        let dy = this.points[i + 1].y - this.points[i].y;
        let distSq = (dx * dx) + (dy * dy);
        let radSq = this.pointRadius * this.pointRadius * 4 * this.touchRatio * this.touchRatio;
        if (distSq >= radSq) {
          let dist = Math.sqrt(distSq);
          let vel = dist * this.distRatio;
          dx /= dist;
          dy /= dist;
          this.points[i].x += dx * vel;
          this.points[i].y += dy * vel;
        }
      }
    }
    
    ctx95.lineCap = ctx95.lineJoin = "round";
    ctx95.lineWidth = this.pointRadius * 2;
    for (let i = 0; i < this.points.length; i++) {
      if (this.connectPoints) {
        ctx95.strokeStyle = this.points[i].color;
        ctx95.beginPath();
        ctx95.moveTo(this.points[i].x, this.points[i].y);
        if (i !== this.points.length - 1) ctx95.lineTo(this.points[i + 1].x, this.points[i + 1].y);
        ctx95.stroke();
      }
      else {
        ctx95.fillStyle = this.points[i].color;
        ctx95.fillCircle(this.points[i].x, this.points[i].y, this.pointRadius);
      }
    }
  };
  Chain95.resetPoints = function() {
    this.points = [];
    for (let i = 0; i < this.numPoints; i++) this.points.push({x: canvas95.width / 2, y: canvas95.height / 2, color: `hsl(${360 - ((i / (this.numPoints - 1)) * 360)}deg, 100%, 50%)`});
    if (!canvas95Running) frame95();
  };
  Chain95.resetPoints();
  
  function frame95() {
    ctx95.clearRect(0, 0, canvas95.width, canvas95.height);
    
    if (Mouse95.down) {
      Chain95.points[Chain95.points.length - 1].x = Mouse95.x;
      Chain95.points[Chain95.points.length - 1].y = Mouse95.y;
    }
    
    Chain95.render();
    
    if (canvas95Running) requestAnimationFrame(frame95);
  }
  
  function startCanvas95() {
    if (canvas95Running) canvas95Running = false;
    else {
      canvas95Running = true;
      frame95();
    }
  }
  
  let chain95TouchRatioRangeArray = [1, 3, 5, 10, 15, 25, 50, 75, 100, 150, 200, 250, 300];
  let chain95DistRatioRangeArray = [1, 5, 10, 15, 20, 25, 30, 40, 50];
  
  function updateSettings95(resetPoints) {
    Chain95.connectPoints = chain95ConnectPointsCheckbox.checked;
    Chain95.numPoints = chain95NumPointsTxt.innerHTML = Number(chain95NumPointsRange.value);
    Chain95.pointRadius = chain95PointRadiusTxt.innerHTML = Number(chain95PointRadiusRange.value);
    Chain95.touchRatio = chain95TouchRatioRangeArray[Number(chain95TouchRatioRange.value)] / 100;
    chain95TouchRatioTxt.innerHTML = chain95TouchRatioRangeArray[Number(chain95TouchRatioRange.value)];
    Chain95.distRatio = chain95DistRatioRangeArray[Number(chain95DistRatioRange.value)] / 100;
    chain95DistRatioTxt.innerHTML = chain95DistRatioRangeArray[Number(chain95DistRatioRange.value)];
    
    if (resetPoints) Chain95.resetPoints();
  }
  
  canvas95.addEventListener("mousedown", e => {
    if (!canvas95Running) return;
    e.preventDefault();
    Mouse95.down = true;
    canvas95Rect = canvas95.getBoundingClientRect();
    Mouse95.x = (e.clientX - canvas95Rect.left) * canvas95Ratio;
    Mouse95.y = (e.clientY - canvas95Rect.top) * canvas95Ratio;
  });
  canvas95.addEventListener("mousemove", e => {
    if (!canvas95Running || !Mouse95.down) return;
    e.preventDefault();
    canvas95Rect = canvas95.getBoundingClientRect();
    Mouse95.x = (e.clientX - canvas95Rect.left) * canvas95Ratio;
    Mouse95.y = (e.clientY - canvas95Rect.top) * canvas95Ratio;
  });
  window.addEventListener("mouseup", e => {
    Mouse95.down = false;
  });
</script>
<canvas id = "canvas94" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas94()">Start/Stop</button>
<div class = "desc"><b><i>(10/8/2021)</i></b> Rollercoaster generator using Bezier curves. At some point I want this to have a little rollercoaster cart rolling along it using the tangent and normal directions at a current point, and have it infinitely scroll along, generating new coaster tracks, and driving along it. I also want to fix the spacing of the supports so that they're more regular and not bunched up.</div>
<hr><hr>
<script>
  const ctx94 = canvas94.getContext("2d");
  canvas94.width = canvas94.height = 1000;
  let canvas94Running = false;
  
  function Track94(x, y, span, minHeight, maxHeight) {
    this.startPoint = {x: x, y: y};
    this.span = span;
    this.minHeight = minHeight;
    this.maxHeight = maxHeight;
    this.endPoint = {x: this.startPoint.x + this.span, y: this.startPoint.y};
    this.controlPoint1 = {x: randBetween(this.startPoint.x, this.startPoint.x + this.span), y: randBetween(this.startPoint.y - this.maxHeight, this.startPoint.y - this.minHeight)};
    this.controlPoint2 = {x: randBetween(this.startPoint.x, this.startPoint.x + this.span), y: randBetween(this.startPoint.y - this.maxHeight, this.startPoint.y - this.minHeight)};
  }
  Track94.prototype.lerp = function(p1, p2, t) {
    return {x: ((1 - t) * p1.x) + (t * p2.x), y: ((1 - t) * p1.y) + (t * p2.y)};
  };
  Track94.prototype.draw = function() {
    ctx94.lineWidth = 3;
    ctx94.lineCap = ctx94.lineJoin = "round";
    for (let i = 0; i <= 100; i += 5) {
      let A = this.lerp(this.startPoint, this.controlPoint1, i / 100);
      let B = this.lerp(this.controlPoint1, this.controlPoint2, i / 100);
      let C = this.lerp(this.controlPoint2, this.endPoint, i / 100);
      let D = this.lerp(A, B, i / 100);
      let E = this.lerp(B, C, i / 100);
      let F = this.lerp(D, E, i / 100);
      
      ctx94.moveTo(F.x, F.y);
      ctx94.lineTo(F.x, this.startPoint.y);
      ctx94.stroke();
    }
    ctx94.lineWidth = 12;
    ctx94.beginPath();
    ctx94.moveTo(this.startPoint.x, this.startPoint.y);
    ctx94.bezierCurveTo(this.controlPoint1.x, this.controlPoint1.y, this.controlPoint2.x, this.controlPoint2.y, this.endPoint.x, this.endPoint.y);
    ctx94.stroke();
  }
  let track94Array = [];
  track94Array.push(new Track94(200, 800, 400, 100, 500));
  track94Array.push(new Track94(600, 800, 400, 100, 500));
  
  function frame94() {
    ctx94.clearRect(0, 0, canvas94.width, canvas94.height);
    
    for (let i = 0; i < track94Array.length; i++) track94Array[i].draw();
    
    ctx94.fillRect(0, 800, 1000, 200);
    
    if (canvas94Running) requestAnimationFrame(frame94);
  }
  frame94();
  
  function startCanvas94() {
    if (canvas94Running) canvas94Running = false;
    else {
      canvas94Running = true;
      frame94();
    }
  }
</script>
<canvas id = "canvas93" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas93()">Start/Stop</button>
<div class = "desc"><b><i>(10/7/2021)</i></b> Space Golf! I want to have different levels with different planets and obstacles, where you try to get your golf ball into a black hole.</div>
<hr><hr>
<script>
  const ctx93 = canvas93.getContext("2d");
  canvas93.width = canvas93.height = 1000;
  let canvas93Running = false;
  let canvas93Rect = canvas93.getBoundingClientRect();
  let canvas93Ratio = canvas93.width / 500;
  
  let Mouse93 = {
    x: 0,
    y: 0,
    power: 0.05,
    lineScale: 5
  };
  
  let gravity93 = 10;
  
  let GolfBall93 = {
    x: canvas93.width / 2,
    y: canvas93.height - 100,
    radius: 10,
    vx: 0,
    vy: 0,
    moving: false,
    launchVelocity: 0,
    launchAngle: 0,
    mass: 10,
    ricochet: false
  };
  GolfBall93.update = function() {
    if (!this.moving) {
      if (this.ricochet) this.launch();
      else return;
    }
    this.x += this.vx;
    this.y += this.vy;
    
    for (let i = 0; i < planet93Array.length; i++) {
      let dx = planet93Array[i].x - this.x;
      let dy = planet93Array[i].y - this.y;
      let distSq = (dx * dx) + (dy * dy);
      let r = planet93Array[i].radius + this.radius;
      let angle = Math.atan2(dy, dx);
      if (distSq <= r * r) {
        this.x = planet93Array[i].x + (r * Math.cos(angle + Math.PI));
        this.y = planet93Array[i].y + (r * Math.sin(angle + Math.PI));
        this.stopMoving();
        return;
      }
      let force = (this.mass * gravity93 * planet93Array[i].mass) / distSq;
      this.vx += force * Math.cos(angle);
      this.vy += force * Math.sin(angle);
    }
    
    let left = this.radius;
    let right = canvas93.width - this.radius;
    let top = this.radius;
    let bottom = canvas93.width - this.radius;
    
    if (this.x < left) {
      this.x = left;
      this.vx = this.vy = 0;
      return;
    }
    if (this.x > right) {
      this.x = right;
      this.vx = this.vy = 0;
      return;
    }
    if (this.y < top) {
      this.y = top;
      this.vx = this.vy = 0;
      return;
    }
    if (this.y > bottom) {
      this.y = bottom;
      this.vx = this.vy = 0;
      return;
    }
  };
  GolfBall93.stopMoving = function() {
    this.moving = false;
    this.vx = this.vy = 0;
    let dx = Mouse93.x - this.x;
    let dy = Mouse93.y - this.y;
    this.launchAngle = Math.atan2(dy, dx);
    this.launchVelocity = Math.sqrt((dx * dx) + (dy * dy)) * Mouse93.power;
  };
  GolfBall93.draw = function() {
    if (!this.moving) {
      ctx93.strokeStyle = "yellow";
      ctx93.lineWidth = 5;
      ctx93.beginPath();
      ctx93.moveTo(this.x, this.y);
      ctx93.lineTo(this.x + (this.launchVelocity * Mouse93.lineScale * Math.cos(this.launchAngle)), this.y + (this.launchVelocity * Mouse93.lineScale * Math.sin(this.launchAngle)));
      ctx93.stroke();
    }
    ctx93.fillStyle = "white";
    ctx93.fillCircle(this.x, this.y, this.radius);
  };
  GolfBall93.launch = function() {
    this.moving = true;
    this.vx = this.launchVelocity * Math.cos(this.launchAngle);
    this.vy = this.launchVelocity * Math.sin(this.launchAngle);
  };
  
  function Planet93(x, y, radius, mass, color) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.mass = mass;
    this.color = color;
  }
  Planet93.prototype.draw = function() {
    ctx93.fillStyle = this.color;
    ctx93.fillCircle(this.x, this.y, this.radius);
  };
  let planet93Array = [];
  
  function loadLevel93(num) {
    planet93Array = [];
    GolfBall93.x = canvas93.width / 2;
    GolfBall93.y = canvas93.height - 100;
    GolfBall93.vx = 0;
    GolfBall93.vy = 0;
    GolfBall93.moving = false;
    GolfBall93.launchVelocity = 0;
    GolfBall93.launchAngle = 0;
    
    // x, y, radius, mass, color
    
    if (num === 1) {
      planet93Array.push(new Planet93(150, 200, 100, 100, "lime"));
      planet93Array.push(new Planet93(600, 250, 50, 75, "hotpink"));
      planet93Array.push(new Planet93(800, 100, 40, 50, "salmon"));
      planet93Array.push(new Planet93(700, 900, 25, 150, "hsl(0deg, 0%, 20%)"));
    }
  }
  
  loadLevel93(1);
  
  function frame93() {
    ctx93.clearRect(0, 0, canvas93.width, canvas93.height);
    
    for (let i = 0; i < planet93Array.length; i++) planet93Array[i].draw();
    
    GolfBall93.update();
    GolfBall93.draw();
    
    if (canvas93Running) requestAnimationFrame(frame93);
  }
  frame93();
  
  function startCanvas93() {
    if (canvas93Running) canvas93Running = false;
    else {
      canvas93Running = true;
      frame93();
    }
  }
  
  canvas93.addEventListener("mousemove", e => {
    if (!canvas93Running) return;
    e.preventDefault();
    canvas93Rect = canvas93.getBoundingClientRect();
    Mouse93.x = (e.clientX - canvas93Rect.left) * canvas93Ratio;
    Mouse93.y = (e.clientY - canvas93Rect.top) * canvas93Ratio;
    let dx = Mouse93.x - GolfBall93.x;
    let dy = Mouse93.y - GolfBall93.y;
    GolfBall93.launchAngle = Math.atan2(dy, dx);
    GolfBall93.launchVelocity = Math.sqrt((dx * dx) + (dy * dy)) * Mouse93.power;
  });
  canvas93.addEventListener("mousedown", e => {
    if (!canvas93Running) return;
    e.preventDefault();
    if (!GolfBall93.moving) GolfBall93.launch();
  });
</script>
<canvas id = "canvas92"></canvas>
<button onclick = "startCanvas92()">Start/Stop</button>
<div class = "desc"><b><i>(10/7/2021)</i></b> Just a simple elastic string simulation, using the same nodes/springs code from the last project. I'm not too happy about this one but I'm not sure what to do with it to make it better.</div>
<hr><hr>
<script>
  const ctx92 = canvas92.getContext("2d");
  canvas92.width = canvas92.height = 1000;
  let canvas92Running = false;
  let canvas92Rect = canvas92.getBoundingClientRect();
  let canvas92Ratio = canvas92.width / 300;
  
  let Mouse92 = {
    down: false,
    x: 0,
    y: 0
  };
  
  let gravity92 = 0.1;
  let damping92 = 0.05;
  let stiffness92 = 0.5;
  let springLength92 = 25;
  
  function Node92(x, y, locked) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.locked = locked;
  }
  Node92.prototype.update = function() {
    if (this.locked) return;
    this.vx *= 1 - damping92;
    this.vy *= 1 - damping92;
    this.vy += gravity92;
    this.x += this.vx;
    this.y += this.vy;
  };
  Node92.prototype.draw = function() {
    ctx92.fillCircle(this.x, this.y, 10);
  };
  let node92Array = [];
  for (let i = 0; i < 30; i++) node92Array.push(new Node92(canvas92.width / 2, i * springLength92, i === 0));
  
  function Spring92(node1, node2) {
    this.node1 = node1;
    this.node2 = node2;
  }
  Spring92.prototype.update = function() {
    let dx = this.node1.x - this.node2.x;
    let dy = this.node1.y - this.node2.y;
    let dist = Math.sqrt((dx * dx) + (dy * dy));
    let displacement = dist - springLength92;
    let angle = Math.atan2(dy, dx);
    let force = -stiffness92 * displacement;
    let xComp = force * Math.cos(angle);
    let yComp = force * Math.sin(angle);
    if (!this.node1.locked) {
      this.node1.vx += xComp;
      this.node1.vy += yComp;
    }
    if (!this.node2.locked) {
      this.node2.vx -= xComp;
      this.node2.vy -= yComp;
    }
  };
  Spring92.prototype.draw = function() {
    ctx92.lineCap = ctx92.lineJoin = "round";
    ctx92.shadowColor = "black";
    ctx92.shadowBlur = 12;
    ctx92.lineWidth = 6;
    ctx92.beginPath();
    ctx92.moveTo(this.node1.x, this.node1.y);
    ctx92.lineTo(this.node2.x, this.node2.y);
    ctx92.stroke();
    ctx92.shadowBlur = 0;
  };
  let spring92Array = [];
  for (let i = 0; i < node92Array.length; i++) {
    if (i !== node92Array.length - 1) {
      spring92Array.push(new Spring92(node92Array[i], node92Array[i + 1]));
    }
  }
  
  function frame92() {
    ctx92.clearRect(0, 0, canvas92.width, canvas92.height);
    
    if (Mouse92.down) {
      node92Array[node92Array.length - 1].x = Mouse92.x;
      node92Array[node92Array.length - 1].y = Mouse92.y;
      node92Array[node92Array.length - 1].vx = node92Array[node92Array.length - 1].vy = 0;
    }
    
    for (let i = 0; i < node92Array.length; i++) node92Array[i].update();
    for (let i = 0; i < spring92Array.length; i++) spring92Array[i].update();
    
    ctx92.lineCap = ctx92.lineJoin = "round";
    ctx92.shadowColor = "black";
    ctx92.shadowBlur = 12;
    ctx92.lineWidth = 6;
    ctx92.beginPath();
    for (let i = 0; i < node92Array.length; i++) ctx92.lineTo(node92Array[i].x, node92Array[i].y);
    ctx92.stroke();
    ctx92.shadowBlur = 0;
    
    //for (let i = 0; i < spring92Array.length; i++) spring92Array[i].draw();
    //for (let i = 0; i < node92Array.length; i++) node92Array[i].draw();
    
    if (canvas92Running) requestAnimationFrame(frame92);
  }
  frame92();
  
  function startCanvas92() {
    if (canvas92Running) canvas92Running = false;
    else {
      canvas92Running = true;
      frame92();
    }
  }
  
  canvas92.addEventListener("mousedown", e => {
    if (!canvas92Running) return;
    Mouse92.down = true;
    canvas92Rect = canvas92.getBoundingClientRect();
    Mouse92.x = (e.clientX - canvas92Rect.left) * canvas92Ratio;
    Mouse92.y = (e.clientY - canvas92Rect.top) * canvas92Ratio;
  });
  canvas92.addEventListener("mousemove", e => {
    if (!canvas92Running || !Mouse92.down) return;
    Mouse92.down = true;
    canvas92Rect = canvas92.getBoundingClientRect();
    Mouse92.x = (e.clientX - canvas92Rect.left) * canvas92Ratio;
    Mouse92.y = (e.clientY - canvas92Rect.top) * canvas92Ratio;
  });
  window.addEventListener("mouseup", e => {
    Mouse92.down = false;
  });
</script>
<canvas id = "canvas91" style = "background-color: black; width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas91()">Start/Stop</button>
<br><br>
<button onclick = "node91Array = []; spring91Array = []; if (!canvas91Running) frame91()">Destroy Nodes</button>
<button onclick = "destroySprings91()">Destroy Springs</button>
<button onclick = "randomizeNodes91()">Randomize Nodes</button>
<button onclick = "addRandomNodes91(25)">+25 Nodes</button>
<table>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Hide Connected Nodes:</u></b></div>
      <input type = "checkbox" id = "hideConnectedNodes91Checkbox" oninput = "updateSettings91()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Destroy Springs After Contact:</u></b></div>
      <input type = "checkbox" id = "destroySprings91PerFrameCheckbox" oninput = "updateSettings91()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Node Velocity Damping:</u></b></div>
      <input type = "checkbox" id = "damping91OnCheckbox" oninput = "updateSettings91()" CHECKED>
    </td>
  </tr>
</table>
<div><b><u>Gravity:</u></b> <span id = "gravity91Txt">0.5</span></div>
<input type = "range" min = "-200" max = "200" value = "50" step = "25" id = "gravity91Range" oninput = "updateSettings91()">
<div><b><u>Spring Stiffness:</u></b> <span id = "springConst91Txt">85</span>%</div>
<input type = "range" min = "0" max = "500" value = "85" step = "25" id = "springConst91Range" oninput = "updateSettings91()">
<div><b><u>Spring Length:</u></b> <span id = "restLength91Txt">150</span>%</div>
<input type = "range" min = "50" max = "300" value = "150" step = "50" id = "restLength91Range" oninput = "updateSettings91()">
<div><b><u>Connection Radius:</u></b> <span id = "senseRadius91Txt">150</span>%</div>
<input type = "range" min = "50" max = "300" value = "150" step = "50" id = "senseRadius91Range" oninput = "updateSettings91()">
<div><b><u>Max Springs Per Node:</u></b> <span id = "maxConnections91Txt">8</span></div>
<input type = "range" min = "0" max = "15" value = "8" step = "1" id = "maxConnections91Range" oninput = "updateSettings91()">
<div class = "desc"><b><i>(10/6/2021)</i></b> Spring force simulation, which I finally got actually working. I basically cloned William Hoza's <a href = "https://williamhoza.com/sproing" target = "_blank">Sproing</a>, but with my own code that I think works better and I understand it. The basic system I wrote for nodes and connectors works really well and I think I can use it in lots of different ways.<br><b><i>Update: (Later that night)</i></b> Redid the spring system, so that it's a separate function for springs, instead of each node having a list of connected nodes that it refers to. I also implemented holding shift to delete clicked nodes, which was surprisingly difficult, but it works now. Also added more settings and sliders.</div>
<hr><hr>
<script>
  const ctx91 = canvas91.getContext("2d");
  canvas91.width = canvas91.height = 1000;
  let canvas91Running = false;
  let canvas91Rect = canvas91.getBoundingClientRect();
  let canvas91Ratio = canvas91.width / 400;
  
  let shiftDown91 = false;
  
  let Mouse91 = {
    down: false,
    x: 0,
    y: 0,
    touchingNode: false,
    touchingNodeIndex: 0,
    draggingColor: "#22a6f0",
    deletingColor: "#ff5c5c"
  };
  Mouse91.checkForTouching = function() {
    for (let i = 0; i < node91Array.length; i++) {
      let dx = this.x - node91Array[i].x;
      let dy = this.y - node91Array[i].y;
      let distSq = (dx * dx) + (dy * dy);
      if (distSq <= node91Radius * node91Radius * 9) {
        this.touchingNode = true;
        this.touchingNodeIndex = i;
        return;
      }
    }
    this.touchingNode = false;
  };
  
  let node91Radius = 12;
  let node91Color = "#22a6f0";
  let gravity91 = 0.5;
  let bounciness91 = 0.5;
  let friction91 = 0.1;
  let senseRadius91 = 150;
  let restLength91 = 150;
  let springConst91 = 0.85;
  let damping91 = 0.05;
  let maxConnections91 = 8;
  let maxNodes91 = 200;
  let hideConnectedNodes91 = false;
  let destroySprings91PerFrame = false;
  let damping91On = true;
  
  ctx91.lineJoin = ctx91.lineCap = "round";
  
  function Node91(x, y) {
    this.x = x;
    this.y = y;
    let a = Math.random() * Math.PI * 2;
    let m = randBetween(-5, 5);
    this.vx = m * Math.cos(a);
    this.vy = m * Math.sin(a);
    this.mass = randBetween(5, 20);
    this.senseRadiusRatio = randBetween(0.75, 1);
    this.connectedNodes = [];
    this.dead = false;
    this.springs = [];
  }
  Node91.prototype.update = function() {
    if (this.dead) return;
    if (damping91On) {
      this.vx *= 1 - damping91;
      this.vy *= 1 - damping91;
    }
    this.vy += gravity91;
    this.x += this.vx;
    this.y += this.vy;
    
    let top = node91Radius;
    let right = canvas91.width - node91Radius;
    let bottom = canvas91.height - node91Radius;
    let left = node91Radius;
    
    if (this.y < top) {
      this.y = top;
      this.vy *= -bounciness91;
      this.vx *= 1 - friction91;
    }
    if (this.y > bottom) {
      this.y = bottom;
      this.vy *= -bounciness91;
      this.vx *= 1 - friction91;
    }
    if (this.x < left) {
      this.x = left;
      this.vx *= -bounciness91;
    }
    if (this.x > right) {
      this.x = right;
      this.vx *= -bounciness91;
    }
    
    for (let i = 0; i < node91Array.length; i++) {
      if (i !== node91Array.indexOf(this)) {
        let dx = node91Array[i].x - this.x;
        let dy = node91Array[i].y - this.y;
        let distSq = (dx * dx) + (dy * dy);
        let r = senseRadius91 * this.senseRadiusRatio;
        let inRadius = distSq <= r * r;
        let notAlreadyConnected = !this.connectedNodes.includes(node91Array[i]) && !node91Array[i].connectedNodes.includes(this);
        let notMaxConnections = this.connectedNodes.length < maxConnections91 && node91Array[i].connectedNodes.length < maxConnections91;
        if (inRadius && notAlreadyConnected && notMaxConnections) {
          this.connectedNodes.push(node91Array[i]);
          node91Array[i].connectedNodes.push(this);
          let newSpring = new Spring91(this, node91Array[i], randBetween(0.5, 1), this.senseRadiusRatio);
          this.springs.push(newSpring);
          node91Array[i].springs.push(newSpring);
          spring91Array.push(newSpring);
        }
      }
    }
  };
  Node91.prototype.draw = function() {
    if (this.dead) return;
    let dragging = Mouse91.touchingNode && Mouse91.touchingNodeIndex === node91Array.indexOf(this);
    ctx91.fillStyle = node91Color;
    if (dragging) ctx91.fillStyle = shiftDown91 ? Mouse91.deletingColor : Mouse91.draggingColor;
    if (!hideConnectedNodes91 || (hideConnectedNodes91 && this.connectedNodes.length === 0)) ctx91.fillCircle(this.x, this.y, node91Radius);
    if (dragging) {
      ctx91.globalAlpha = 0.3;
      ctx91.fillCircle(this.x, this.y, node91Radius * 2);
      ctx91.globalAlpha = 1;
    }
  };
  let node91Array = [];
  
  function Spring91(node1, node2, stiffness, restLengthRatio) {
    this.node1 = node1;
    this.node2 = node2;
    this.stiffness = stiffness;
    this.restLengthRatio = restLengthRatio;
    this.dead = false;
  }
  Spring91.prototype.update = function() {
    if (this.dead) return;
    let dx = this.node1.x - this.node2.x;
    let dy = this.node1.y - this.node2.y;
    let dist = Math.sqrt((dx * dx) + (dy * dy));
    let displacement = dist - (restLength91 * this.restLengthRatio);
    let angle = Math.atan2(dy, dx);
    let force = -this.stiffness * springConst91 * displacement;
    let xComp = force * Math.cos(angle);
    let yComp = force * Math.sin(angle);
    this.node1.vx += xComp / this.node1.mass;
    this.node1.vy += yComp / this.node1.mass;
    this.node2.vx -= xComp / this.node2.mass;
    this.node2.vy -= yComp / this.node2.mass;
  };
  Spring91.prototype.draw = function() {
    if (this.dead) return;
    ctx91.strokeStyle = node91Color;
    let dragging1 = Mouse91.touchingNodeIndex === node91Array.indexOf(this.node1);
    let dragging2 = Mouse91.touchingNodeIndex === node91Array.indexOf(this.node2);
    let deleting = Mouse91.touchingNode && (dragging1 || dragging2) && shiftDown91;
    if (deleting) ctx91.strokeStyle = Mouse91.deletingColor
    ctx91.lineWidth = 3;
    ctx91.beginPath();
    ctx91.moveTo(this.node1.x, this.node1.y);
    ctx91.lineTo(this.node2.x, this.node2.y);
    ctx91.stroke();
    if (deleting) {
      ctx91.lineWidth = 12;
      ctx91.globalAlpha = 0.3;
      ctx91.stroke();
      ctx91.globalAlpha = 1;
    }
    if (destroySprings91PerFrame) this.dead = true;
  };
  let spring91Array = [];
  
  function destroySprings91() {
    spring91Array = [];
    
    for (let i = 0; i < node91Array.length; i++) {
      node91Array[i].connectedNodes = [];
      node91Array[i].springs = [];
    }
    
    if (!canvas91Running) frame91();
  }
  
  function randomizeNodes91() {
    destroySprings91();
    for (let i = 0; i < node91Array.length; i++) {
      let a = Math.random() * Math.PI * 2;
      let m = randBetween(-5, 5);
      node91Array[i].vx = m * Math.cos(a);
      node91Array[i].vy = m * Math.sin(a);
      node91Array[i].x = Math.random() * canvas91.width;
      node91Array[i].y = Math.random() * canvas91.height;
    }
    
    if (!canvas91Running) frame91();
  }
  
  function addRandomNodes91(num) {
    for (let i = 0; i < num; i++) node91Array.push(new Node91(Math.random() * canvas91.width, Math.random() * canvas91.height));
    
    if (!canvas91Running) frame91();
  }
  
  function frame91() {
    ctx91.clearRect(0, 0, canvas91.width, canvas91.height);
    
    if (!Mouse91.down) Mouse91.checkForTouching();
    canvas91.style.cursor = Mouse91.touchingNode ? "pointer" : "default";
    
    if (Mouse91.down && Mouse91.touchingNode && !shiftDown91) {
      node91Array[Mouse91.touchingNodeIndex].vx = (Mouse91.x - node91Array[Mouse91.touchingNodeIndex].x) / 4;
      node91Array[Mouse91.touchingNodeIndex].vy = (Mouse91.y - node91Array[Mouse91.touchingNodeIndex].y) / 4;
      node91Array[Mouse91.touchingNodeIndex].x = Mouse91.x;
      node91Array[Mouse91.touchingNodeIndex].y = Mouse91.y;
    }
    
    while (node91Array.length > maxNodes91) {
      node91Array[0].dead = true;
      for (let i = 0; i < node91Array[0].springs.length; i++) node91Array[0].springs[i].dead = true;
      node91Array.shift();
    }
    
    for (let i = 0; i < node91Array.length; i++) {
      node91Array[i].update();
      if (node91Array[i].dead) {
        for (let j = 0; j < node91Array[i].springs.length; j++) node91Array[i].springs[j].dead = true;
        node91Array.splice(i, 1);
        i--;
      }
    }
    for (let i = 0; i < spring91Array.length; i++) {
      spring91Array[i].update();
      if (spring91Array[i].dead) {
        spring91Array[i].node1.connectedNodes.splice(spring91Array[i].node1.connectedNodes.indexOf(node91Array.indexOf(spring91Array[i].node2)), 1);
        spring91Array[i].node2.connectedNodes.splice(spring91Array[i].node2.connectedNodes.indexOf(node91Array.indexOf(spring91Array[i].node1)), 1);
        spring91Array.splice(i, 1);
        i--;
      }
    }
    for (let i = 0; i < spring91Array.length; i++) spring91Array[i].draw();
    for (let i = 0; i < node91Array.length; i++) node91Array[i].draw();
    
    if (canvas91Running) requestAnimationFrame(frame91);
  }
  frame91();
  
  function startCanvas91() {
    if (canvas91Running) canvas91Running = false;
    else {
      canvas91Running = true;
      frame91();
    }
  }
  
  function updateSettings91() {
    gravity91 = gravity91Txt.innerHTML = Number(gravity91Range.value) / 100;
    springConst91 = Number(springConst91Range.value) / 100;
    springConst91Txt.innerHTML = springConst91Range.value;
    senseRadius91 = senseRadius91Txt.innerHTML = Number(senseRadius91Range.value);
    restLength91 = restLength91Txt.innerHTML = Number(restLength91Range.value);
    maxConnections91 = maxConnections91Txt.innerHTML = Number(maxConnections91Range.value);
    hideConnectedNodes91 = hideConnectedNodes91Checkbox.checked;
    destroySprings91PerFrame = destroySprings91PerFrameCheckbox.checked;
    damping91On = damping91OnCheckbox.checked;
  }
  
  canvas91.addEventListener("mousedown", e => {
    if (!canvas91Running) return;
    Mouse91.down = true;
    e.preventDefault();
    canvas91Rect = canvas91.getBoundingClientRect();
    Mouse91.x = (e.clientX - canvas91Rect.left) * canvas91Ratio;
    Mouse91.y = (e.clientY - canvas91Rect.top) * canvas91Ratio;
    
    Mouse91.checkForTouching();
    
    if (shiftDown91) {
      if (Mouse91.touchingNode) {
        node91Array[Mouse91.touchingNodeIndex].dead = true;
        Mouse91.touchingNode = false;
      }
    }
    else if (!Mouse91.touchingNode) node91Array.push(new Node91(Mouse91.x, Mouse91.y));
  });
  canvas91.addEventListener("mousemove", e => {
    if (!canvas91Running) return;
    e.preventDefault();
    canvas91Rect = canvas91.getBoundingClientRect();
    Mouse91.x = (e.clientX - canvas91Rect.left) * canvas91Ratio;
    Mouse91.y = (e.clientY - canvas91Rect.top) * canvas91Ratio;
    if (!Mouse91.down) {
      for (let i = 0; i < node91Array.length; i++) {
        let dx = Mouse91.x - node91Array[i].x;
        let dy = Mouse91.y - node91Array[i].y;
        let distSq = (dx * dx) + (dy * dy);
        if (distSq <= node91Radius * node91Radius * 9) {
          Mouse91.touchingNode = true;
          Mouse91.touchingNodeIndex = i;
          return;
        }
      }
      Mouse91.touchingNode = false;
    }
  });
  window.addEventListener("mouseup", e => {
    Mouse91.down = false;
    Mouse91.touchingNode = false;
  });
  window.addEventListener("keydown", e => {
    if (!canvas91Running) return;
    if (e.code === "ShiftLeft" || e.code === "ShiftRight") shiftDown91 = true;
  });
  window.addEventListener("keyup", e => {
    if (!canvas91Running) return;
    if (e.code === "ShiftLeft" || e.code === "ShiftRight") shiftDown91 = false;
  });
</script>
<canvas id = "canvas90" style = "background-image: radial-gradient(#754e2f, #402b19); width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas90()">Start/Stop</button>
<br><br>
<button onclick = "Snake90.hue = Math.random() * 360; if (!canvas90Running) Snake90.draw()">Change color</button>
<div class = "desc"><b><i>(10/1/2021)</i></b> More FABRIK experiments, this time it's just a simple little snake that follows the mouse cursor.<br><b><i>(10/3/2021)</i></b> Added shadow banding to the snake to give it more texture and gave the background a simple gradient.</div>
<hr><hr>
<script>
  const ctx90 = canvas90.getContext("2d");
  canvas90.width = canvas90.height = 1000;
  let canvas90Running = false;
  let canvas90Rect = canvas90.getBoundingClientRect();
  let canvas90Ratio = canvas90.width / 500;
  
  let Mouse90 = {
    x: 0,
    y: 0
  };
  
  let Snake90 = {
    body: [],
    segments: 200,
    bodyLength: 2000,
    headRadius: 60,
    tailRadius: 10,
    slideSpeed: 8,
    headBrightness: 25,
    tailBrightness: 65,
    eyeAngle: 0,
    hue: 120,
    banding: 3,
    bandColor: "black"
  };
  Snake90.resetBody = function() {
    this.body = [];
    let currX = -1500;
    let currY = 500;
    let len = this.bodyLength / (this.segments - 1);
    for (let i = 0; i < this.segments; i++) {
      this.body.push({x: currX, y: currY, segmentLength: len});
      currX += len;
    }
    Mouse90.x = currX;
    Mouse90.y = currY;
  };
  Snake90.resetBody();
  Snake90.draw = function() {
    ctx90.strokeStyle = "darkgreen";
    ctx90.lineCap = ctx90.lineJoin = "round";
    for (let i = 0; i < this.body.length; i++) {
      if (i !== this.body.length - 1) {
        ctx90.lineWidth = ((i / this.body.length) * (this.headRadius - this.tailRadius)) + this.tailRadius;
        ctx90.strokeStyle = `hsl(${this.hue}deg, 100%, ${((i / this.body.length) * (this.headBrightness - this.tailBrightness)) + this.tailBrightness}%)`;
        ctx90.shadowColor = this.bandColor;
        ctx90.shadowBlur = i % this.banding === 0 ? 5 : 0;
        ctx90.beginPath();
        ctx90.moveTo(this.body[i].x, this.body[i].y);
        ctx90.lineTo(this.body[i + 1].x, this.body[i + 1].y);
        ctx90.stroke();
        if (i === this.body.length - 2) {
          let angle = Math.atan2(this.body[i + 1].y - this.body[i].y, this.body[i + 1].x - this.body[i].x);
          let normal = angle + (Math.PI / 2);
          let eye1Y = this.body[i + 1].y + (12 * Math.sin(normal));
          let eye2Y = this.body[i + 1].y - (12 * Math.sin(normal));
          let eye1X = this.body[i + 1].x + (12 * Math.cos(normal));
          let eye2X = this.body[i + 1].x - (12 * Math.cos(normal));
          ctx90.shadowBlur = 0;
          ctx90.fillStyle = "white";
          ctx90.fillCircle(eye1X, eye1Y, 10);
          ctx90.fillCircle(eye2X, eye2Y, 10);
          ctx90.fillStyle = "black";
          ctx90.fillCircle(eye1X + (4 * Math.cos(angle + this.eyeAngle)), eye1Y + (4 * Math.sin(angle + this.eyeAngle)), 6);
          ctx90.fillCircle(eye2X + (4 * Math.cos(angle + this.eyeAngle)), eye2Y + (4 * Math.sin(angle + this.eyeAngle)), 6);
        }
      }
    }
  };
  Snake90.moveToPoint = function(x, y) {
    let currX = x;
    let currY = y;
    for (let i = this.body.length - 1; i >= 0; i--) {
      this.body[i].x = currX;
      this.body[i].y = currY;
      if (i !== 0) {
        let dx = this.body[i - 1].x - currX;
        let dy = this.body[i - 1].y - currY;
        let angle = Math.atan2(dy, dx);
        currX += this.body[i].segmentLength * Math.cos(angle);
        currY += this.body[i].segmentLength * Math.sin(angle);
      }
    }
  };
  Snake90.slideTowardsPoint = function(x, y) {
    let endX = this.body[this.body.length - 1].x;
    let endY = this.body[this.body.length - 1].y;
    let dx = x - endX;
    let dy = y - endY;
    let distSq = (dx * dx) + (dy * dy);
    let angle = Math.atan2(dy, dx);
    if (distSq <= this.slideSpeed * this.slideSpeed) return;
    else this.moveToPoint(endX + (this.slideSpeed * Math.cos(angle)), endY + (this.slideSpeed * Math.sin(angle)));
  };
  
  function frame90() {
    ctx90.clearRect(0, 0, canvas90.width, canvas90.height);
    
    Snake90.slideTowardsPoint(Mouse90.x, Mouse90.y);
    // Uncomment to show the difference between a FABRIK chain and just a list of visited points
    /*let endX = Snake90.body[Snake90.body.length - 1].x;
    let endY =  Snake90.body[Snake90.body.length - 1].y;
    let dx = Mouse90.x - endX;
    let dy = Mouse90.y - endY;
    let angle = Math.atan2(dy, dx);
    if ((dx * dx) + (dy * dy) > Snake90.slideSpeed * Snake90.slideSpeed) {
      Snake90.body.shift();
      Snake90.body.push({x: endX + (Snake90.slideSpeed * Math.cos(angle)), y: endY + (Snake90.slideSpeed * Math.sin(angle)), segmentLength: Snake90.body[0].segmentLength});
    }*/
    
    Snake90.draw();
    
    if (canvas90Running) requestAnimationFrame(frame90);
  }
  frame90();
  
  function startCanvas90() {
    if (canvas90Running) canvas90Running = false;
    else {
      canvas90Running = true;
      frame90();
    }
  }
  
  canvas90.addEventListener("mousemove", e => {
    if (!canvas90Running) return;
    e.preventDefault();
    canvas90Rect = canvas90.getBoundingClientRect();
    Mouse90.x = (e.clientX - canvas90Rect.left) * canvas90Ratio;
    Mouse90.y = (e.clientY - canvas90Rect.top) * canvas90Ratio;
  });
</script>
<canvas id = "canvas89" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas89()">Start/Stop</button>
<button onclick = "resetChains89()">Reset</button>
<button onclick = "randomizeChains89()">Randomize</button>
<br><br>
<button onclick = "Path89.sign *= -1">Switch Direction</button>
<div><b><u>Number of Lines:</u></b> <span id = "numChains89Txt">50</span></div>
<input type = "range" min = "1" max = "100" step = "1" value = "50" id = "numChains89Range" oninput = "updateSettings89(true)">
<div><b><u>Points Per Line:</u></b> <span id = "numPoints89Txt">100</span></div>
<input type = "range" min = "3" max = "100" step = "1" value = "100" id = "numPoints89Range" oninput = "updateSettings89(true)">
<div><b><u>Stiffness:</u></b> <span id = "t89Txt">100</span>%</div>
<input type = "range" min = "0" max = "100" step = "5" value = "100" id = "t89Range" oninput = "updateSettings89(false)">
<div><b><u>Path Radius:</u></b> <span id = "path89RadiusTxt">400</span>px</div>
<input type = "range" min = "100" max = "600" step = "5" value = "400" id = "path89RadiusRange" oninput = "updateSettings89(false)">
<div><b><u>Path Speed:</u></b> <span id = "path89VAngleTxt">1</span>x</div>
<input type = "range" min = "0" max = "10" step = "1" value = "3" id = "path89VAngleRange" oninput = "updateSettings89(false)">
<div class = "desc"><b><i>(10/1/2021)</i></b> Experimenting with different things that can be made with FABRIK chains. For coolest results, move the cursor in a circle. It kinda looks like pinching and pulling a cloth around.<br><b><i>Update: (Later that day)</i></b> Added a changeable path that the chains all snap to, or you can click and drag to override the path. Also added sliders and more settings.</div>
<hr><hr>
<script>
  const ctx89 = canvas89.getContext("2d");
  canvas89.width = canvas89.height = 1000;
  let canvas89Running = false;
  let canvas89Rect = canvas89.getBoundingClientRect();
  let canvas89Ratio = canvas89.width / 500;
  
  let t89 = 1;
  let numChains89 = 50;
  let numPoints89 = 100;
  let chain89Length = 1500;
  
  let Mouse89 = {
    down: false,
    x: 0,
    y: 0
  }
  
  let Path89 = {
    radius: 400,
    centerX: canvas89.width / 2,
    centerY: canvas89.height / 2,
    angle: 0,
    vAngle: 1,
    x: 0,
    y: 0,
    sign: 1
  };
  Path89.update = function() {
    this.angle += this.vAngle * this.sign;
    this.x = this.centerX + (this.radius * Math.cos(toRad(this.angle)));
    this.y = this.centerY + (this.radius * Math.sin(toRad(this.angle)));
  };
  
  function Chain89(x, y, totalLength, numPoints, orientation) {
    this.anchorX = x;
    this.anchorY = y;
    this.totalLength = totalLength;
    this.points = [];
    this.segmentLength = totalLength / (numPoints - 1);
    let currX = this.anchorX;
    let currY = this.anchorY;
    for (let i = 0; i < numPoints; i++) {
      this.points.push({x: currX, y: currY});
      currX += this.segmentLength * Math.cos(toRad(orientation));
      currY += this.segmentLength * Math.sin(toRad(orientation));
    }
    this.endX = this.points[this.points.length - 1].x;
    this.endY = this.points[this.points.length - 1].y;
  }
  Chain89.prototype.draw = function() {
    ctx89.lineWidth = 1;
    ctx89.lineJoin = ctx89.lineCap = "round";
    ctx89.beginPath();
    for (let i = 0; i < this.points.length; i++) ctx89.lineTo(this.points[i].x, this.points[i].y);
    ctx89.stroke();
  };
  Chain89.prototype.snapToPoint = function(x, y) {
    let oX = this.points[0].x;
    let oY = this.points[0].y;
    let currX = x;
    let currY = y;
    for (let i = this.points.length - 1; i >= 0; i--) {
      this.points[i].x = currX;
      this.points[i].y = currY;
      if (i !== 0) {
        let dx = this.points[i - 1].x - currX;
        let dy = this.points[i - 1].y - currY;
        let angle = Math.atan2(dy, dx);
        currX += this.segmentLength * Math.cos(angle);
        currY += this.segmentLength * Math.sin(angle);
      }
    }
    
    currX = oX;
    currY = oY;
    
    for (let i = 0; i < this.points.length; i++) {
      this.points[i].x = currX;
      this.points[i].y = currY;
      if (i !== this.points.length - 1) {
        let dx = this.points[i + 1].x - currX;
        let dy = this.points[i + 1].y - currY;
        let angle = Math.atan2(dy, dx);
        currX += this.segmentLength * Math.cos(angle);
        currY += this.segmentLength * Math.sin(angle);
      }
    }
    
    this.endX = this.points[this.points.length - 1].x;
    this.endY = this.points[this.points.length - 1].y;
  };
  Chain89.prototype.easeToPoint = function(x, y, t) {
    this.endX = this.points[this.points.length - 1].x;
    this.endY = this.points[this.points.length - 1].y;
    let p = lerp89(this.endX, this.endY, x, y, t);
    this.snapToPoint(p.x, p.y);
  };
  let chain89Array = [];
  
  function resetChains89() {
    chain89Array = [];
    for (let i = 0; i < numChains89; i++) {
      let a = (i / numChains89) * Math.PI * 2;
      let x = (canvas89.width / 2) + (canvas89.width * Math.cos(a));
      let y = (canvas89.height / 2) + (canvas89.height * Math.sin(a));
      chain89Array.push(new Chain89(x, y, chain89Length, numPoints89, toDeg(a) + 180));
    }
  }
  resetChains89();
  
  function randomizeChains89() {
    for (let i = 0; i < chain89Array.length; i++) chain89Array[i].snapToPoint(randBetween(-canvas89.width * 2, canvas89.width * 2), randBetween(-canvas89.height * 2, canvas89.height * 2));
  }
  
  function lerp89(x1, y1, x2, y2, t) {
    return {x: ((1 - t) * x1) + (t * x2), y: ((1 - t) * y1) + (t * y2)};
  }
  
  function frame89() {
    ctx89.clearRect(0, 0, canvas89.width, canvas89.height);
    
    Path89.update();
    
    for (let i = 0; i < chain89Array.length; i++) {
      if (Mouse89.down) chain89Array[i].snapToPoint(Mouse89.x, Mouse89.y);
      else {
        chain89Array[i].easeToPoint(Path89.x, Path89.y, t89);
      }
      chain89Array[i].draw();
    }
    
    if (canvas89Running) requestAnimationFrame(frame89);
  }
  frame89();
  
  function startCanvas89() {
    if (canvas89Running) canvas89Running = false;
    else {
      canvas89Running = true;
      frame89();
    }
  }
  
  let path89VAngleRangeArray = [0, 0.25, 0.5, 1, 2, 3, 4, 5];
  path89VAngleRange.max = path89VAngleRangeArray.length - 1;
  
  function updateSettings89(resetChains) {
    Path89.radius = path89RadiusTxt.innerHTML = Number(path89RadiusRange.value);
    Path89.vAngle = path89VAngleTxt.innerHTML = path89VAngleRangeArray[Number(path89VAngleRange.value)];
    t89 = Number(t89Range.value) / 100;
    t89Txt.innerHTML = t89Range.value;
    numChains89 = numChains89Txt.innerHTML = Number(numChains89Range.value);
    numPoints89 = numPoints89Txt.innerHTML = Number(numPoints89Range.value);
    
    if (resetChains) resetChains89();
  }
  
  canvas89.addEventListener("mousedown", e => {
    if (!canvas89Running) return;
    e.preventDefault();
    Mouse89.down = true;
    canvas89Rect = canvas89.getBoundingClientRect();
    Mouse89.x = (e.clientX - canvas89Rect.left) * canvas89Ratio;
    Mouse89.y = (e.clientY - canvas89Rect.top) * canvas89Ratio;
  });
  window.addEventListener("mouseup", e => {
    Mouse89.down = false;
  });
  canvas89.addEventListener("mousemove", e => {
    if (!canvas89Running || !Mouse89.down) return;
    e.preventDefault();
    canvas89Rect = canvas89.getBoundingClientRect();
    Mouse89.x = (e.clientX - canvas89Rect.left) * canvas89Ratio;
    Mouse89.y = (e.clientY - canvas89Rect.top) * canvas89Ratio;
  });
</script>
<canvas id = "canvas88"></canvas>
<button onclick = "startCanvas88()">Start/Stop</button>
<div class = "desc"><b><i>(9/30/2021)</i></b> Bezier Curve visualizer, the blue line is velocity and orange is the normal. You can drag the points around with the mouse.</div>
<hr><hr>
<script>
  const ctx88 = canvas88.getContext("2d");
  canvas88.width = canvas88.height = 1000;
  let canvas88Running = false;
  let canvas88Rect = canvas88.getBoundingClientRect();
  let canvas88Ratio = canvas88.width / 300;
  
  function lerp88(pointA, pointB, t) {
    return {x: ((1 - t) * pointA.x) + (t * pointB.x), y: ((1 - t) * pointA.y) + (t * pointB.y)};
  }
  
  let Mouse88 = {
    down: false,
    x: 0,
    y: 0,
    draggingPoint: false,
    draggingPointIndex: 0
  };
  
  let Curve88 = {
    t: 0,
    period: 200,
    points: [
      {
        x: 250,
        y: 830
      },
      {
        x: 415,
        y: 500
      },
      {
        x: 580,
        y: 460
      },
      {
        x: 750,
        y: 760
      }
    ],
    pointRadius: 15
  };
  Curve88.render = function() {
    if (Mouse88.draggingPoint) {
      this.points[Mouse88.draggingPointIndex].x = Mouse88.x;
      this.points[Mouse88.draggingPointIndex].y = Mouse88.y;
    }
    
    ctx88.strokeStyle = "black";
    ctx88.lineWidth = 5;
    ctx88.lineCap = ctx88.lineJoin = "round";
    ctx88.beginPath();
    ctx88.moveTo(this.points[0].x, this.points[0].y);
    ctx88.bezierCurveTo(this.points[1].x, this.points[1].y, this.points[2].x, this.points[2].y, this.points[3].x, this.points[3].y);
    ctx88.stroke();
    
    ctx88.lineWidth = 3;
    ctx88.beginPath();
    ctx88.moveTo(this.points[0].x, this.points[0].y);
    ctx88.lineTo(this.points[1].x, this.points[1].y);
    ctx88.stroke();
    ctx88.beginPath();
    ctx88.moveTo(this.points[2].x, this.points[2].y);
    ctx88.lineTo(this.points[3].x, this.points[3].y);
    ctx88.stroke();
    
    this.t += 1 / this.period;
    if (this.t > 1) this.t = 0;
    let A = lerp88(this.points[0], this.points[1], this.t);
    let B = lerp88(this.points[1], this.points[2], this.t);
    let C = lerp88(this.points[2], this.points[3], this.t);
    let D = lerp88(A, B, this.t);
    let E = lerp88(B, C, this.t);
    let F = lerp88(D, E, this.t);
    
    let t = this.t;
    let t2 = t * t;
    let polynomials = [
      (-3 * t2) + (6 * t) - 3,
      (9 * t2) - (12 * t) + 3,
      (-9 * t2) + (6 * t),
      6 * t2
    ];
    
    let velocityX = 0;
    let velocityY = 0;
    for (let i = 0; i < this.points.length; i++) {
      velocityX += this.points[i].x * polynomials[i];
      velocityY += this.points[i].y * polynomials[i];
    }
    let angle = Math.atan2(velocityY, velocityX);
    let velocity = {x: 50 * Math.cos(angle), y: 50 * Math.sin(angle)};
    let normal = {x: 50 * Math.cos(angle + (Math.PI / 2)), y: 50 * Math.sin(angle + (Math.PI / 2))};
    
    ctx88.lineWidth = 8;
    ctx88.strokeStyle = "blue";
    ctx88.beginPath();
    ctx88.moveTo(F.x, F.y);
    ctx88.lineTo(F.x + velocity.x, F.y + velocity.y);
    ctx88.stroke();
    ctx88.strokeStyle = "orange";
    ctx88.beginPath();
    ctx88.moveTo(F.x, F.y);
    ctx88.lineTo(F.x + normal.x, F.y + normal.y);
    ctx88.stroke();
    
    ctx88.fillStyle = "black";
    ctx88.fillCircle(F.x, F.y, 10);
    
    ctx88.fillStyle = "white";
    ctx88.strokeStyle = "black";
    ctx88.lineWidth = 5;
    for (let i = 0; i < this.points.length; i++) {
      ctx88.beginPath();
      ctx88.arc(this.points[i].x, this.points[i].y, this.pointRadius, 0, Math.PI * 2);
      ctx88.fill();
      ctx88.stroke();
    }
  };
  
  function frame88() {
    ctx88.clearRect(0, 0, canvas88.width, canvas88.height);
    
    Curve88.render();
    
    if (canvas88Running) requestAnimationFrame(frame88);
  }
  frame88();
  
  function startCanvas88() {
    if (canvas88Running) canvas88Running = false;
    else {
      canvas88Running = true;
      frame88();
    }
  }
  
  canvas88.addEventListener("mousedown", e => {
    if (!canvas88Running) return;
    e.preventDefault();
    Mouse88.down = true;
    canvas88Rect = canvas88.getBoundingClientRect();
    let eX = (e.clientX - canvas88Rect.left) * canvas88Ratio;
    let eY = (e.clientY - canvas88Rect.top) * canvas88Ratio;
    Mouse88.x = eX;
    Mouse88.y = eY;
    for (let i = 0; i < Curve88.points.length; i++) {
      let dx = Mouse88.x - Curve88.points[i].x;
      let dy = Mouse88.y - Curve88.points[i].y;
      let distSq = (dx * dx) + (dy * dy);
      if (distSq <= Curve88.pointRadius * Curve88.pointRadius * 4) {
        Mouse88.draggingPoint = true;
        Mouse88.draggingPointIndex = i;
        return;
      }
    }
  });
  canvas88.addEventListener("mousemove", e => {
    if (!canvas88Running || !Mouse88.down) return;
    e.preventDefault();
    canvas88Rect = canvas88.getBoundingClientRect();
    let eX = (e.clientX - canvas88Rect.left) * canvas88Ratio;
    let eY = (e.clientY - canvas88Rect.top) * canvas88Ratio;
    Mouse88.x = eX;
    Mouse88.y = eY;
  });
  window.addEventListener("mouseup", e => {
    Mouse88.down = false;
    Mouse88.draggingPoint = false;
  });
</script>
<canvas id = "canvas87" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas87()">Start/Stop</button>
<br><br>
<button id = "playPause87Btn" onclick = "playPause87()">Pause</button>
<button onclick = "reset87()">Clear</button>
<button onclick = "connectAllPoints87InOrder()">Connect All Points</button>
<br><br>
<button onclick = "makeRope87()">Make Rope</button>
<div><b><u>Edges:</u></b></div>
<input type = "checkbox" id = "edges87Checkbox" oninput = "edges87 = this.checked" CHECKED>
<div class = "desc"><b><i>(9/29/2021)</i></b> Rope simulation using <a href = "https://www.youtube.com/watch?v=PGk0rnyTa1U" target = "_blank">this</a> video at 6:43 as a reference.<br><b><i>Update: (Later that day)</i></b> I finally got everything working correctly. The Start/Stop button is the global canvasRunning button, so clicking that just stops or starts everything. But the Play/Pause button controls if the points and sticks update or not. If it's paused, you can click to add a new point, and drag a line between points to make a new stick, or if you click a point it'll switch between locked and unlocked. If it's playing, you can drag points around with the cursor. Currently it gets pretty glitchy when you try to drag an unlocked point, especially if you drag it out more than its stick's length, but I'm fine with that since it's kinda fun. There's a few bugs, like dragging one point doesn't always affect the one next to it (like if you make a rope and drag the first unlocked point), but I'm not sure how to fix them. Overall, this algorithm is really useful and it gives me lots of ideas, like replicating William Hoza's <a href = "https://williamhoza.com/sproing" target = "_blank">Sproing</a>, or a spring simulation, etc.<br><b><i>Update (Also later that day)</i></b> Added boundaries that the points bounce off of, currently I'm pretty happy with how they bounce, but it isn't perfect.</div>
<hr><hr>
<script>
  const ctx87 = canvas87.getContext("2d");
  canvas87.width = canvas87.height = 1000;
  let canvas87Running = false;
  let canvas87Rect = canvas87.getBoundingClientRect();
  let canvas87Ratio = canvas87.width / 400;
  
  let going87 = true;
  
  let gravity87 = 0.5;
  let stick87RenderIterations = 10;
  let point87Radius = 15;
  let edges87 = true;
  
  let Mouse87 = {
    down: false,
    draggingStick: false,
    draggingStickIndex: 0,
    draggingPoint: false,
    draggingPointIndex: 0
  };
  
  function Point87(x, y) {
    this.x = x;
    this.y = y;
    this.lastX = this.x;
    this.lastY = this.y;
    this.locked = false;
  }
  Point87.prototype.update = function() {
    if (this.locked) {
      this.lastX = this.x;
      this.lastY = this.y;
      return;
    }
    let beforeX = this.x;
    let beforeY = this.y;
    this.x += (this.x - this.lastX) * 0.99;
    this.y += (this.y - this.lastY) * 0.99;
    this.y += gravity87;
    
    if (edges87) {
      let left = point87Radius;
      let right = canvas87.width - point87Radius;
      let bottom = point87Radius;
      let top = canvas87.height - point87Radius;
      
      if (this.x <= left) {
        this.x = left;
        beforeX = left + (this.x - this.lastX) * 0.5;
      }
      if (this.x >= right) {
        this.x = right;
        beforeX = right + (this.x - this.lastX) * 0.5;
      }
      if (this.y <= bottom) {
        this.y = bottom;
        beforeY = bottom + (this.y - this.lastY) * 0.5;
      }
      if (this.y >= top) {
        this.y = top;
        beforeY = top + (this.y - this.lastY) * 0.5;
      }
    }
    
    this.lastX = beforeX;
    this.lastY = beforeY;
  };
  Point87.prototype.draw = function() {
    ctx87.lineWidth = 5;
    ctx87.strokeStyle = "black";
    ctx87.fillStyle = this.locked ? "black" : "white";;
    ctx87.beginPath();
    ctx87.arc(this.x, this.y, point87Radius, 0, Math.PI * 2);
    ctx87.fill();
    ctx87.stroke();
  };
  let point87Array = [];
  
  function Stick87(pointA, pointB) {
    this.pointA = pointA;
    this.pointB = pointB;
    let dx = this.pointA.x - this.pointB.x;
    let dy = this.pointA.y - this.pointB.y;
    this.restLength = Math.sqrt((dx * dx) + (dy * dy));
  }
  Stick87.prototype.update = function() {
    for (let i = 0; i < stick87RenderIterations; i++) {
      let midX = (this.pointA.x + this.pointB.x) / 2;
      let midY = (this.pointA.y + this.pointB.y) / 2;
      let dx = this.pointA.x - this.pointB.x;
      let dy = this.pointA.y - this.pointB.y;
      //let dist = Math.sqrt((dx * dx) + (dy * dy));
      let len = this.restLength//(dist + this.restLength) / 2;
      let angle = Math.atan2(dy, dx);
      let xComp = Math.cos(angle);
      let yComp = Math.sin(angle);
      if (!this.pointA.locked) {
        this.pointA.x = midX + ((xComp * len) / 2);
        this.pointA.y = midY + ((yComp * len) / 2);
      }
      if (!this.pointB.locked) {
        this.pointB.x = midX - ((xComp * len) / 2);
        this.pointB.y = midY - ((yComp * len) / 2);
      }
    }
  };
  Stick87.prototype.draw = function() {
    ctx87.lineWidth = 5;
    ctx87.strokeStyle = "black";
    ctx87.lineCap = ctx87.lineJoin = "round";
    ctx87.beginPath();
    ctx87.moveTo(this.pointA.x, this.pointA.y);
    ctx87.lineTo(this.pointB.x, this.pointB.y);
    ctx87.stroke();
  };
  let stick87Array = [];
  
  function connectAllPoints87InOrder() {
    stick87Array = [];
    for (let i = 0; i < point87Array.length; i++) {
      if (i !== point87Array.length - 1) stick87Array.push(new Stick87(point87Array[i], point87Array[i + 1]));
    }
    if (!canvas87Running) frame87();
  }
  function connectAllPoints87ByProximity(proximity) {
    let proxSq = proximity * proximity;
    let alreadyConnected = [];
    stick87Array = [];
    for (let i = 0; i < point87Array.length; i++) {
      for (let j = 0; j < point87Array.length; j++) {
        let beenConnected = false;
        for (let k = 0; k < alreadyConnected.length; k++) {
          if (alreadyConnected[k][0] === i && alreadyConnected[k][1] === j) beenConnected = true;
          if (alreadyConnected[k][0] === j && alreadyConnected[k][1] === i) beenConnected = true;
        }
        if (j !== i && !beenConnected) {
          let dx = point87Array[i].x - point87Array[j].x;
          let dy = point87Array[i].y - point87Array[j].y;
          let distSq = (dx * dx) + (dy * dy);
          if (distSq <= proxSq) {
            stick87Array.push(new Stick87(point87Array[i], point87Array[j]));
            alreadyConnected.push([i, j]);
          }
        }
      }
    }
    if (!canvas87Running) frame87();
  }
  
  function makeRope87() {
    reset87();
    for (let i = 0; i < 10; i++) {
      point87Array.push(new Point87(canvas87.width / 2, (canvas87.height / 2) + (i * 50)));
    }
    point87Array[0].locked = true;
    connectAllPoints87InOrder();
    playPause87();
  }
  makeRope87();
  
  function makeCloth87() {
    reset87();
    for (let x = -3; x < 3; x++) {
      for (let y = 0; y < 5; y++) {
        let newPoint = new Point87((canvas87.width / 2) + ((x + 0.5) * 100), (canvas87.height / 2) + (y * 100));
        if ((y === 0 && x === -3) || (y === 0 && x === 2)) newPoint.locked = true;
        point87Array.push(newPoint);
      }
    }
    connectAllPoints87ByProximity(150);
    playPause87();
  }
  
  function makeBox87(x, y) {
    let jitter = () => randBetween(-10, 10);
    let p1 = new Point87(x + jitter(), y + jitter());
    let p2 = new Point87(x + 50 + jitter(), y + jitter());
    let p3 = new Point87(x + jitter(), y + 50 + jitter());
    let p4 = new Point87(x + 50 + jitter(), y + 50 + jitter());
    let s1 = new Stick87(p1, p2);
    let s2 = new Stick87(p2, p3);
    let s3 = new Stick87(p3, p4);
    let s4 = new Stick87(p4, p1);
    let s5 = new Stick87(p1, p3);
    let s6 = new Stick87(p2, p4);
    point87Array.push(p1, p2, p3, p4);
    stick87Array.push(s1, s2, s3, s4, s5, s6);
  }
  
  function frame87() {
    ctx87.clearRect(0, 0, canvas87.width, canvas87.height);
    
    if (going87) {
      for (let i = 0; i < point87Array.length; i++) point87Array[i].update();
      for (let i = 0; i < stick87Array.length; i++) stick87Array[i].update();
    }
    
    if (Mouse87.draggingStick) {
      ctx87.lineWidth = 5;
      ctx87.strokeStyle = "black";
      ctx87.lineCap = ctx87.lineJoin = "round";
      ctx87.beginPath();
      ctx87.moveTo(point87Array[Mouse87.draggingStickIndex].x, point87Array[Mouse87.draggingStickIndex].y);
      ctx87.lineTo(Mouse87.x, Mouse87.y);
      ctx87.stroke();
    }
    else if (Mouse87.draggingPoint) {
      point87Array[Mouse87.draggingPointIndex].x = Mouse87.x;
      point87Array[Mouse87.draggingPointIndex].y = Mouse87.y;
    }
    
    for (let i = 0; i < stick87Array.length; i++) stick87Array[i].draw();
    for (let i = 0; i < point87Array.length; i++) point87Array[i].draw();
    
    if (canvas87Running) requestAnimationFrame(frame87);
    //if (canvas87Running) setTimeout(() => requestAnimationFrame(frame87), 100);
  }
  frame87();
  
  function startCanvas87() {
    if (canvas87Running) canvas87Running = false;
    else {
      canvas87Running = true;
      frame87();
    }
  }
  
  function playPause87() {
    if (going87) {
      going87 = false;
      playPause87Btn.innerHTML = "Play";
    }
    else {
      going87 = true;
      playPause87Btn.innerHTML = "Pause";
    }
  }
  
  function reset87() {
    point87Array = [];
    stick87Array = [];
    going87 = false;
    playPause87Btn.innerHTML = "Play";
    if (!canvas87Running) frame87();
  }
  
  canvas87.addEventListener("mousedown", e => {
    if (!canvas87Running) return;
    e.preventDefault();
    Mouse87.down = true;
    canvas87Rect = canvas87.getBoundingClientRect();
    let eX = (e.clientX - canvas87Rect.left) * canvas87Ratio;
    let eY = (e.clientY - canvas87Rect.top) * canvas87Ratio;
    Mouse87.x = eX;
    Mouse87.y = eY;
    if (!going87) {
      for (let i = 0; i < point87Array.length; i++) {
        let dx = eX - point87Array[i].x;
        let dy = eY - point87Array[i].y;
        let distSq = (dx * dx) + (dy * dy);
        if (distSq <= point87Radius * point87Radius * 4) {
          Mouse87.draggingStick = true;
          Mouse87.draggingStickIndex = i;
          return;
        }
      }
      point87Array.push(new Point87(eX, eY));
    }
    else {
      for (let i = 0; i < point87Array.length; i++) {
        let dx = eX - point87Array[i].x;
        let dy = eY - point87Array[i].y;
        let distSq = (dx * dx) + (dy * dy);
        if (distSq <= point87Radius * point87Radius * 4) {
          Mouse87.draggingPoint = true;
          Mouse87.draggingPointIndex = i;
          return;
        }
      }
    }
  });
  canvas87.addEventListener("mousemove", e => {
    if (!canvas87Running || !Mouse87.down) return;
    e.preventDefault();
    canvas87Rect = canvas87.getBoundingClientRect();
    let eX = (e.clientX - canvas87Rect.left) * canvas87Ratio;
    let eY = (e.clientY - canvas87Rect.top) * canvas87Ratio;
    Mouse87.x = eX;
    Mouse87.y = eY;
  });
  canvas87.addEventListener("mouseup", e => {
    if (!canvas87Running) return;
    Mouse87.down = false;
    Mouse87.draggingPoint = false;
    if (!Mouse87.draggingStick || going87) return;
    canvas87Rect = canvas87.getBoundingClientRect();
    let eX = (e.clientX - canvas87Rect.left) * canvas87Ratio;
    let eY = (e.clientY - canvas87Rect.top) * canvas87Ratio;
    for (let i = 0; i < point87Array.length; i++) {
      let dx = eX - point87Array[i].x;
      let dy = eY - point87Array[i].y;
      let distSq = (dx * dx) + (dy * dy);
      if (distSq <= point87Radius * point87Radius * 4) {
        if (i !== Mouse87.draggingStickIndex) {
          Mouse87.draggingStick = false;
          stick87Array.push(new Stick87(point87Array[Mouse87.draggingStickIndex], point87Array[i]));
          return;
        }
        else point87Array[i].locked = !point87Array[i].locked;
      }
    }
    Mouse87.draggingStick = false;
  });
</script>
<canvas id = "canvas86" style = "background-color: black; width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas86()">Start/Stop</button>
<button onclick = "anchorChain86 = !anchorChain86; if (!canvas86Running) frame86()">Toggle Anchor Point</button>
<div><b><u>Elastic Cursor Following:</u></b></div>
<input type = "checkbox" id = "elasticChain86Checkbox" oninput = "elasticChain86 = this.checked">
<div><b><u>Chain Size:</u></b> <span id = "chain86LinkCountTxt">6</span> links</div>
<input type = "range" min = "0" max = "20" step = "1" value = "4" id = "chain86LinkCountRange" oninput = "updateSettings86()">
<div><b><u>Show Joints:</u></b></div>
<input type = "checkbox" id = "showJoints86Checkbox" oninput = "showJoints86 = this.checked" CHECKED>
<div class = "desc"><b><i>(9/28/2021)</i></b> Simple simulation of something like a string or rope being pulled behind the mouse, using an implementation that I wrote of the surprisingly simple and fast <a href = "http://andreasaristidou.com/FABRIK.html" target = "_blank">FABRIK algorithm</a>. I wanted it to be like some robotic arm reaching towards the cursor, but accidentally discovered this string thing by having it not reconstrain to the original point. I might later make another project with the robotic arm, but I like this one for now. There are 100 individual segments in the chain, FABRIK-ing to the cursor each frame.<br><b><i>Update: (Later that day)</i></b> Made the string follow the cursor more dynamically, as if it's stretching, and also added settings and sliders. Click and drag to pull the string along.<br><b><i>Update: (15 or so minutes later)</i></b> I figured out I can just go back through the FABRIK algorithm backwards one more time to make the string anchored to a point, so I added a checkbox for that and a checkbox to make the string either follow the cursor slowly or follow it exactly.</div>
<hr><hr>
<script>
  const ctx86 = canvas86.getContext("2d");
  canvas86.width = canvas86.height = 1000;
  let canvas86Running = false;
  let canvas86Rect = canvas86.getBoundingClientRect();
  let canvas86Ratio = canvas86.width / 400;
  
  let Mouse86 = {
    down: false,
    x: 0,
    y: 0
  };
  
  let totalChain86Length = 600;
  let chain86LinkCount = 7;
  let chain86SegmentLength = totalChain86Length / (chain86LinkCount - 1);
  let anchorChain86 = true;
  let elasticChain86 = false;
  let showJoints86 = true;
  
  let chain86 = [];
  for (let i = 0; i < chain86LinkCount; i++) {
    chain86.push({
      x: (canvas86.width / 2) + (i * chain86SegmentLength),
      y: canvas86.height / 2,
      segmentLength: chain86SegmentLength
    });
  }
  
  function FABRIKToPoint(x, y) {
    let oX = chain86[0].x;
    let oY = chain86[0].y;
    let endX = x;
    let endY = y;
    for (let i = chain86.length - 1; i >= 0; i--) {
      chain86[i].x = endX;
      chain86[i].y = endY;
      if (i !== 0) {
        let dx = chain86[i - 1].x - endX;
        let dy = chain86[i - 1].y - endY;
        let angle = Math.atan2(dy, dx);
        endX += chain86[i].segmentLength * Math.cos(angle);
        endY += chain86[i].segmentLength * Math.sin(angle);
      }
    }
    
    if (!anchorChain86) return;
    
    endX = oX;
    endY = oY;
    
    for (let i = 0; i < chain86.length; i++) {
      chain86[i].x = endX;
      chain86[i].y = endY;
      if (i !== chain86.length - 1) {
        let dx = chain86[i + 1].x - endX;
        let dy = chain86[i + 1].y - endY;
        let angle = Math.atan2(dy, dx);
        endX += chain86[i].segmentLength * Math.cos(angle);
        endY += chain86[i].segmentLength * Math.sin(angle);
      }
    }
  }
  
  function frame86() {
    ctx86.clearRect(0, 0, canvas86.width, canvas86.height);
    
    if (Mouse86.down) {
      let endX = chain86[chain86.length - 1].x;
      let endY = chain86[chain86.length - 1].y;
      let dx = Mouse86.x - endX;
      let dy = Mouse86.y - endY;
      let angle = Math.atan2(dy, dx);
      let dist = Math.max(Math.sqrt((dx * dx) + (dy * dy)) / 10, 2);
      if (elasticChain86) FABRIKToPoint(endX + (dist * Math.cos(angle)), endY + (dist * Math.sin(angle)));
      else FABRIKToPoint(Mouse86.x, Mouse86.y);
    }
    
    ctx86.lineCap = ctx86.lineJoin = "round";
    ctx86.beginPath();
    for (let i = 0; i < chain86.length; i++) ctx86.lineTo(chain86[i].x, chain86[i].y);
    ctx86.strokeStyle = "yellow";
    ctx86.lineWidth = 5;
    ctx86.stroke();
    
    if (showJoints86) {
      ctx86.fillStyle = "yellow";
      for (let i = 0; i < chain86.length; i++) ctx86.fillCircle(chain86[i].x, chain86[i].y, 10);
    }
    
    if (anchorChain86) {
      ctx86.fillStyle = "orange";
      ctx86.fillCircle(chain86[0].x, chain86[0].y, 15);
    }
    
    if (canvas86Running) requestAnimationFrame(frame86);
  }
  frame86();
  
  function reset86() {
    chain86SegmentLength = totalChain86Length / (chain86LinkCount - 1);
    
    chain86 = [];
    for (let i = 0; i < chain86LinkCount; i++) {
      chain86.push({
        x: (canvas86.width / 2) + (i * chain86SegmentLength),
        y: canvas86.height / 2,
        segmentLength: chain86SegmentLength
      });
    }
    if (!canvas86Running) frame86();
  }
  
  function startCanvas86() {
    if (canvas86Running) canvas86Running = false;
    else {
      canvas86Running = true;
      frame86();
    }
  }
  
  let chain86LinkCountRangeArray = [2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 50, 75, 100, 150, 200];
  chain86LinkCountRange.max = chain86LinkCountRangeArray.length - 1;
  
  function updateSettings86() {
    chain86LinkCount = chain86LinkCountRangeArray[Number(chain86LinkCountRange.value)] + 1;
    chain86LinkCountTxt.innerHTML = chain86LinkCountRangeArray[Number(chain86LinkCountRange.value)];
    
    reset86();
  }
  
  canvas86.addEventListener("mousedown", e => {
    if (!canvas86Running) return;
    e.preventDefault();
    Mouse86.down = true;
    canvas86Rect = canvas86.getBoundingClientRect();
    let eX = (e.clientX - canvas86Rect.left) * canvas86Ratio;
    let eY = (e.clientY - canvas86Rect.top) * canvas86Ratio;
    Mouse86.x = eX;
    Mouse86.y = eY;
  });
  window.addEventListener("mouseup", e => {
    Mouse86.down = false;
  });
  canvas86.addEventListener("mousemove", e => {
    if (!canvas86Running || !Mouse86.down) return;
    e.preventDefault();
    canvas86Rect = canvas86.getBoundingClientRect();
    let eX = (e.clientX - canvas86Rect.left) * canvas86Ratio;
    let eY = (e.clientY - canvas86Rect.top) * canvas86Ratio;
    Mouse86.x = eX;
    Mouse86.y = eY;
  });
</script>
<canvas id = "canvas85" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas85()">Start/Stop</button>
<button onclick = "Ellipse85.reset()">Reset</button>
<button onclick = "Ellipse85.globalSign *= -1; Ellipse85.reset()">Switch Direction</button>
<div style = "color: gray; font-style: italic; font-size: 12">FPS: <span id = "fps85Txt">0</span></div>
<div><b><u>Animation Speed:</u></b> <span id = "ellipse85StepsPerFrameTxt">3</span>x</div>
<input type = "range" min = "0" max = "10" step = "1" value = "2" id = "ellipse85StepsPerFrameRange" oninput = "updateSettings85()">
<div><b><u>Turn Speed:</u></b> <span id = "ellipse85InitialTurnSpeedTxt">2</span>&deg;</div>
<input type = "range" min = "0" max = "10" step = "1" value = "5" id = "ellipse85InitialTurnSpeedRange" oninput = "updateSettings85()">
<div><b><u>Turn Speed Increase:</u></b> <span id = "ellipse85TurnAccelerationTxt">0</span>&deg;</div>
<input type = "range" min = "0" max = "200" step = "5" value = "0" id = "ellipse85TurnAccelerationRange" oninput = "updateSettings85()">
<div><b><u>Size:</u></b> <span id = "ellipse85InitialSizeTxt">600</span>px</div>
<input type = "range" min = "400" max = "2000" step = "100" value = "600" id = "ellipse85InitialSizeRange" oninput = "updateSettings85()">
<div><b><u>Size Ratio:</u></b> <span id = "ellipse85HeightRatioTxt">50</span>%</div>
<input type = "range" min = "5" max = "95" step = "5" value = "50" id = "ellipse85HeightRatioRange" oninput = "updateSettings85()">
<div><b><u>Line Width:</u></b> <span id = "ellipse85LineWidthTxt">1</span>px</div>
<input type = "range" min = "0" max = "10" step = "1" value = "6" id = "ellipse85LineWidthRange" oninput = "updateSettings85()">
<div><b><u>Hue:</u></b> <span id = "ellipse85HueTxt">60</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "15" value = "60" id = "ellipse85HueRange" oninput = "updateSettings85()">
<div><b><u>Opacity:</u></b> <span id = "ellipse85OpacityTxt">100</span>%</div>
<input type = "range" min = "5" max = "100" step = "5" value = "100" id = "ellipse85OpacityRange" oninput = "updateSettings85()">
<div class = "desc"><b><I>(9/28/2021)</i></b> Rotating ellipses tangent inside of each other, using <a href = "https://commons.wikimedia.org/wiki/File:Nested_Ellipses.png">https://commons.wikimedia.org/wiki/File:Nested_Ellipses.png</a> as a reference.<br><b><i>Update: (Later that day)</i></b> Added lots of settings and sliders.</div>
<hr><hr>
<script>
  const ctx85 = canvas85.getContext("2d");
  canvas85.width = canvas85.height = 1000;
  let canvas85Running = false;
  
  let Ellipse85 = {
    x: canvas85.width / 2,
    y: canvas85.height / 2,
    angle: 0,
    lastAngle: 0,
    radiusX: 0,
    lastRadiusX: 0,
    radiusY: 0,
    lastRadiusY: 0,
    turnSpeed: 0,
    lineWidth: 1,
    initialSize: 600,
    heightRatio: 0.5,
    stopped: false,
    initialTurnSpeed: 2,
    turnAcceleration: 0,
    initialAngle: 135,
    stepsPerFrame: 3,
    hue: 60,
    opacity: 1,
    globalSign: 1
  };
  Ellipse85.render = function() {
    if (this.stopped) return;
    for (let i = 0; i < this.stepsPerFrame; i++) {
      this.angle = (this.angle + 180) % 180;
      let diff = ((this.angle - this.lastAngle) + 180) % 180;
      let delta = ((this.lastRadiusX / this.lastRadiusY) - (this.lastRadiusY / this.lastRadiusX)) * Math.sin(toRad(diff));
      let scale = Math.sqrt(1 + ((delta * delta) / 4)) - (delta / 2);
      this.radiusX = this.lastRadiusX * scale;
      this.radiusY = this.lastRadiusY * scale;
      
      if (this.radiusX * 4 < this.lineWidth && this.radiusY * 4 < this.lineWidth) {
        this.stopped = true;
        return;
      }
      
      ctx85.globalAlpha = this.opacity;
      ctx85.lineWidth = this.lineWidth;
      ctx85.strokeStyle = `hsl(${this.hue}deg, 100%, 50%)`;
      ctx85.beginPath();
      ctx85.ellipse(this.x, this.y, this.radiusX, this.radiusY, toRad(this.angle), 0, Math.PI * 2);
      ctx85.stroke();
      
      this.lastAngle = this.angle;
      this.lastRadiusX = this.radiusX;
      this.lastRadiusY = this.radiusY;
      this.angle += this.turnSpeed * this.globalSign;
      this.turnSpeed += this.turnAcceleration;
    }
  };
  Ellipse85.reset = function() {
    ctx85.clearRect(0, 0, canvas85.width, canvas85.height);
    this.radiusX = this.lastRadiusX = this.initialSize;
    this.radiusY = this.lastRadiusY = this.initialSize * this.heightRatio;
    this.angle = this.lastAngle = this.initialAngle;
    this.turnSpeed = this.initialTurnSpeed;
    this.stopped = false;
    if (!canvas85Running) frame85();
  };
  
  let lastFrame85Time = 0;
  let lastFps85DisplayTime = 1000;
  
  function frame85() {
    if (Date.now() - lastFps85DisplayTime >= 500) {
      fps85Txt.innerHTML = Math.floor(1000 / (Date.now() - lastFrame85Time));
      lastFps85DisplayTime = Date.now();
    }
    lastFrame85Time = Date.now();
    
    Ellipse85.render();
    
    if (canvas85Running) requestAnimationFrame(frame85);
  }
  
  Ellipse85.reset();
  
  function startCanvas85() {
    if (canvas85Running) canvas85Running = false;
    else {
      canvas85Running = true;
      frame85();
    }
  }
  
  let ellipse85InitialTurnSpeedRangeArray = [0.1, 0.25, 0.5, 1, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 45, 60];
  ellipse85InitialTurnSpeedRange.max = ellipse85InitialTurnSpeedRangeArray.length - 1;
  
  let ellipse85StepsPerFrameRangeArray = [1, 2, 3, 4, 5, 10, 20, 30, 40, 50, 100];
  ellipse85StepsPerFrameRange.max = ellipse85StepsPerFrameRangeArray.length - 1;
  
  let ellipse85LineWidthRangeArray = [0.1, 0.15, 0.2, 0.25, 0.3, 0.5, 1, 1.5, 2, 5];
  ellipse85LineWidthRange.max = ellipse85LineWidthRangeArray.length - 1;
  
  function updateSettings85() {
    Ellipse85.initialTurnSpeed = ellipse85InitialTurnSpeedTxt.innerHTML = ellipse85InitialTurnSpeedRangeArray[Number(ellipse85InitialTurnSpeedRange.value)];
    Ellipse85.turnAcceleration = ellipse85TurnAccelerationTxt.innerHTML = Number(ellipse85TurnAccelerationRange.value) / 100;
    Ellipse85.heightRatio = Number(ellipse85HeightRatioRange.value) / 100;
    Ellipse85.initialSize = ellipse85InitialSizeTxt.innerHTML = Number(ellipse85InitialSizeRange.value);
    ellipse85HeightRatioTxt.innerHTML = Number(ellipse85HeightRatioRange.value);
    Ellipse85.stepsPerFrame = ellipse85StepsPerFrameTxt.innerHTML = ellipse85StepsPerFrameRangeArray[Number(ellipse85StepsPerFrameRange.value)];
    Ellipse85.lineWidth = ellipse85LineWidthTxt.innerHTML = ellipse85LineWidthRangeArray[Number(ellipse85LineWidthRange.value)];
    Ellipse85.opacity = Number(ellipse85OpacityRange.value) / 100;
    ellipse85OpacityTxt.innerHTML = Number(ellipse85OpacityRange.value);
    Ellipse85.hue = ellipse85HueTxt.innerHTML = Number(ellipse85HueRange.value);
    
    Ellipse85.reset();
  }
</script>
<canvas id = "canvas84"></canvas>
<button onclick = "tilingMode84 = 1; drawGrid84()">Square Tessellation</button>
<button onclick = "tilingMode84 = 2; drawGrid84()">Triangular Tessellation</button>
<div class = "desc"><b><i>(9/27/2021)</i></b> An experiment to try to make different kind of grid tilings. The square tiling works (obviously) but triangular doesn't work at all and I want to add different types like on <a href = "https://en.wikipedia.org/wiki/Tessellation" target = "_blank">this</a> Wikpedia page.</div>
<hr><hr>
<script>
  const ctx84 = canvas84.getContext("2d");
  canvas84.width = canvas84.height = 300;
  
  let gridSize84 = 10;
  let tilingMode84 = 1; // 1: Square | 2: Triangle
  let tileSize84 = canvas84.width / gridSize84;
  
  function drawGrid84() {
    ctx84.clearRect(0, 0, canvas84.width, canvas84.height);
    tileSize84 = canvas84.width / gridSize84;
    if (tilingMode84 === 1) { // Square
      for (let x = 0; x < gridSize84; x++) {
        for (let y = 0; y < gridSize84; y++) {
          ctx84.strokeRect(x * tileSize84, y * tileSize84, tileSize84, tileSize84);
        }
      }
    }
    else if (tilingMode84 === 2) { // Triangular
      for (let x = 0; x < gridSize84; x++) {
        for (let y = 0; y < gridSize84; y++) {
          if (y % 2 === 0) drawTriangle84(x * tileSize84, y * tileSize84, tileSize84, true);
          else drawTriangle84((x + 0.5) * tileSize84, y * tileSize84, tileSize84, false);
        }
      }
    }
  }
  drawGrid84();
  
  function drawTriangle84(x, y, size, upsideDown) {
    ctx84.beginPath();
    ctx84.moveTo(x, y);
    ctx84.lineTo(x + size, y);
    if (upsideDown) ctx84.lineTo(x + size + (size * Math.cos(toRad(120))), y + (size * Math.sin(toRad(120))));
    else ctx84.lineTo(x + size + (size * Math.cos(toRad(120))), y - (size * Math.sin(toRad(120))));
    ctx84.lineTo(x, y);
    ctx84.stroke();
  }
</script>
<canvas id = "canvas83" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas83()">Start/Stop</button>
<button onclick = "reset83()">Reset</button>
<button onclick = "if (!canvas83Running) frame83()">Step</button>
<div><b><u>Current Angle:</u></b> <span id = "currentAngle83Txt">0</span>&deg;</div>
<div><b><u>Loop Animation:</u></b></div>
<input type = "checkbox" id = "loop83Checkbox" oninput = "loop83 = this.checked" CHECKED>
<div><b><u>Speed Up:</u></b></div>
<input type = "checkbox" id = "turbo83Checkbox" oninput = "turbo83 = this.checked">
<div><b><u>Alternate Turning Directions:</u></b></div>
<input type = "checkbox" id = "alternateDirections83Checkbox" oninput = "updateSettings83()" CHECKED>
<br>
<button onclick = "globalSign83 *= -1; updateSettings83()">Reverse Global Direction</button>
<br>
<div><b><u>Tiling Size:</u></b> <span id = "gridSize83Txt">6x6</span></div>
<input type = "range" min = "1" max = "12" step = "1" value = "6" id = "gridSize83Range" oninput = "updateSettings83()">
<div><b><u>Turn Size:</u></b> <span id = "turnSpeed83Txt">3</span>&deg;</div>
<input type = "range" min = "0" max = "15" step = "1" value = "4" id = "turnSpeed83Range" oninput = "updateSettings83()">
<div><b><u>Hue:</u></b> <span id = "hue83Txt">120</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "15" value = "120" id = "hue83Range" oninput = "updateSettings83()">
<div><b><u>Brightness:</u></b> <span id = "brightness83Txt">50</span>%</div>
<input type = "range" min = "20" max = "80" step = "5" value = "50" id = "brightness83Range" oninput = "updateSettings83()">
<div><b><u>Line Width:</u></b> <span id = "lineWidth83Txt">1</span>px</div>
<input type = "range" min = "25" max = "200" step = "25" value = "100" id = "lineWidth83Range" oninput = "updateSettings83()">
<br><br>
<button onclick = "exportCanvas83()">Export canvas</button>
<br><br>
<img id = "canvas83Img" style = "width: 150px; height: 150px; background-color: black">
<div class = "desc"><b><i>(9/26/2021)</i></b> An attempt to replicate the rotating squares design from <a href = "http://4.bp.blogspot.com/-jcJyCoSa2lg/UdKcU0mxf-I/AAAAAAAACp8/zCUlfvcedTg/s400/tiling_by_nested_squares_02.gif" target = "_blank">this</a> gif, but I can't get it working at all and the trigonometry is driving me crazy.<br><b><i>Update: (A few seconds later)</i></b> Realized I had it all down fine, but forgot to convert to radians. Now the basic idea is working.<br><b><i>Update: (About 15 minutes later)</i></b> I got it all working properly and there's a whole grid and it cycles. I might want to do something more with this idea eventually but I'm happy with it for now. Also rotated it 45 degrees and added color. Basically the way this works is each square is rotated by a set angle each step, and then scaled down so that it is tangent with the inside of it's previous size and angle square.<br><b><i>(9/27/2021)</i></b> Added export canvas button to allow for mobile downloading, and added more settings and sliders.</div>
<hr><hr>
<script>
  const ctx83 = canvas83.getContext("2d");
  canvas83.width = canvas83.height = 1000;
  let canvas83Running = false;
  
  let gridSize83 = 6;
  let tileSize83 = canvas83.width / gridSize83;
  let hue83 = 120;
  let brightness83 = 50;
  let lineWidth83 = 1;
  let turnSpeed83 = 3;
  let alternateDirections83 = true;
  let globalSign83 = 1;
  
  let clear83 = false;
  let loop83 = true;
  let turbo83 = false;
  
  ctx83.translate(canvas83.width / 2, canvas83.height / 2);
  ctx83.rotate(Math.PI / 4);
  ctx83.fillStyle = "black";
  ctx83.fillRect(-canvas83.width, -canvas83.height, canvas83.width * 2, canvas83.height * 2);
  
  function Square83(x, y, initialSize, turnSign) {
    this.x = x;
    this.y = y;
    this.initialSize = initialSize * Math.SQRT1_2;
    this.size = this.initialSize;
    this.angle = 0;
    this.turnSign = turnSign;
    this.lastSize = this.size;
    this.lastAngle = this.angle;
  }
  Square83.prototype.render = function() {
    if (this.size < 0.25) clear83 = true;
    if (this.size < 0.001) this.size = this.lastSize = 0;
    this.angle = (this.angle + 90) % 90;
    let diff = ((this.angle - this.lastAngle) + 90) % 90;
    this.size = this.lastSize / (Math.sin(toRad(90 - diff)) + Math.cos(toRad(90 - diff)));
    let currA = this.angle + 45;
    ctx83.beginPath();
    for (let i = 0; i <= 4; i++) {
      currA += 90;
      ctx83.lineTo(this.x + (this.size * Math.cos(toRad(currA))), this.y + (this.size * Math.sin(toRad(currA))));
    }
    ctx83.stroke();
    this.lastAngle = this.angle;
    this.lastSize = this.size;
    this.angle += turnSpeed83 * this.turnSign;
  };
  let square83Array = [];
  for (let x = -3; x < gridSize83 + 3; x++) {
    for (let y = -3; y < gridSize83 + 3; y++) {
      let turnSign = ((x + y) % 2 === 0) ? 1 : -1;
      if (!alternateDirections83) turnSign = 1;
      turnSign *= globalSign83;
      square83Array.push(new Square83((x * tileSize83) + (tileSize83 / 2) - (canvas83.width / 2), (y * tileSize83) + (tileSize83 / 2) - (canvas83.height / 2), tileSize83, turnSign));
    }
  }
  
  function frame83() {
    let iterations = turbo83 ? 5 : 1;
    ctx83.strokeStyle = `hsl(${hue83}deg, 100%, ${brightness83}%)`;
    ctx83.lineWidth = lineWidth83;
    
    for (let j = 0; j < iterations; j++) {
      for (let i = 0; i < square83Array.length; i++) square83Array[i].render();
      
      if (clear83 && loop83) reset83();
    }
    
    currentAngle83Txt.innerHTML = square83Array[0].size === 0 ? 0 : square83Array[0].lastAngle;
    
    if (canvas83Running) setTimeout(() => requestAnimationFrame(frame83), 25);
  }
  reset83();
  
  function reset83() {
    ctx83.fillStyle = "black";
    ctx83.fillRect(-canvas83.width, -canvas83.height, canvas83.width * 2, canvas83.height * 2);
    clear83 = false;
    for (let i = 0; i < square83Array.length; i++) {
      square83Array[i].size = square83Array[i].initialSize;
      square83Array[i].angle = 0;
      square83Array[i].lastSize = square83Array[i].size;
      square83Array[i].lastAngle = square83Array[i].angle;
    }
    if (!canvas83Running) frame83();
  }
  
  function startCanvas83() {
    if (canvas83Running) canvas83Running = false;
    else {
      canvas83Running = true;
      frame83();
    }
  }
  
  function exportCanvas83() {
    canvas83Img.src = canvas83.toDataURL();
  }
  
  let turnSpeed83RangeArray = [0.5, 1, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45];
  turnSpeed83Range.max = turnSpeed83RangeArray.length - 1;
  
  function updateSettings83() {
    gridSize83 = Number(gridSize83Range.value);
    gridSize83Txt.innerHTML = gridSize83Range.value + "x" + gridSize83Range.value;
    tileSize83 = canvas83.width / gridSize83;
    
    turnSpeed83 = turnSpeed83Txt.innerHTML = turnSpeed83RangeArray[Number(turnSpeed83Range.value)];
    
    hue83 = hue83Txt.innerHTML = Number(hue83Range.value);
    
    brightness83 = brightness83Txt.innerHTML = Number(brightness83Range.value);
    
    lineWidth83 = lineWidth83Txt.innerHTML = Number(lineWidth83Range.value) / 100;
    
    alternateDirections83 = alternateDirections83Checkbox.checked;
    
    square83Array = [];
    for (let x = -3; x < gridSize83 + 3; x++) {
      for (let y = -3; y < gridSize83 + 3; y++) {
        let turnSign = ((x + y) % 2 === 0) ? 1 : -1;
        if (!alternateDirections83) turnSign = 1;
        turnSign *= globalSign83;
        square83Array.push(new Square83((x * tileSize83) + (tileSize83 / 2) - (canvas83.width / 2), (y * tileSize83) + (tileSize83 / 2) - (canvas83.height / 2), tileSize83, turnSign));
      }
    }
    
    reset83();
  }
</script>
<canvas id = "canvas82" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "Tree82.draw()">Redraw</button>
<button onclick = "resetSettings82()">Reset Settings</button>
<div style = "font-size: 15px; color: red"><b><i><span id = "errorTxt82"></span></i></b></div>
<div><b><u>Recursion Layers:</u></b> <span id = "tree82MaxLayersTxt">7</span> layers</div>
<input type = "range" min = "1" max = "8" step = "1" value = "7" id = "tree82MaxLayersRange" oninput = "updateSettings82(false)">
<div><b><u>Minimum Splits Per Branch:</u></b> <span id = "tree82MinSplitsTxt">2</span> splits</div>
<input type = "range" min = "0" max = "8" step = "1" value = "2" id = "tree82MinSplitsRange" oninput = "updateSettings82(false)">
<div><b><u>Maximum Splits Per Branch:</u></b> <span id = "tree82MaxSplitsTxt">8</span> splits</div>
<input type = "range" min = "0" max = "12" step = "1" value = "8" id = "tree82MaxSplitsRange" oninput = "updateSettings82(false)">
<div><b><u>Random Length Ratio:</u></b> <span id = "tree82MinRandLengthRatioTxt">50</span>%</div>
<input type = "range" min = "5" max = "85" step = "5" value = "50" id = "tree82MinRandLengthRatioRange" oninput = "updateSettings82(false)">
<div><b><u>Random Angle Offset:</u></b> <span id = "tree82RandOffsetAngleTxt">45</span>&deg;</div>
<input type = "range" min = "0" max = "90" step = "5" value = "45" id = "tree82RandOffsetAngleRange" oninput = "updateSettings82(false)">
<div><b><u>Random Hue Offset:</u></b> <span id = "tree82RandOffsetHueTxt">30</span>&deg;</div>
<input type = "range" min = "0" max = "180" step = "5" value = "30" id = "tree82RandOffsetHueRange" oninput = "updateSettings82(false)">
<div><b><u>Random Branch Bend:</u></b> <span id = "tree82RandBendTxt">50</span>%</div>
<input type = "range" min = "0" max = "100" step = "5" value = "50" id = "tree82RandBendRange" oninput = "updateSettings82(false)">
<div><b><u>Leaf Grow Chance:</u></b> <span id = "tree82LeafChanceTxt">50</span>%</div>
<input type = "range" min = "0" max = "100" step = "5" value = "50" id = "tree82LeafChanceRange" oninput = "updateSettings82(false)">
<div class = "desc"><b><i>(9/25/2021)</i></b> The ultimate random fractal tree generator, each time the branch splits it has a random number of splits, and each new branch has randomize length ratio, width ratio, etc. The branches also bend randomly for more variation.<br><b><i>(9/26/2021)</i></b> Added leaves that draw at the end of each branch, and sliders for different settings.</div>
<hr><hr>
<script>
  const ctx82 = canvas82.getContext("2d");
  canvas82.width = canvas82.height = 1500;
  
  let Tree82 = {
    startX: 0.5,
    startY: 0.9,
    startLength: 250,
    startAngle: 270,
    startWidth: 15,
    minWidth: 0.5,
    maxSplits: 8,
    minSplits: 2,
    maxLayers: 7,
    startHue: 0,
    startBend: 0.5,
    startLerp: 0.5,
    currentTotalBranches: 0,
    stopped: false,
    leafChance: 0.5,
    minRandLengthRatio: 0.5,
    minRandWidthRatio: 0.5,
    randOffsetAngle: 45,
    randOffsetHue: 30,
    randBend: 0.5
  };
  Tree82.draw = function() {
    ctx82.clearRect(0, 0, canvas82.width, canvas82.height);
    ctx82.lineCap = ctx82.lineJoin = "round";
    ctx82.globalAlpha = 0.5;
    this.startHue = Math.random() * 360;
    this.startBend = randBetween(-this.randBend / 2, this.randBend / 2);
    this.startLerp = Math.random();
    this.currentTotalBranches = 0;
    this.stopped = false;
    errorTxt82.innerHTML = "";
    this.drawBranch(this.startX * canvas82.width, this.startY * canvas82.height, this.startLength, this.startBend, this.startLerp, this.startWidth, this.startAngle, this.startHue, 1);
  };
  Tree82.drawBranch = function(x, y, length, bend, lerp, width, angle, hue, currLayer) {
    if (currLayer > this.maxLayers || this.stopped) return;
    this.currentTotalBranches++;
    if (this.currentTotalBranches >= 100000) {
      this.stopped = true;
      errorTxt82.innerHTML = "Tree drawing was stopped before finishing because the total number of branches and leaves exceeded 1 million. For better results, try reducing the number of recursion layers, reducing the number of minimum/maximum branch splits, or reducing the leaf grow chance.";
      return;
    }
    let endX = x + (length * Math.cos(toRad(angle)));
    let endY = y + (length * Math.sin(toRad(angle)));
    let dx = endX - x;
    let dy = endY - y;
    let midpointX = ((1 - lerp) * x) + (lerp * endX);
    let midpointY = ((1 - lerp) * y) + (lerp * endY);
    let normal = toRad(angle + 90);
    let controlX = midpointX + (length * bend * Math.cos(normal));
    let controlY = midpointY + (length * bend * Math.sin(normal));
    ctx82.lineWidth = Math.max(width, this.minWidth);
    ctx82.strokeStyle = `hsl(${hue}deg, 100%, 30%)`;
    ctx82.beginPath();
    ctx82.moveTo(x, y);
    ctx82.quadraticCurveTo(controlX, controlY, endX, endY);
    ctx82.stroke();
    let splits = Math.round(randBetween(this.minSplits, this.maxSplits));
    if (currLayer === this.maxLayers || splits === 0) {
      if (Math.random() > this.leafChance) return;
      let lengthRatio = randBetween(this.minRandLengthRatio, 0.9);
      let offsetAngle = randBetween(-this.randOffsetAngle, this.randOffsetAngle);
      let offsetHue = randBetween(-this.randOffsetHue, this.randOffsetHue);
      let bend = randBetween(0.25, 0.5);
      let lerp = Math.random();
      this.drawLeaf(endX, endY, length * lengthRatio, bend, lerp, angle + offsetAngle, hue + offsetHue);
      return;
    }
    for (let i = 0; i < splits; i++) {
      let lengthRatio = randBetween(this.minRandLengthRatio, 0.9);
      let widthRatio = randBetween(this.minRandWidthRatio, 0.9);
      let offsetAngle = randBetween(-this.randOffsetAngle, this.randOffsetAngle);
      let offsetHue = randBetween(-this.randOffsetHue, this.randOffsetHue);
      let bend = randBetween(-this.randBend, this.randBend);
      let lerp = Math.random();
      this.drawBranch(endX, endY, length * lengthRatio, bend, lerp, width * widthRatio, angle + offsetAngle, hue + offsetHue, currLayer + 1);
    }
  };
  Tree82.drawLeaf = function(x, y, length, bend, lerp, angle, hue) {
    this.currentTotalBranches++;
    ctx82.fillStyle = `hsl(${hue}deg, 100%, 70%)`;
    let endX = x + (length * Math.cos(toRad(angle)));
    let endY = y + (length * Math.sin(toRad(angle)));
    let dx = endX - x;
    let dy = endY - y;
    let normal = toRad(angle + 90);
    let midpointX1 = ((1 - lerp) * x) + (lerp * endX);
    let midpointY1 = ((1 - lerp) * y) + (lerp * endY);
    let controlX1 = midpointX1 + (length * -bend * Math.cos(normal));
    let controlY1 = midpointY1 + (length * -bend * Math.sin(normal));
    let midpointX2 = ((1 - lerp) * x) + (lerp * endX);
    let midpointY2 = ((1 - lerp) * y) + (lerp * endY);
    let controlX2 = midpointX2 + (length * bend * Math.cos(normal));
    let controlY2 = midpointY2 + (length * bend * Math.sin(normal));
    ctx82.beginPath();
    ctx82.moveTo(x, y);
    ctx82.quadraticCurveTo(controlX1, controlY1, endX, endY);
    ctx82.quadraticCurveTo(controlX2, controlY2, x, y);
    ctx82.fill();
  };
  Tree82.draw();
  
  function updateSettings82(redraw) {
    Tree82.maxLayers = tree82MaxLayersTxt.innerHTML = Number(tree82MaxLayersRange.value);
    Tree82.maxSplits = tree82MaxSplitsTxt.innerHTML = tree82MinSplitsRange.max = Number(tree82MaxSplitsRange.value);
    Tree82.minSplits = tree82MinSplitsTxt.innerHTML = Number(tree82MinSplitsRange.value);
    Tree82.minRandLengthRatio = Number(tree82MinRandLengthRatioRange.value) / 100;
    tree82MinRandLengthRatioTxt.innerHTML = Number(tree82MinRandLengthRatioRange.value);
    Tree82.randOffsetAngle = tree82RandOffsetAngleTxt.innerHTML = Number(tree82RandOffsetAngleRange.value);
    Tree82.randOffsetHue = tree82RandOffsetHueTxt.innerHTML = Number(tree82RandOffsetHueRange.value);
    Tree82.randBend = Number(tree82RandBendRange.value) / 100;
    tree82RandBendTxt.innerHTML = Number(tree82RandBendRange.value);
    Tree82.leafChance = Number(tree82LeafChanceRange.value) / 100;
    tree82LeafChanceTxt.innerHTML = Number(tree82LeafChanceRange.value);
    if (redraw) Tree82.draw();
  }
  
  function resetSettings82() {
    tree82MaxLayersRange.value = tree82MaxLayersRange.defaultValue;
    tree82MaxSplitsRange.value = tree82MinSplitsRange.max = tree82MaxSplitsRange.defaultValue;
    tree82MinSplitsRange.value = tree82MinSplitsRange.defaultValue;
    tree82MinRandLengthRatioRange.value = tree82MinRandLengthRatioRange.defaultValue;
    tree82RandOffsetAngleRange.value = tree82RandOffsetAngleRange.defaultValue;
    tree82RandOffsetHueRange.value = tree82RandOffsetHueRange.defaultValue;
    tree82RandBendRange.value = tree82RandBendRange.defaultValue;
    tree82LeafChanceRange.value = tree82LeafChanceRange.defaultValue;
    
    updateSettings82(true);
  }
</script>
<canvas id = "canvas81" style = "background-color: black; width: 400px; height: 400px"></canvas>
<button onclick = "Tree81.resetSettings()">Reset</button>
<div><b><u>Total Branches:</u></b> <span id = "tree81TotalBranchesTxt"></span></div>
<div style = "font-size: 15px; color: red"><b><i><span id = "errorTxt81"></span></i></b></div>
<div><b><u>Number of Branches Per Split:</u></b> <span id = "tree81BranchesTxt">7</span></div>
<input type = "range" min = "2" max = "8" step = "1" value = "7" id = "tree81BranchesRange" oninput = "updateSettings81()">
<div><b><u>Recursion Layers:</u></b> <span id = "tree81MaxLayersTxt">6</span></div>
<input type = "range" min = "2" max = "10" step = "1" value = "6" id = "tree81MaxLayersRange" oninput = "updateSettings81()">
<div class = "desc"><b><i>(9/25/2021)</i></b> Fractal Tree generator with a changeable number of splitting branches. It works fine and I'm happy with it, but I want to eventually improve it to have more interesting results. Right now the main problem I ran into was generating interesting trees from random rules, as most of them just made boring trees. Right now the way it works is each branch is offset from the previous one by some angle, and then the other branch settings are randomized normally.</div>
<hr><hr>
<script>
  const ctx81 = canvas81.getContext("2d");
  canvas81.width = canvas81.height = 1000;
  
  let Tree81 = {
    startX: 0.5,
    startY: 0.9,
    branches: 7,
    startLength: 150,
    startAngle: 270,
    startWidth: 4,
    settings: [],
    maxLayers: 6,
    minWidth: 0.5,
    startHue: 0,
    totalBranches: 0
  };
  Tree81.resetSettings = function() {
    this.startHue = Math.random() * 360;
    this.settings = [];
    let totalAngle = 0;
    for (let i = 0; i < this.branches; i++) {
      this.settings.push({
        lengthRatio: randBetween(0.3, 0.9),
        widthRatio: randBetween(0.5, 0.9),
        offsetAngle: randBetween(5, 180 / this.branches),
        offsetHue: randBetween(-60, 60)
      });
      if (i !== 0) totalAngle += this.settings[i].offsetAngle;
    }
    this.startNewBranchAngle = totalAngle / 2;
    this.draw();
  };
  Tree81.draw = function() {
    ctx81.clearRect(0, 0, canvas81.width, canvas81.height);
    this.totalBranches = Math.pow(this.branches, this.maxLayers) - 1;
    tree81TotalBranchesTxt.innerHTML = this.totalBranches.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    if (this.totalBranches >= 1000000) {
      errorTxt81.innerHTML = `Current total branch count of ${this.totalBranches.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")} exceeds the maximum allowed amount of 1 million. Please choose fewer recursion layers or branches per split to render the tree.`;
      return;
    }
    else errorTxt81.innerHTML = "";
    ctx81.lineCap = ctx81.lineJoin = "round";
    ctx81.globalAlpha = 0.5;
    this.drawBranch(this.startX * canvas81.width, this.startY * canvas81.height, this.startLength, this.startWidth, this.startAngle, this.startHue, 1);
  };
  Tree81.drawBranch = function(x, y, length, width, angle, hue, currLayer) {
    if (currLayer > this.maxLayers) return;
    ctx81.lineWidth = Math.max(width, this.minWidth);
    ctx81.strokeStyle = `hsl(${hue}deg, 100%, 50%)`;
    let endX = x + (length * Math.cos(toRad(angle)));
    let endY = y + (length * Math.sin(toRad(angle)));
    ctx81.beginPath();
    ctx81.moveTo(x, y);
    ctx81.lineTo(endX, endY);
    ctx81.stroke();
    let currAngle = angle - this.startNewBranchAngle;
    for (let i = 0; i < this.branches; i++) {
      if (i !== 0) currAngle += this.settings[i].offsetAngle;
      //currAngle = angle + this.settings[i].offsetAngle;
      this.drawBranch(endX, endY, length * this.settings[i].lengthRatio, width * this.settings[i].widthRatio, currAngle, hue + this.settings[i].offsetHue, currLayer + 1);
    }
  };
  Tree81.resetSettings();
  
  function updateSettings81() {
    Tree81.branches = tree81BranchesTxt.innerHTML = Number(tree81BranchesRange.value);
    Tree81.maxLayers = tree81MaxLayersTxt.innerHTML = Number(tree81MaxLayersRange.value);
  }
</script>
<canvas id = "canvas80"></canvas>
<button onclick = "smoothGrid80(resetSmoothingIterations80, true)">Smooth</button>
<button onclick = "reset80(false)">Reset (No smoothing)</button>
<button onclick = "reset80(true)">Reset (With smoothing iterations)</button>
<div><i><b>Current Smoothing Iterations:</b> <span id = "smoothingIterations80Txt">0</span></i></div>
<div><b><u>Smoothing Iterations Per Step:</u></b> <span id = "resetSmoothingIterations80Txt">25</span></div>
<input type = "range" min = "1" max = "50" step = "1" value = "25" id = "resetSmoothingIterations80Range" oninput = "updateSettings80(false)">
<div><b><u>Color Mode:</u></b></div>
<input type = "radio" name = "colorMode80Radio" id = "colorMode801Radio" oninput = "updateSettings80(false)" CHECKED>
<label for = "colorMode801Radio">Black and white</label>
<br>
<input type = "radio" name = "colorMode80Radio" id = "colorMode802Radio" oninput = "updateSettings80(false)">
<label for = "colorMode802Radio">Single color</label>
<br>
<input type = "radio" name = "colorMode80Radio" id = "colorMode803Radio" oninput = "updateSettings80(false)">
<label for = "colorMode803Radio">Rainbow</label>
<div><b><u>Color Hue:</u></b> <span id = "hue80Txt">0</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "15" value = "0" id = "hue80Range" oninput = "updateSettings80(false)">
<div class = "desc"><b><i>(9/24/2021)</i></b> Something that I think might be random noise, I have an array of random values from 0 to 1 and then each step they're averaged together by a set weighted average.<br><b><i>(9/25/2021)</i></b> Added different color modes.</div>
<hr><hr>
<script>
  const ctx80 = canvas80.getContext("2d");
  canvas80.width = canvas80.height = 100;
  
  let smoothness80 = 0.4;
  let smoothingIterations80 = 0;
  let resetSmoothingIterations80 = 25;
  let colorMode80 = 1; // 1: Black and white | 2: Single color | 3: Rainbow
  let hue80 = 0;
  
  let gridSize80 = 100;
  let tileSize80 = canvas80.width / gridSize80;
  let grid80 = [];
  
  function smoothGrid80(steps, drawGrid) {
    for (let j = 0; j < steps; j++) {
      smoothingIterations80++;
      let copy = [];
      for (let i = 0; i < gridSize80; i++) copy[i] = [];
      for (let x = 0; x < gridSize80; x++) {
        for (let y = 0; y < gridSize80; y++) {
          let top = (y - 1 + gridSize80) % gridSize80;
          let right = (x + 1) % gridSize80;
          let bottom = (y + 1) % gridSize80;
          let left = (x - 1 + gridSize80) % gridSize80;
          
          let mult = smoothness80 / 8;
          
          let t = grid80[x][top] * mult;
          let tr = grid80[right][top] * mult;
          let r = grid80[right][y] * mult;
          let br = grid80[right][bottom] * mult;
          let b = grid80[x][bottom] * mult;
          let bl = grid80[left][bottom] * mult;
          let l = grid80[left][y] * mult;
          let tl = grid80[left][top] * mult;
          let m = grid80[x][y] * (1 - smoothness80);
          
          copy[x][y] = t + tr + r + br + b + bl + l + tl + m;
        }
      }
      grid80 = copy;
    }
    if (drawGrid) drawGrid80();
  }
  
  function drawGrid80() {
    let min = Infinity;
    let max = 0;
    for (let x = 0; x < gridSize80; x++) {
      for (let y = 0; y < gridSize80; y++) {
        min = Math.min(min, grid80[x][y]);
        max = Math.max(max, grid80[x][y]);
      }
    }
    let diff = max - min;
    for (let x = 0; x < gridSize80; x++) {
      for (let y = 0; y < gridSize80; y++) {
        grid80[x][y] = (grid80[x][y] - min) / diff;
        if (colorMode80 === 1) ctx80.fillStyle = `hsl(0deg, 0%, ${grid80[x][y] * 100}%)`; // Black and white
        else if (colorMode80 === 2) ctx80.fillStyle = `hsl(${hue80}deg, 100%, ${grid80[x][y] * 100}%)`; // Single color
        else if (colorMode80 === 3) ctx80.fillStyle = `hsl(${(grid80[x][y] * 360) + hue80}deg, 100%, 50%)`; // Rainbow
        ctx80.fillRect(x * tileSize80, y * tileSize80, tileSize80, tileSize80);
      }
    }
    smoothingIterations80Txt.innerHTML = smoothingIterations80.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  
  function reset80(smooth) {
    smoothingIterations80 = 0;
    tileSize80 = canvas80.width / gridSize80;
    grid80 = [];
    for (let x = 0; x < gridSize80; x++) {
      let col = [];
      for (let y = 0; y < gridSize80; y++) {
        col.push(Math.random());
      }
      grid80.push(col);
    }
    if (smooth) smoothGrid80(resetSmoothingIterations80, true);
    else drawGrid80();
  }
  reset80(true);
  
  function updateSettings80(reset) {
    resetSmoothingIterations80 = resetSmoothingIterations80Txt.innerHTML = Number(resetSmoothingIterations80Range.value);
    if (colorMode801Radio.checked) colorMode80 = 1;
    else if (colorMode802Radio.checked) colorMode80 = 2;
    else if (colorMode803Radio.checked) colorMode80 = 3;
    hue80 = hue80Txt.innerHTML = Number(hue80Range.value);
    if (reset) reset80(true);
    else drawGrid80();
  }
</script>
<canvas id = "canvas79"></canvas>
<button onclick = "reset79()">Reset</button>
<button onclick = "smoothRows79()">Smooth out</button>
<div class = "desc"><b><i>(9/24/2021)</i></b> Pixel landscape generator, using a similar method to the snowfall generator by averaging rows to smooth the terrain.</div>
<hr><hr>
<script>
  const ctx79 = canvas79.getContext("2d");
  canvas79.width = canvas79.height = 1000;
  
  let gridSize79 = 100;
  let tileSize79 = canvas79.width / gridSize79;
  let smoothness79 = 0.2;
  let steepness79 = 50;
  let minHeight79 = 10;
  
  let rows79 = [];
  
  function smoothRows79() {
    let copy = [];
    for (let i = 0; i < rows79.length; i++) {
      let left = (rows79[(i - 1 + gridSize79) % gridSize79]) * (smoothness79 / 2);
      let middle = rows79[i] * (1 - smoothness79);
      let right = (rows79[(i + 1) % gridSize79]) * (smoothness79 / 2);
      copy[i] = Math.round(left + middle + right);
    }
    rows79 = copy;
    drawRows79();
  }
  
  function drawRows79() {
    ctx79.clearRect(0, 0, canvas79.width, canvas79.height);
    for (let i = 0; i < rows79.length; i++) {
      let height = gridSize79 - rows79[i];
      ctx79.fillRect(i * tileSize79, height * tileSize79, tileSize79, rows79[i] * tileSize79);
    }
  }
  
  function reset79() {
    tileSize79 = canvas79.width / gridSize79;
    rows79 = [];
    for (let i = 0; i < gridSize79; i++) rows79.push(Math.round((Math.random() * steepness79) + minHeight79));
    drawRows79();
  }
  reset79();
</script>
<canvas id = "canvas78" style = "background-color: black"></canvas>
<button onclick = "startCanvas78()">Start/Stop</button>
<button onclick = "reset78()">Reset</button>
<div class = "desc"><b><i>(9/23/2021) (and 9/24/2021, a few minutes past 12am)</i></b> Pixel art nightime snowfall art. Each snowflake falls at a set gravity, with lower gravity snowflakes being drawn darker to make them appear further back, and if the current y-position of a snowflake is more than the snowpile below it, that snowpile is incremented and the snowflake destroyed. Snowpiles grow lighter as they grow taller, to give the appearance of layers of snow with shading. The snowpiles interact like Tetris blocks, so that if there is 10 complete rows at the bottom, they all decrement. Each snowpile also averages each frame with its neighbors by a 15% / 70% / 15% averaging method.</div>
<hr><hr>
<script>
  const ctx78 = canvas78.getContext("2d");
  canvas78.width = canvas78.height = 1000;
  let canvas78Running = false;
  
  let gridSize78 = 100;
  let tileSize78 = canvas78.width / gridSize78;
  let snowfall78 = 1;
  let minBuildup78 = 10;
  let smoothness78 = 0.3;
  
  function Snowflake78() {
    this.x = Math.floor(Math.random() * gridSize78);
    this.y = -1;
    this.stuck = false;
    this.gravity = (Math.random() * 0.5) + 0.5;
    this.color = `hsl(0deg, 0%, ${((this.gravity - 0.5) / 0.5) * 100}%)`;
  }
  Snowflake78.prototype.render = function() {
    this.y += this.gravity;
    if (Math.floor(this.y) >= gridSize78 - rows78[this.x]) {
      rows78[this.x]++;
      this.stuck = true;
      return;
    }
    ctx78.fillStyle = this.color;
    ctx78.fillRect(this.x * tileSize78, Math.floor(this.y) * tileSize78, tileSize78, tileSize78);
  };
  let snowflake78Array = [];
  
  let rows78 = [];
  //for (let i = 0; i < gridSize78; i++) rows78.push(Math.round(randBetween(-100, 100)));
  for (let i = 0; i < gridSize78; i++) rows78.push(0);
  
  function frame78() {
    ctx78.clearRect(0, 0, canvas78.width, canvas78.height);
    
    if (snowfall78 >= 1) {
      for (let i = 0; i < snowfall78; i++) snowflake78Array.push(new Snowflake78());
    }
    else if (Math.random() < snowfall78) snowflake78Array.push(new Snowflake78());
    
    for (let i = 0; i < snowflake78Array.length; i++) {
      snowflake78Array[i].render();
      if (snowflake78Array[i].stuck) {
        snowflake78Array.splice(i, 1);
        i--;
      }
    }
    
    let minHeight = Infinity;
    for (let i = 0; i < rows78.length; i++) {
      for (let j = 0; j < rows78[i]; j++) {
        ctx78.fillStyle = `hsl(0deg, 0%, ${(((j + 1) / rows78[i]) * 65) + 35}%)`;
        ctx78.fillRect(i * tileSize78, canvas78.height - ((j + 1) * tileSize78), tileSize78, tileSize78);
      }
      
      if (rows78[i] <= minHeight) minHeight = rows78[i];
    }
    if (minHeight > minBuildup78) {
      for (let i = 0; i < rows78.length; i++) rows78[i]--;
    }
    
    let copy = [];
    for (let i = 0; i < rows78.length; i++) {
      let left = (rows78[(i - 1 + gridSize78) % gridSize78]) * (smoothness78 / 2);
      let middle = rows78[i] * (1 - smoothness78);
      let right = (rows78[(i + 1) % gridSize78]) * (smoothness78 / 2);
      copy[i] = Math.round(left + middle + right);
    }
    rows78 = copy;
    
    if (canvas78Running) requestAnimationFrame(frame78);
  }
  frame78();
  
  function startCanvas78() {
    if (canvas78Running) canvas78Running = false;
    else {
      canvas78Running = true;
      frame78();
    }
  }
  
  function reset78() {
    snowflake78Array = [];
    rows78 = [];
    for (let i = 0; i < gridSize78; i++) rows78.push(0);
    tileSize78 = canvas78.width / gridSize78;
    if (!canvas78Running) frame78();
  }
</script>
<canvas id = "canvas77" style = "background-color: black; width: 400px; height: 400px"></canvas>
<button onclick = "PythagorasTree.draw()">Go</button>
<div><b><u>Rainbow Branches:</u></b></div>
<input type = "checkbox" id = "pythagorasTreeRainbowBranchesCheckbox" oninput = "updateSettings77()" CHECKED>
<div><b><u>Initial Hue:</u></b> <span id = "pythagorasTreeStartHueTxt">0</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "15" value = "0" id = "pythagorasTreeStartHueRange" oninput = "updateSettings77()">
<div><b><u>Left Branch Hue Offset:</u></b> <span id = "pythagorasTreeHueOffsetLeftTxt">15</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "5" value = "15" id = "pythagorasTreeHueOffsetLeftRange" oninput = "updateSettings77()">
<div><b><u>Right Branch Hue Offset:</u></b> <span id = "pythagorasTreeHueOffsetRightTxt">15</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "5" value = "15" id = "pythagorasTreeHueOffsetRightRange" oninput = "updateSettings77()">
<div><b><u>Layers:</u></b> <span id = "pythagorasTreeMaxLayersTxt">10</span></div>
<input type = "range" min = "1" max = "14" step = "1" value = "10" id = "pythagorasTreeMaxLayersRange" oninput = "updateSettings77()">
<div><b><u>Initial Size:</u></b> <span id = "pythagorasStartSizeTxt">100</span>px</div>
<input type = "range" min = "50" max = "200" step = "25" value = "100" id = "pythagorasStartSizeRange" oninput = "updateSettings77()">
<div><b><u>Side Branch Angle:</u></b> <span id = "pythagorasLeftTreeBranchAngleTxt">45</span>&deg;</div>
<input type = "range" min = "5" max = "85" step = "1" value = "45" id = "pythagorasLeftTreeBranchAngleRange" oninput = "updateSettings77()">
<div><b><u>Top Branch Angle:</u></b> <span id = "pythagorasTopTreeBranchAngleTxt">90</span>&deg;</div>
<input type = "range" min = "60" max = "120" step = "1" value = "90" id = "pythagorasTopTreeBranchAngleRange" oninput = "updateSettings77()">
<div><b><u>Randomize Side Branch Angle:</u></b></div>
<input type = "checkbox" id = "pythagorasTreeRandomSideBranchAnglesCheckbox" oninput = "updateSettings77()" CHECKED>
<div><b><u>Randomize Top Branch Angle:</u></b></div>
<input type = "checkbox" id = "pythagorasTreeRandomTopBranchAnglesCheckbox" oninput = "updateSettings77()">
<div class = "desc"><b><i>(9/21/2021)</i></b> Pythagoras Fractal Tree generator, currently not working.<br><b><i>Update: (later that night)</i></b> I finally got it working properly and you can change the branch angle as well. You can also make it randomize the branch angle each new branch.<br><b><i>(9/22/2021)</i></b> Added the ability to change the entire shape of the triangle by changing the top angle. At some point I might want to add the ability to have each new branch be a rectangle instead of a square. Also added colors.<br><b><i><mark>Actually finished! (5/20/2022)</mark> Added to <a href = "generative-art-gallery.html" target = "_blank">generative-art-gallery.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx77 = canvas77.getContext("2d");
  canvas77.width = canvas77.height = 1000;
  
  let PythagorasTree = {
    startX: 500,
    startY: 800,
    startSize: 100,
    startAngle: 0,
    maxLayers: 10,
    startLeftBranchAngle: 45,
    startTopBranchAngle: 90,
    randomSideBranchAngles: true,
    randomTopBranchAngles: false,
    startHue: 0,
    hueOffsetLeft: 15,
    hueOffsetRight: 15,
    rainbowBranches: true
  };
  PythagorasTree.draw = function() {
    ctx77.clearRect(0, 0, canvas77.width, canvas77.height);
    ctx77.globalCompositeOperation = "lighter";
    
    let nextTopBranchAngle = this.startTopBranchAngle;
    let nextLeftBranchAngle = this.startLeftBranchAngle;
    if (this.randomTopBranchAngles) {
      nextLeftBranchAngle = this.randomSideBranchAngles ? randBetween(30, 60) : this.startLeftBranchAngle;
      nextTopBranchAngle = randBetween(60, 175 - nextLeftBranchAngle);
    }
    if (this.randomSideBranchAngles) {
      nextTopBranchAngle = this.randomTopBranchAngles ? randBetween(60, 120) : this.startTopBranchAngle;
      nextLeftBranchAngle = randBetween(30, 150 - nextTopBranchAngle);
    }
    
    this.drawSquare(this.startX - (this.startSize / 2), this.startY + (this.startSize / 2), this.startSize, this.startAngle, 1, true, nextLeftBranchAngle, nextTopBranchAngle, this.startHue);
  };
  PythagorasTree.drawSquare = function(x, y, size, angle, currLayer, isLeft, leftBranchAngle, topBranchAngle, hue) {
    if (currLayer > this.maxLayers) return;
    let cx = x;
    let cy = y;
    let corners = [];
    let sign = isLeft ? 1 : -1;
    ctx77.fillStyle = this.rainbowBranches ? `hsl(${hue}deg, 100%, 60%)` : "white";
    ctx77.beginPath();
    ctx77.moveTo(cx, cy);
    for (let i = 0; i < 4; i++) {
      corners.push({x: cx, y: cy});
      cx += size * Math.cos(toRad(angle + (i * sign * 90)));
      cy -= size * Math.sin(toRad(angle + (i * sign * 90)));
      ctx77.lineTo(cx, cy);
    }
    ctx77.fill();
    
    let nextTopBranchAngle = this.startTopBranchAngle;
    let nextLeftBranchAngle = this.startLeftBranchAngle;
    if (this.randomTopBranchAngles) {
      nextLeftBranchAngle = this.randomSideBranchAngles ? randBetween(30, 60) : this.startLeftBranchAngle;
      nextTopBranchAngle = randBetween(60, 175 - nextLeftBranchAngle);
    }
    if (this.randomSideBranchAngles) {
      nextTopBranchAngle = this.randomTopBranchAngles ? randBetween(60, 120) : this.startTopBranchAngle;
      nextLeftBranchAngle = randBetween(30, 150 - nextTopBranchAngle);
    }
    
    let sinTop = 1 / Math.sin(toRad(topBranchAngle));
    let scaleLeft = sinTop * Math.sin(toRad(leftBranchAngle));
    let scaleRight = sinTop * Math.sin(toRad(180 - (topBranchAngle + leftBranchAngle)));
    if (isLeft) {
      this.drawSquare(corners[3].x, corners[3].y, size * scaleLeft, angle + (180 - (topBranchAngle + leftBranchAngle)), currLayer + 1, true, nextLeftBranchAngle, nextTopBranchAngle, hue - this.hueOffsetLeft);
      this.drawSquare(corners[2].x, corners[2].y, size * scaleRight, angle - leftBranchAngle + 180, currLayer + 1, false, nextLeftBranchAngle, nextTopBranchAngle, hue + this.hueOffsetRight);
    }
    else {
      this.drawSquare(corners[2].x, corners[2].y, size * scaleLeft, angle + (180 - (topBranchAngle + leftBranchAngle)) + 180, currLayer + 1, true, nextLeftBranchAngle, nextTopBranchAngle, hue - this.hueOffsetLeft);
      this.drawSquare(corners[3].x, corners[3].y, size * scaleRight, angle - leftBranchAngle, currLayer + 1, false, nextLeftBranchAngle, nextTopBranchAngle, hue + this.hueOffsetRight);
    }
  };
  PythagorasTree.draw();
  
  function updateSettings77() {
    PythagorasTree.randomSideBranchAngles = pythagorasTreeRandomSideBranchAnglesCheckbox.checked;
    PythagorasTree.randomTopBranchAngles = pythagorasTreeRandomTopBranchAnglesCheckbox.checked;
    PythagorasTree.startTopBranchAngle = pythagorasTopTreeBranchAngleTxt.innerHTML = Number(pythagorasTopTreeBranchAngleRange.value);
    pythagorasLeftTreeBranchAngleRange.max = 175 - PythagorasTree.startTopBranchAngle;
    PythagorasTree.startLeftBranchAngle = pythagorasLeftTreeBranchAngleTxt.innerHTML = Number(pythagorasLeftTreeBranchAngleRange.value);
    PythagorasTree.maxLayers = pythagorasTreeMaxLayersTxt.innerHTML = Number(pythagorasTreeMaxLayersRange.value);
    PythagorasTree.rainbowBranches = pythagorasTreeRainbowBranchesCheckbox.checked;
    PythagorasTree.startSize = pythagorasStartSizeTxt.innerHTML = Number(pythagorasStartSizeRange.value);
    PythagorasTree.startHue = pythagorasTreeStartHueTxt.innerHTML = Number(pythagorasTreeStartHueRange.value);
    PythagorasTree.hueOffsetLeft = pythagorasTreeHueOffsetLeftTxt.innerHTML = Number(pythagorasTreeHueOffsetLeftRange.value);
    PythagorasTree.hueOffsetRight = pythagorasTreeHueOffsetRightTxt.innerHTML = Number(pythagorasTreeHueOffsetRightRange.value);
    PythagorasTree.draw();
  }
</script>
<canvas id = "canvas76"></canvas>
<button onclick = "startCanvas76()">Start/Stop</button>
<button onclick = "circle76Array = []">Destroy Circles</button>
<div class = "desc"><b><i>(9/21/2021)</i></b> An attempt to make a physics simulation with colliding balls, which works somewhat fine, except that when two spheres collide, they bounce off without taking their current velocity or mass into account, and I can't figure out how to fix that, which I want to do at some point. This means when you drag to add circles they all get bunched up for a second before actually falling. They also get caught up on the ceiling and sides a lot for some reason that I can't figure out.<br><b><i>(9/22/2021)</i></b> Changed the collision code using <a href = "https://spicyyoghurt.com/tutorials/html5-javascript-game-development/collision-detection-physics" target = "_blank">this</a> page as a reference, and now the collisions work properly.</div>
<hr><hr>
<script>
  const ctx76 = canvas76.getContext("2d");
  canvas76.width = canvas76.height = 1000;
  let canvas76Ratio = canvas76.width / 300;
  let canvas76Rect = canvas76.getBoundingClientRect();
  let canvas76Running = false;
  
  let gravity76 = 0.25;
  let maxCircles76 = 200;
  
  let Mouse76 = {
    down: false
  };
  
  function Circle76(x, y) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.mass = randBetween(10, 30);
    this.radius = this.mass;
    this.bounciness = 1;
    this.wallBounciness = 0.6;
  }
  Circle76.prototype.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += gravity76;
    
    let collided = false;
    
    for (let i = 0; i < circle76Array.length; i++) {
      if (i !== circle76Array.indexOf(this)) {
        let dx = this.x - circle76Array[i].x;
        let dy = this.y - circle76Array[i].y;
        if ((dx * dx) + (dy * dy) <= (this.radius + circle76Array[i].radius) * (this.radius + circle76Array[i].radius)) {
          collided = true;
          let angle = Math.atan2(dy, dx);
          let collisionX = Math.cos(angle);
          let collisionY = Math.sin(angle);
          let relativeVx = this.vx - circle76Array[i].vx;
          let relativeVy = this.vy - circle76Array[i].vy;
          let speed = (relativeVx * collisionX) + (relativeVy * collisionY);
          let impulse = (speed * 2) / (this.mass + circle76Array[i].mass);
          this.vx -= this.bounciness * impulse * circle76Array[i].mass * collisionX;
          this.vy -= this.bounciness * impulse * circle76Array[i].mass * collisionY;
          circle76Array[i].vx += circle76Array[i].bounciness * impulse * this.mass * collisionX;
          circle76Array[i].vy += circle76Array[i].bounciness * impulse * this.mass * collisionY;
          this.x = circle76Array[i].x + ((this.radius + circle76Array[i].radius) * collisionX);
          this.y = circle76Array[i].y + ((this.radius + circle76Array[i].radius) * collisionY);
        }
      }
    }
    
    if (this.x + this.radius > canvas76.width) {
      this.x = canvas76.width - this.radius;
      this.vx *= -this.wallBounciness;
      collided = true;
    }
    if (this.x < this.radius) {
      this.x = this.radius;
      this.vx *= -this.wallBounciness;
      collided = true;
    }
    if (this.y + this.radius > canvas76.height) {
      this.y = canvas76.height - this.radius;
      this.vy *= -this.wallBounciness;
      collided = true;
    }
    if (this.y < this.radius) {
      this.y = this.radius;
      this.vy *= -this.wallBounciness;
      collided = true;
    }
    
    if (collided) {
      //this.vx *= 0.5;
      //this.vy *= 0.5;
    }
    
    ctx76.fillCircle(this.x, this.y, this.radius);
  }
  let circle76Array = [];
  //for (let i = 0; i < 200; i++) circle76Array.push(new Circle76(randBetween(30, canvas76.width - 30), randBetween(30, canvas76.height - 30)));
  
  function frame76() {
    ctx76.clearRect(0, 0, canvas76.width, canvas76.height);
    
    for (let i = 0; i < circle76Array.length; i++) circle76Array[i].render();
    
    if (canvas76Running) requestAnimationFrame(frame76);
  }
  frame76();
  
  function startCanvas76() {
    if (canvas76Running) canvas76Running = false;
    else {
      canvas76Running = true;
      frame76();
    }
  }
  
  canvas76.addEventListener("mousedown", e => {
    if (!canvas76Running) return;
    e.preventDefault();
    Mouse76.down = true;
    canvas76Rect = canvas76.getBoundingClientRect();
    let eX = (e.clientX - canvas76Rect.left) * canvas76Ratio;
    let eY = (e.clientY - canvas76Rect.top) * canvas76Ratio;
    circle76Array.push(new Circle76(eX + randBetween(-2, 2), eY + (randBetween(-2, 2))));
    while (circle76Array.length > maxCircles76) circle76Array.shift();
  });
  window.addEventListener("mouseup", e => {
    if (!canvas76Running) return;
    Mouse76.down = false;
  });
  canvas76.addEventListener("mousemove", e => {
    if (!canvas76Running || !Mouse76.down) return;
    e.preventDefault();
    canvas76Rect = canvas76.getBoundingClientRect();
    let eX = (e.clientX - canvas76Rect.left) * canvas76Ratio;
    let eY = (e.clientY - canvas76Rect.top) * canvas76Ratio;
    circle76Array.push(new Circle76(eX + randBetween(-2, 2), eY + (randBetween(-2, 2))));
    while (circle76Array.length > maxCircles76) circle76Array.shift();
  });
</script>
<canvas id = "canvas75" style = "background-color: black; width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas75()">Start/Stop</button>
<div class = "desc"><b><i>(9/20/2021)</i></b> Electromagnetic force simulation, with various charged particles attracting and repelling each other. It works fine, but it's kinda boring and I don't know what to do with it. Click and drag to add particles.</div>
<hr><hr>
<script>
  const ctx75 = canvas75.getContext("2d");
  canvas75.width = canvas75.height = 1000;
  let canvas75Ratio = canvas75.width / 400;
  let canvas75Rect = canvas75.getBoundingClientRect();
  let canvas75Running = false;
  
  let attractionConstant = 50;
  let friction75 = 0.05;
  let chargeMode = 1;
  
  let Mouse75 = {
    down: false
  };
  
  function ChargedParticle(x, y, charge) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
    this.charge = charge;
    this.radius = 10;
  }
  ChargedParticle.prototype.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    
    for (let i = 0; i < chargedParticleArray.length; i++) {
      if (i !== chargedParticleArray.indexOf(this)) {
        let dx = this.x - chargedParticleArray[i].x;
        let dy = this.y - chargedParticleArray[i].y;
        if (Math.abs(dx) < 15) dx = 15 * Math.sign(dx);
        if (Math.abs(dy) < 15) dy = 15 * Math.sign(dy);
        let distSq = (dx * dx) + (dy * dy);
        let angle = Math.atan2(dy, dx);
        let sign = this.charge === chargedParticleArray[i].charge ? 1 : -1;
        let force = attractionConstant / distSq;
        this.vx += sign * force * Math.cos(angle);
        this.vy += sign * force * Math.sin(angle);
      }
    }
    
    let distToTop = this.y;
    let distToRight = canvas75.width - this.x;
    let distToBottom = canvas75.height - this.y;
    let distToLeft = this.x;
    this.vy += attractionConstant / (distToTop * distToTop);
    this.vx -= attractionConstant / (distToRight * distToRight);
    this.vy -= attractionConstant / (distToBottom * distToBottom);
    this.vx += attractionConstant / (distToLeft * distToLeft);
    
    this.vx *= 1 - friction75;
    this.vy *= 1 - friction75;
    
    ctx75.fillStyle = this.charge === "+" ? "blue" : "red";
    ctx75.fillCircle(this.x, this.y, this.radius);
  };
  let chargedParticleArray = [];
  
  function frame75() {
    ctx75.clearRect(0, 0, canvas75.width, canvas75.height);
    
    for (let i = 0; i < chargedParticleArray.length; i++) chargedParticleArray[i].render();
    
    if (canvas75Running) requestAnimationFrame(frame75);
  }
  frame75();
  
  function startCanvas75() {
    if (canvas75Running) canvas75Running = false;
    else {
      canvas75Running = true;
      frame75();
    }
  }
  
  canvas75.addEventListener("mousedown", e => {
    if (!canvas75Running) return;
    Mouse75.down = true;
    e.preventDefault();
    canvas75Rect = canvas75.getBoundingClientRect();
    let eX = (e.clientX - canvas75Rect.left) * canvas75Ratio;
    let eY = (e.clientY - canvas75Rect.top) * canvas75Ratio;
    let charge = "";
    if (chargeMode === 1) charge = "+";
    else if (chargeMode === 2) charge = "-";
    else charge = Math.random() >= 0.5 ? "+" : "-";
    chargedParticleArray.push(new ChargedParticle(eX, eY, charge));
  });
  canvas75.addEventListener("mouseup", e => {
    if (!canvas75Running) return;
    Mouse75.down = false;
  });
  canvas75.addEventListener("mousemove", e => {
    if (!canvas75Running || !Mouse75.down) return;
    e.preventDefault();
    canvas75Rect = canvas75.getBoundingClientRect();
    let eX = (e.clientX - canvas75Rect.left) * canvas75Ratio;
    let eY = (e.clientY - canvas75Rect.top) * canvas75Ratio;
    let charge = "";
    if (chargeMode === 1) charge = "+";
    else if (chargeMode === 2) charge = "-";
    else charge = Math.random() >= 0.5 ? "+" : "-";
    chargedParticleArray.push(new ChargedParticle(eX + randBetween(-2, 2), eY + randBetween(-2, 2), charge));
  });
</script>
<canvas id = "canvas74" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas74()">Start/Stop</button>
<button onclick = "BlackHole74.x = canvas74.width / 2; BlackHole74.y = canvas74.height / 2">Center Black Hole</button>
<button onclick = "ball74Array = []">Destroy Balls</button>
<button onclick = "randomizeBalls74()">Randomize Balls</button>
<button onclick = "centerBalls74()">Center Balls</button>
<div><b><u>Slow Mode:</u></b></div>
<input type = "checkbox" id = "slowMode74Checkbox" oninput = "updateSettings74()">
<div><b><u>Ball Size:</u></b> <span id = "ball74SizeTxt">15</span></div>
<input type = "range" min = "5" max = "30" step = "5" value = "15" id = "ball74SizeRange" oninput = "updateSettings74()">
<div><b><u>Black Hole Strength:</u></b> <span id = "blackHole74PowerTxt">0.25</span>x</div>
<input type = "range" min = "0" max = "200" step = "25" value = "25" id = "blackHole74PowerRange" oninput = "updateSettings74()">
<div><b><u>Black Hole Repels:</u></b></div>
<input type = "checkbox" id = "blackHoleRepelsCheckbox" oninput = "updateSettings74()">
<div><b><u>Ball Decay:</u></b> <span id = "ball74DecayTxt">0.050</span>x</div>
<input type = "range" min = "0" max = "250" step = "25" value = "50" id = "ball74DecayRange" oninput = "updateSettings74()">
<div class = "desc"><b><i>(9/19/2021)</i></b> Balls bouncing off the inside of a circle simulation. I want to add more settings at some point, such as turning gravity and changing its power, or maybe having the balls be attracted towards a black hole you can drag around.<br><b><i>(9/20/2021)</i></b> Added angled gravity and changed the settings some, as well as added ball decay that slowly shrinks the balls.<br><b><i>Update:</i></b> Added draggable black hole that the balls are attracted to.</div>
<hr><hr>
<script>
  const ctx74 = canvas74.getContext("2d");
  canvas74.width = canvas74.height = 1200;
  let canvas74Ratio = canvas74.width / 500;
  let canvas74Rect = canvas74.getBoundingClientRect();
  let canvas74Running = false;
  
  let Gravity74 = {
    power: 0.25,
    angle: 90
  };
  
  let terminalVelocity74 = 15;
  let maxBalls74 = 300;
  let ball74Decay = 0.05;
  let ball74Size = 15;
  let slowMode74 = false;
  
  let Mouse74 = {
    down: false,
    draggingBlackHole: false,
    blackHoleOffsetX: 0,
    blackHoleOffsetY: 0
  };
  
  let BlackHole74 = {
    x: 600,
    y: 1110,
    radius: 75,
    power: 0.25
  };
  BlackHole74.render = function() {
    ctx74.strokeStyle = ctx74.shadowColor = Mouse74.draggingBlackHole ? "hsl(270deg, 100%, 60%)" : "hsl(270deg, 100%, 40%)";
    ctx74.shadowBlur = 15;
    ctx74.lineWidth = 3;
    for (let i = 0; i < 6; i++) ctx74.strokeCircle(this.x, this.y, this.radius);
    ctx74.shadowBlur = 0;
    ctx74.fillStyle = "black";
    ctx74.fillCircle(this.x, this.y, this.radius);
  };
  
  let Circle74 = {
    x: canvas74.width / 2,
    y: canvas74.height / 2,
    radius: 400,
    thickness: 3
  };
  Circle74.render = function() {
    ctx74.strokeStyle = "white";
    ctx74.lineWidth = this.thickness * 2;
    ctx74.strokeCircle(this.x, this.y, this.radius);
    ctx74.lineWidth = this.thickness;
    ctx74.strokeCircle(this.x, this.y, this.radius + (this.thickness * 4));
  };
  
  function Ball74(x, y) {
    this.x = x;
    this.y = y;
    let a = Math.random() * Math.PI * 2;
    let m = Math.random() * 4;
    this.vx = m * Math.cos(a);
    this.vy = m * Math.sin(a);
    this.color = `hsl(${Math.random() * 360}deg, 100%, 50%)`;
    this.radius = randBetween(ball74Size / 3, ball74Size);
  }
  Ball74.prototype.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    
    this.radius -= Math.random() * ball74Decay;
    if (this.radius <= 0) {
      ball74Array.splice(ball74Array.indexOf(this), 1);
      return;
    }
    
    let cx = this.x - Circle74.x;
    let cy = this.y - Circle74.y;
    if ((cx * cx) + (cy * cy) >= (Circle74.radius - this.radius - Circle74.thickness) * (Circle74.radius - this.radius - Circle74.thickness)) {
      let angle = Math.atan2(cy, cx);
      
      this.x = Circle74.x + ((Circle74.radius - this.radius - Circle74.thickness) * Math.cos(angle));
      this.y = Circle74.y + ((Circle74.radius - this.radius - Circle74.thickness) * Math.sin(angle));
      
      let normal = angle + (Math.PI / 2);
      
      let resultX = this.vx - (2 * ((this.vx * Math.cos(normal)) + (this.vy * Math.sin(normal))) * Math.cos(normal));
      let resultY = this.vy - (2 * ((this.vx * Math.cos(normal)) + (this.vy * Math.sin(normal))) * Math.sin(normal));
      
      this.vx = -resultX;
      this.vy = -resultY;
    }
    else {
      //this.vy += Gravity74.power * Math.sin(toRad(Gravity74.angle));
      //this.vx += Gravity74.power * Math.cos(toRad(Gravity74.angle));
      let dx = BlackHole74.x - this.x;
      let dy = BlackHole74.y - this.y;
      let angleTo = Math.atan2(dy, dx);
      this.vx += BlackHole74.power * Math.cos(angleTo);
      this.vy += BlackHole74.power * Math.sin(angleTo);
    }
    
    if (Math.abs(this.vx) >= terminalVelocity74) this.vx = terminalVelocity74 * Math.sign(this.vx);
    if (Math.abs(this.vy) >= terminalVelocity74) this.vy = terminalVelocity74 * Math.sign(this.vy);
    
    ctx74.fillStyle = this.color;
    ctx74.fillCircle(this.x, this.y, this.radius);
  };
  let ball74Array = [];
  
  function frame74() {
    ctx74.clearRect(0, 0, canvas74.width, canvas74.height);
    
    Circle74.render();
    
    BlackHole74.render();
    
    for (let i = 0; i < ball74Array.length; i++) ball74Array[i].render();
    
    if (canvas74Running) {
      if (slowMode74) setTimeout(() => requestAnimationFrame(frame74), 50);
      else requestAnimationFrame(frame74);
    }
  }
  frame74();
  
  function startCanvas74() {
    if (canvas74Running) canvas74Running = false;
    else {
      canvas74Running = true;
      frame74();
    }
  }
  
  canvas74.addEventListener("mousedown", e => {
    if (!canvas74Running) return;
    e.preventDefault();
    Mouse74.down = true;
    canvas74Rect = canvas74.getBoundingClientRect();
    let eX = (e.clientX - canvas74Rect.left) * canvas74Ratio;
    let eY = (e.clientY - canvas74Rect.top) * canvas74Ratio;
    let dx = eX - BlackHole74.x;
    let dy = eY - BlackHole74.y;
    let distSq = (dx * dx) + (dy * dy);
    if (distSq <= BlackHole74.radius * BlackHole74.radius) {
      Mouse74.draggingBlackHole = true;
      Mouse74.blackHoleOffsetX = dx;
      Mouse74.blackHoleOffsetY = dy;
    }
    else {
      Mouse74.draggingBlackHole = false;
      ball74Array.push(new Ball74(eX, eY));
      while (ball74Array.length > maxBalls74) ball74Array.shift();
    }
  });
  window.addEventListener("mouseup", e => {
    if (!canvas74Running) return;
    Mouse74.down = false;
    Mouse74.draggingBlackHole = false;
  });
  canvas74.addEventListener("mousemove", e => {
    if (!canvas74Running || !Mouse74.down) return;
    e.preventDefault();
    canvas74Rect = canvas74.getBoundingClientRect();
    let eX = (e.clientX - canvas74Rect.left) * canvas74Ratio;
    let eY = (e.clientY - canvas74Rect.top) * canvas74Ratio;
    if (Mouse74.draggingBlackHole) {
      BlackHole74.x = eX - Mouse74.blackHoleOffsetX;
      BlackHole74.y = eY - Mouse74.blackHoleOffsetY;
    }
    else {
      ball74Array.push(new Ball74(eX, eY));
      while (ball74Array.length > maxBalls74) ball74Array.shift();
    }
  });
  
  function updateSettings74() {
    ball74Decay = Number(ball74DecayRange.value) / 1000;
    ball74DecayTxt.innerHTML = (Number(ball74DecayRange.value) / 1000).toFixed(3);
    slowMode74 = slowMode74Checkbox.checked;
    BlackHole74.power = Number(blackHole74PowerRange.value) / 100;
    blackHole74PowerTxt.innerHTML = (Number(blackHole74PowerRange.value) / 100).toFixed(2);
    if (blackHoleRepelsCheckbox.checked) BlackHole74.power *= -1;
    ball74Size = ball74SizeTxt.innerHTML = Number(ball74SizeRange.value);
  }
  
  function randomizeBalls74() {
    for (let i = 0; i < ball74Array.length; i++) {
      let a = Math.random() * Math.PI * 2;
      let r = Math.random() * (Circle74.radius - Circle74.thickness - ball74Array[i].radius);
      ball74Array[i].x = Circle74.x + (r * Math.cos(a));
      ball74Array[i].y = Circle74.y + (r * Math.sin(a));
      a = Math.random() * Math.PI * 2;
      let m = Math.random() * 4;
      ball74Array[i].vx = m * Math.cos(a);
      ball74Array[i].vy = m * Math.sin(a);
    }
  }
  
  function centerBalls74() {
    for (let i = 0; i < ball74Array.length; i++) {
      ball74Array[i].x = Circle74.x;
      ball74Array[i].y = Circle74.y;
      let a = Math.random() * Math.PI * 2;
      let m = Math.random() * 4;
      ball74Array[i].vx = m * Math.cos(a);
      ball74Array[i].vy = m * Math.sin(a);
    }
  }
</script>
<canvas id = "canvas73" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas73()">Start/Stop</button>
<button onclick = "resetBalls73()">Reset</button>
<div><b><u>Number of Balls:</u></b> <span id = "numBalls73Txt">1000</span></div>
<input type = "range" min = "0" max = "9" step = "1" value = "9" id = "numBalls73Range" oninput = "updateSettings73(true)">
<div><b><u>Circle Radius:</u></b> <span id = "circle73RadiusTxt">400</span></div>
<input type = "range" min = "100" max = "500" step = "100" value = "400" id = "circle73RadiusRange" oninput = "updateSettings73(false)">
<div class = "desc"><b><i>(9/19/2021)</i></b> Another Butterfly Effect simulation, with balls at slightly different offset bouncing along the inside of a circle. I got the bouncing working <i>kinda</i> right, but not perfectly and it doesn't seem very realistic, so I want to fix this.<br><b><i>Update: (about 5 minutes later):</i></b> I looked up a formula for vector reflection across a normal, and figured out I just needed to use dot products and now it works perfectly! There's 1000 balls, each offset by a millionth of a pixel.</div>
<hr><hr>
<script>
  const ctx73 = canvas73.getContext("2d");
  canvas73.width = canvas73.height = 1000;
  let canvas73Running = false;
  
  let numBalls73 = 1000;
  
  let Circle73 = {
    x: canvas73.width / 2,
    y: canvas73.height / 2,
    radius: 400
  };
  Circle73.render = function() {
    ctx73.strokeStyle = "white";
    ctx73.lineWidth = 7;
    ctx73.strokeCircle(this.x, this.y, this.radius);
  };
  
  function Ball73() {
    this.x = canvas73.width / 2;
    this.y = canvas73.height / 2;
    this.vx = 0;
    this.vy = 0;
    this.gravity = 0.2;
    this.color = "black";
  }
  Ball73.prototype.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    
    let cx = this.x - Circle73.x;
    let cy = this.y - Circle73.y;
    if ((cx * cx) + (cy * cy) >= Circle73.radius * Circle73.radius) {
      let angle = Math.atan2(cy, cx);
      
      this.x = Circle73.x + (Circle73.radius * Math.cos(angle));
      this.y = Circle73.y + (Circle73.radius * Math.sin(angle));
      
      let normal = angle + (Math.PI / 2);
      
      let resultX = this.vx - (2 * ((this.vx * Math.cos(normal)) + (this.vy * Math.sin(normal))) * Math.cos(normal));
      let resultY = this.vy - (2 * ((this.vx * Math.cos(normal)) + (this.vy * Math.sin(normal))) * Math.sin(normal));
      this.vx = -resultX;
      this.vy = -resultY;
    }
    else this.vy += this.gravity;
    
    if (Math.abs(this.vx) >= 15) this.vx = 15 * Math.sign(this.vx);
    if (Math.abs(this.vy) >= 15) this.vy = 15 * Math.sign(this.vy);
    
    ctx73.fillStyle = this.color;
    ctx73.fillCircle(this.x, this.y, 5);
  };
  let ball73Array = [];
  
  function resetBalls73() {
    ball73Array = [];
    for (let i = 0; i < numBalls73; i++) {
      let newBall73 = new Ball73();
      newBall73.x = (canvas73.width / 2) + (i / 1000000) + 0.001;
      newBall73.color = `hsl(${(i / numBalls73) * 360}deg, 100%, 60%)`;
      ball73Array.push(newBall73);
    }
    if (!canvas73Running) frame73();
  }
  resetBalls73();
  
  function frame73() {
    ctx73.clearRect(0, 0, canvas73.width, canvas73.height);
    
    for (let i = 0; i < ball73Array.length; i++) ball73Array[i].render();
    
    Circle73.render();
    
    if (canvas73Running) requestAnimationFrame(frame73);
  }
  frame73();
  
  function startCanvas73() {
    if (canvas73Running) canvas73Running = false;
    else {
      canvas73Running = true;
      frame73();
    }
  }
  
  let numBalls73Array = [2, 3, 5, 10, 25, 50, 100, 250, 500, 1000];
  
  function updateSettings73(reset) {
    numBalls73 = numBalls73Txt.innerHTML = numBalls73Array[Number(numBalls73Range.value)];
    Circle73.radius = circle73RadiusTxt.innerHTML = Number(circle73RadiusRange.value);
    if (reset) resetBalls73();
    else if (!canvas73Running) frame73();
  }
</script>
<canvas id = "canvas72" style = "background-color: black; width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas72()">Start/Stop</button>
<button onclick = "resetPendulums72()">Reset</button>
<div class = "desc"><b><i>(9/18/2021)</i></b> Butterfly Effect simulation, with 500 double pendulums, each offset by a millionth of a degree.</div>
<hr><hr>
<script>
  const ctx72 = canvas72.getContext("2d");
  canvas72.width = canvas72.height = 2000;
  let canvas72Running = false;
  
  function Pendulum72() {
    this.anchorX = canvas72.width / 2;
    this.anchorY = canvas72.height / 2;
    this.gravity = 3;
    this.timeSpeed = 0.05;
    this.stringLength1 = 450;
    this.stringLength2 = 450;
    this.mass1 = 2;
    this.mass2 = 2;
    this.angle1 = 0;
    this.angle2 = 0;
    this.velocity1 = 0;
    this.velocity2 = 0;
    this.acceleration1 = 0;
    this.acceleration2 = 0;
    this.color = "black";
  }
  Pendulum72.prototype.render = function() {
    for (let i = 0; i < 5; i++) {
      let mu = 1 + (this.mass1 / this.mass2);
      
      this.acceleration1 = (this.gravity * (Math.sin(this.angle2) * Math.cos(this.angle1 - this.angle2) - mu * Math.sin(this.angle1)) - (this.stringLength2 * this.velocity2 * this.velocity2 + this.stringLength1 * this.velocity1 * this.velocity1 * Math.cos(this.angle1 - this.angle2)) * Math.sin(this.angle1 - this.angle2)) / (this.stringLength1 * (mu - Math.cos(this.angle1 - this.angle2) * Math.cos(this.angle1 - this.angle2)));
      this.acceleration2 = (mu * this.gravity * (Math.sin(this.angle1) * Math.cos(this.angle1 - this.angle2) - Math.sin(this.angle2)) + (mu * this.stringLength1 * this.velocity1 * this.velocity1 + this.stringLength2 * this.velocity2 * this.velocity2 * Math.cos(this.angle1 - this.angle2)) * Math.sin(this.angle1 - this.angle2)) / (this.stringLength2 * (mu - Math.cos(this.angle1 - this.angle2) * Math.cos(this.angle1 - this.angle2)));
      
      this.velocity1 += this.acceleration1 * this.timeSpeed;
      if (Math.abs(this.velocity1) >= 1.5) this.velocity1 = 1.5 * Math.sign(this.velocity1);
      this.velocity2 += this.acceleration2 * this.timeSpeed;
      if (Math.abs(this.velocity2) >= 5) this.velocity2 = 5 * Math.sign(this.velocity2);
      this.angle1 += this.velocity1 * this.timeSpeed;
      this.angle1 = (this.angle1 + (Math.PI * 2)) % (Math.PI * 2);
      this.angle2 += this.velocity2 * this.timeSpeed;
      this.angle2 = (this.angle2 + (Math.PI * 2)) % (Math.PI * 2);
    }
    
    let x1 = this.anchorX + (this.stringLength1 * Math.cos(this.angle1 + (Math.PI / 2)));
    let y1 = this.anchorY + (this.stringLength1 * Math.sin(this.angle1 + (Math.PI / 2)));
    let x2 = x1 + (this.stringLength2 * Math.cos(this.angle2 + (Math.PI / 2)));
    let y2 = y1 + (this.stringLength2 * Math.sin(this.angle2 + (Math.PI / 2)));
    ctx72.fillStyle = ctx72.strokeStyle = this.color;
    ctx72.lineWidth = 4;
    ctx72.lineCap = ctx72.lineJoin = "round";
    ctx72.beginPath();
    ctx72.moveTo(this.anchorX, this.anchorY);
    ctx72.lineTo(x1, y1);
    ctx72.lineTo(x2, y2);
    ctx72.stroke();
    //ctx72.fillCircle(x1, y1, this.mass1);
    //ctx72.fillCircle(x2, y2, this.mass2);
  };
  let pendulum72Array = [];
  for (let i = 0; i < 500; i++) pendulum72Array.push(new Pendulum72());
  
  function resetPendulums72() {
    for (let i = 0; i < pendulum72Array.length; i++) {
      pendulum72Array[i] = new Pendulum72();
      pendulum72Array[i].angle1 = pendulum72Array[i].angle2 = toRad(-135) + toRad(i / 1000000);
      
      pendulum72Array[i].color = `hsl(240deg, 100%, ${((i / pendulum72Array.length) * 75) + 25}%)`;
    }
    if (!canvas72Running) frame72();
  }
  resetPendulums72();
  
  function frame72() {
    ctx72.clearRect(0, 0, canvas72.width, canvas72.height);
    
    for (let i = 0; i < pendulum72Array.length; i++) pendulum72Array[i].render();
    
    if (canvas72Running) requestAnimationFrame(frame72);
  }
  frame72();
  
  function startCanvas72() {
    if (canvas72Running) canvas72Running = false;
    else {
      canvas72Running = true;
      frame72();
    }
  }
</script>
<canvas id = "canvas71" style = "width: 400px; height: 400px"></canvas>
<button onclick = "BinaryTree.draw()">Go</button>
<button onclick = "randomizeSettings71()">Randomize Settings</button>
<div><b><u>Presets:</u></b></div>
<div id = "binaryTreePresetsDiv"></div>
<table>
  <tr valign = "top">
    <td style = "padding: 15px">
      <div style = "font-size: 16px"><i>Tree Settings</i></div>
      <div><b><u>Layers:</u></b> <span id = "binaryTreeMaxLayersTxt">16</span></div>
      <input type = "range" min = "1" max = "19" step = "1" value = "16" style = "margin-bottom: 15px" id = "binaryTreeMaxLayersRange" oninput = "updateSettings71(false)">
      <div><b><u>X Position:</u></b> <span id = "binaryTreeStartXTxt">42</span>%</div>
      <input type = "range" min = "0" max = "100" step = "1" value = "42" style = "margin-bottom: 15px" id = "binaryTreeStartXRange" oninput = "updateSettings71(false)">
      <div><b><u>Y Position:</u></b> <span id = "binaryTreeStartYTxt">90</span>%</div>
      <input type = "range" min = "0" max = "100" step = "1" value = "90" style = "margin-bottom: 15px" id = "binaryTreeStartYRange" oninput = "updateSettings71(false)">
      <div><b><u>Starting Angle:</u></b> <span id = "binaryTreeStartAngleTxt">270</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "15" value = "270" style = "margin-bottom: 15px" id = "binaryTreeStartAngleRange" oninput = "updateSettings71(false)">
      <div><b><u>Starting Branch Length:</u></b> <span id = "binaryTreeStartLengthTxt">250</span>px</div>
      <input type = "range" min = "25" max = "400" step = "25" value = "250" style = "margin-bottom: 15px" id = "binaryTreeStartLengthRange" oninput = "updateSettings71(false)">
      <div><b><u>Starting Branch Width:</u></b> <span id = "binaryTreeStartWidthTxt">15</span>px</div>
      <input type = "range" min = "1" max = "30" step = "1" value = "15" style = "margin-bottom: 15px" id = "binaryTreeStartWidthRange" oninput = "updateSettings71(false)">
      <div><b><u>Minimum Branch Width:</u></b> <span id = "binaryTreeMinWidthTxt">0.5</span>px</div>
      <input type = "range" min = "0" max = "20" step = "1" value = "5" style = "margin-bottom: 15px" id = "binaryTreeMinWidthRange" oninput = "updateSettings71(false)">
      <div><b><u>Rainbow Branches:</u></b></div>
      <input type = "checkbox" style = "margin-bottom: 15px" id = "binaryTreeRainbowBranchesCheckbox" oninput = "updateSettings71(false)" CHECKED>
      <div><b><u>Starting Hue:</u></b> <span id = "binaryTreeStartHueTxt">300</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "15" value = "300" style = "margin-bottom: 15px" id = "binaryTreeStartHueRange" oninput = "updateSettings71(false)">
      <div><b><u>Inverse Colors:</u></b></div>
      <input type = "checkbox" style = "margin-bottom: 15px" id = "binaryTreeInverseColorsCheckbox" oninput = "updateSettings71(false)">
    </td>
    <td style = "padding: 15px">
      <div style = "font-size: 16px"><i>Left Branch Settings</i></div>
      <div><b><u>Angle Offset:</u></b> <span id = "binaryTreeOffsetAngle1Txt">30</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "1" value = "30" style = "margin-bottom: 15px" id = "binaryTreeOffsetAngle1Range" oninput = "updateSettings71(false)">
      <div><b><u>Branch Length Ratio:</u></b> <span id = "binaryTreeLengthRatio1Txt">65</span>%</div>
      <input type = "range" min = "5" max = "95" step = "1" value = "65" style = "margin-bottom: 15px" id = "binaryTreeLengthRatio1Range" oninput = "updateSettings71(false)">
      <div><b><u>Branch Width Ratio:</u></b> <span id = "binaryTreeWidthRatio1Txt">50</span>%</div>
      <input type = "range" min = "5" max = "100" step = "5" value = "50" style = "margin-bottom: 15px" id = "binaryTreeWidthRatio1Range" oninput = "updateSettings71(false)">
      <div><b><u>Hue Offset:</u></b> <span id = "binaryTreeOffsetHue1Txt">25</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "5" value = "25" style = "margin-bottom: 15px" id = "binaryTreeOffsetHue1Range" oninput = "updateSettings71(false)">
    </td>
    <td style = "padding: 15px">
      <div style = "font-size: 16px"><i>Right Branch Settings</i></div>
      <div><b><u>Angle Offset:</u></b> <span id = "binaryTreeOffsetAngle2Txt">35</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "1" value = "35" style = "margin-bottom: 15px" id = "binaryTreeOffsetAngle2Range" oninput = "updateSettings71(false)">
      <div><b><u>Branch Length Ratio:</u></b> <span id = "binaryTreeLengthRatio2Txt">75</span>%</div>
      <input type = "range" min = "5" max = "95" step = "1" value = "75" style = "margin-bottom: 15px" id = "binaryTreeLengthRatio2Range" oninput = "updateSettings71(false)">
      <div><b><u>Branch Width Ratio:</u></b> <span id = "binaryTreeWidthRatio2Txt">80</span>%</div>
      <input type = "range" min = "5" max = "100" step = "5" value = "80" style = "margin-bottom: 15px" id = "binaryTreeWidthRatio2Range" oninput = "updateSettings71(false)">
      <div><b><u>Hue Offset:</u></b> <span id = "binaryTreeOffsetHue2Txt">35</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "5" value = "35" style = "margin-bottom: 15px" id = "binaryTreeOffsetHue2Range" oninput = "updateSettings71(false)">
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(9/18/2021)</i></b> Fractal Binary Tree generator, with separate settings for the new left and right branches.<br><b><i>(9/21/2021)</i></b> Added more presets.</div>
<hr><hr>
<script>
  const ctx71 = canvas71.getContext("2d");
  canvas71.width = canvas71.height = 1000;
  
  let BinaryTree = {
    startX: 0.42,
    startY: 0.9,
    startAngle: 270,
    startLength: 250,
    startWidth: 15,
    minWidth: 0.5,
    startHue: 300,
    
    offsetAngle1: 30,
    offsetAngle2: 35,
    
    lengthRatio1: 0.65,
    lengthRatio2: 0.75,
    
    widthRatio1: 0.5,
    widthRatio2: 0.8,
    
    offsetHue1: 25,
    offsetHue2: 35,
    
    rainbowBranches: true,
    
    inverseColors: false,
    
    maxLayers: 16,
    
    presets: [
      { // 1
        startX: 0.42,
        startY: 0.9,
        startAngle: 270,
        startLength: 250,
        startWidth: 15,
        minWidth: 0.5,
        startHue: 300,
        offsetAngle1: 30,
        offsetAngle2: 35,
        lengthRatio1: 0.65,
        lengthRatio2: 0.75,
        widthRatio1: 0.5,
        widthRatio2: 0.8,
        offsetHue1: 25,
        offsetHue2: 35,
        rainbowBranches: true,
        inverseColors: false,
        maxLayers: 16
      },
      { // 2
        startX: 0.5,
        startY: 0.9,
        startAngle: 270,
        startLength: 250,
        startWidth: 20,
        minWidth: 0.5,
        startHue: 0,
        offsetAngle1: 30,
        offsetAngle2: 30,
        lengthRatio1: 0.7,
        lengthRatio2: 0.7,
        widthRatio1: 0.7,
        widthRatio2: 0.7,
        offsetHue1: 25,
        offsetHue2: 25,
        rainbowBranches: true,
        inverseColors: false,
        maxLayers: 16
      },
      { // 3
        startX: 0.42,
        startY: 0.9,
        startAngle: 270,
        startLength: 300,
        startWidth: 25,
        minWidth: 0.5,
        startHue: 30,
        offsetAngle1: 20,
        offsetAngle2: 80,
        lengthRatio1: 0.65,
        lengthRatio2: 0.65,
        widthRatio1: 0.8,
        widthRatio2: 0.8,
        offsetHue1: 30,
        offsetHue2: 330,
        rainbowBranches: true,
        inverseColors: false,
        maxLayers: 16
      },
      { // 4
        startX: 0.57,
        startY: 0.73,
        startAngle: 270,
        startLength: 275,
        startWidth: 1,
        minWidth: 0.5,
        startHue: 240,
        offsetAngle1: 30,
        offsetAngle2: 180,
        lengthRatio1: 0.75,
        lengthRatio2: 0.7,
        widthRatio1: 1,
        widthRatio2: 1,
        offsetHue1: 0,
        offsetHue2: 0,
        rainbowBranches: true,
        inverseColors: false,
        maxLayers: 17
      },
      { // 5
        startX: 0.43,
        startY: 0.71,
        startAngle: 270,
        startLength: 200,
        startWidth: 1,
        minWidth: 0.5,
        startHue: 240,
        offsetAngle1: 180,
        offsetAngle2: 15,
        lengthRatio1: 0.7,
        lengthRatio2: 0.8,
        widthRatio1: 1,
        widthRatio2: 1,
        offsetHue1: 0,
        offsetHue2: 0,
        rainbowBranches: true,
        inverseColors: true,
        maxLayers: 17
      },
      { // 6
        startX: 0.32,
        startY: 0.94,
        startAngle: 315,
        startLength: 275,
        startWidth: 15,
        minWidth: 0.3,
        startHue: 300,
        offsetAngle1: 45,
        offsetAngle2: 0,
        lengthRatio1: 0.75,
        lengthRatio2: 0.7,
        widthRatio1: 0.8,
        widthRatio2: 0.7,
        offsetHue1: 25,
        offsetHue2: 35,
        rainbowBranches: false,
        inverseColors: false,
        maxLayers: 17
      },
      { // 7
        startX: 0.53,
        startY: 0.82,
        startAngle: 270,
        startLength: 350,
        startWidth: 25,
        minWidth: 0.5,
        startHue: 150,
        offsetAngle1: 120,
        offsetAngle2: 100,
        lengthRatio1: 0.7,
        lengthRatio2: 0.7,
        widthRatio1: 0.7,
        widthRatio2: 0.7,
        offsetHue1: 0,
        offsetHue2: 0,
        rainbowBranches: true,
        inverseColors: true,
        maxLayers: 15
      },
      { // 8
        startX: 0.5,
        startY: 0.85,
        startAngle: 270,
        startLength: 350,
        startWidth: 3,
        minWidth: 0.5,
        startHue: 0,
        offsetAngle1: 90,
        offsetAngle2: 90,
        lengthRatio1: 0.7,
        lengthRatio2: 0.7,
        widthRatio1: 1,
        widthRatio2: 1,
        offsetHue1: 0,
        offsetHue2: 5,
        rainbowBranches: true,
        inverseColors: false,
        maxLayers: 14
      },
      { // 9
        startX: 0.96,
        startY: 0.25,
        startAngle: 180,
        startLength: 375,
        startWidth: 25,
        minWidth: 1.2,
        startHue: 240,
        offsetAngle1: 15,
        offsetAngle2: 270,
        lengthRatio1: 0.7,
        lengthRatio2: 0.6,
        widthRatio1: 0.6,
        widthRatio2: 0.6,
        offsetHue1: 5,
        offsetHue2: 0,
        rainbowBranches: true,
        inverseColors: true,
        maxLayers: 16
      },
      { // 10
        startX: 0.75,
        startY: 0.9,
        startAngle: 270,
        startLength: 200,
        startWidth: 20,
        minWidth: 1,
        startHue: 300,
        offsetAngle1: 10,
        offsetAngle2: 315,
        lengthRatio1: 0.85,
        lengthRatio2: 0.55,
        widthRatio1: 0.75,
        widthRatio2: 0.3,
        offsetHue1: 25,
        offsetHue2: 35,
        rainbowBranches: false,
        inverseColors: true,
        maxLayers: 16
      },
      { // 11
        startX: 0.57,
        startY: 0.9,
        startAngle: 270,
        startLength: 250,
        startWidth: 15,
        minWidth: 0.7,
        startHue: 0,
        offsetAngle1: 60,
        offsetAngle2: 72,
        lengthRatio1: 0.75,
        lengthRatio2: 0.6,
        widthRatio1: 0.65,
        widthRatio2: 0.8,
        offsetHue1: 10,
        offsetHue2: 0,
        rainbowBranches: true,
        inverseColors: true,
        maxLayers: 16
      },
      { // 12
        startX: 0.6,
        startY: 0.71,
        startAngle: 225,
        startLength: 300,
        startWidth: 1,
        minWidth: 0.5,
        startHue: 330,
        offsetAngle1: 195,
        offsetAngle2: 10,
        lengthRatio1: 0.85,
        lengthRatio2: 0.65,
        widthRatio1: 0.05,
        widthRatio2: 0.05,
        offsetHue1: 0,
        offsetHue2: 0,
        rainbowBranches: true,
        inverseColors: true,
        maxLayers: 15
      }
      /*{
        startX: 0.42,
        startY: 0.9,
        startAngle: 270,
        startLength: 250,
        startWidth: 15,
        minWidth: 0.5,
        startHue: 300,
        offsetAngle1: 30,
        offsetAngle2: 35,
        lengthRatio1: 0.65,
        lengthRatio2: 0.75,
        widthRatio1: 0.5,
        widthRatio2: 0.8,
        offsetHue1: 25,
        offsetHue2: 35,
        rainbowBranches: true,
        inverseColors: false,
        maxLayers: 16
      }*/
    ]
  };
  for (let i = 0; i < BinaryTree.presets.length; i++) {
    let btn = document.createElement("button");
    btn.style.margin = "3px";
    btn.innerHTML = i + 1;
    btn.onclick = () => BinaryTree.loadPreset(i);
    binaryTreePresetsDiv.appendChild(btn);
  }
  BinaryTree.loadPreset = function(n) {
    binaryTreeStartXRange.value = this.presets[n].startX * 100;
    binaryTreeStartYRange.value = this.presets[n].startY * 100;
    binaryTreeStartAngleRange.value = this.presets[n].startAngle;
    binaryTreeStartLengthRange.value = this.presets[n].startLength;
    binaryTreeStartWidthRange.value = this.presets[n].startWidth;
    binaryTreeMinWidthRange.value = this.presets[n].minWidth * 10;
    binaryTreeStartHueRange.value = this.presets[n].startHue;
    binaryTreeOffsetAngle1Range.value = this.presets[n].offsetAngle1;
    binaryTreeOffsetAngle2Range.value = this.presets[n].offsetAngle2;
    binaryTreeLengthRatio1Range.value = this.presets[n].lengthRatio1 * 100;
    binaryTreeLengthRatio2Range.value = this.presets[n].lengthRatio2 * 100;
    binaryTreeWidthRatio1Range.value = this.presets[n].widthRatio1 * 100;
    binaryTreeWidthRatio2Range.value = this.presets[n].widthRatio2 * 100;
    binaryTreeOffsetHue1Range.value = this.presets[n].offsetHue1;
    binaryTreeOffsetHue2Range.value = this.presets[n].offsetHue2;
    binaryTreeRainbowBranchesCheckbox.checked = this.presets[n].rainbowBranches;
    binaryTreeInverseColorsCheckbox.checked = this.presets[n].inverseColors;
    binaryTreeMaxLayersRange.value = this.presets[n].maxLayers;
    
    updateSettings71(true);
  };
  BinaryTree.draw = function() {
    ctx71.fillStyle = this.inverseColors ? "black" : "white";
    ctx71.fillRect(0, 0, canvas71.width, canvas71.height);
    ctx71.lineCap = ctx71.lineJoin = "round";
    this.drawBranch(canvas71.width * this.startX, canvas71.height * this.startY, this.startAngle, this.startLength, this.startWidth, this.startHue, 0);
  };
  BinaryTree.drawBranch = function(x, y, angle, length, width, hue, currLayer) {
    if (currLayer >= this.maxLayers) return;
    let nextX = x + (length * Math.cos(toRad(angle)));
    let nextY = y + (length * Math.sin(toRad(angle)));
    let a = this.inverseColors ? 180 : 0;
    let c = this.inverseColors ? "white" : "black";
    ctx71.strokeStyle = this.rainbowBranches ? `hsl(${hue + a}deg, 100%, 50%)` : c;
    ctx71.lineWidth = Math.max(width, this.minWidth);
    ctx71.beginPath();
    ctx71.moveTo(x, y);
    ctx71.lineTo(nextX, nextY);
    ctx71.stroke();
    this.drawBranch(nextX, nextY, angle - this.offsetAngle1, length * this.lengthRatio1, width * this.widthRatio1, hue - this.offsetHue1, currLayer + 1);
    this.drawBranch(nextX, nextY, angle + this.offsetAngle2, length * this.lengthRatio2, width * this.widthRatio2, hue + this.offsetHue2, currLayer + 1);
  };
  BinaryTree.draw();
  
  function updateSettings71(drawTree) {
    BinaryTree.maxLayers = binaryTreeMaxLayersTxt.innerHTML = Number(binaryTreeMaxLayersRange.value);
    
    BinaryTree.startX = Number(binaryTreeStartXRange.value) / 100;
    binaryTreeStartXTxt.innerHTML = Number(binaryTreeStartXRange.value);
    
    BinaryTree.startY = Number(binaryTreeStartYRange.value) / 100;
    binaryTreeStartYTxt.innerHTML = Number(binaryTreeStartYRange.value);
    
    BinaryTree.startAngle = binaryTreeStartAngleTxt.innerHTML = Number(binaryTreeStartAngleRange.value);
    
    BinaryTree.startLength = binaryTreeStartLengthTxt.innerHTML = Number(binaryTreeStartLengthRange.value);
    
    BinaryTree.startWidth = binaryTreeStartWidthTxt.innerHTML = Number(binaryTreeStartWidthRange.value);
    
    BinaryTree.minWidth = binaryTreeMinWidthTxt.innerHTML = Number(binaryTreeMinWidthRange.value) / 10;
    
    BinaryTree.rainbowBranches = binaryTreeRainbowBranchesCheckbox.checked;
    
    BinaryTree.startHue = binaryTreeStartHueTxt.innerHTML = Number(binaryTreeStartHueRange.value);
    
    BinaryTree.offsetAngle1 = binaryTreeOffsetAngle1Txt.innerHTML = Number(binaryTreeOffsetAngle1Range.value);
    BinaryTree.offsetAngle2 = binaryTreeOffsetAngle2Txt.innerHTML = Number(binaryTreeOffsetAngle2Range.value);
    
    BinaryTree.lengthRatio1 = Number(binaryTreeLengthRatio1Range.value) / 100;
    binaryTreeLengthRatio1Txt.innerHTML = Number(binaryTreeLengthRatio1Range.value);
    BinaryTree.lengthRatio2 = Number(binaryTreeLengthRatio2Range.value) / 100;
    binaryTreeLengthRatio2Txt.innerHTML = Number(binaryTreeLengthRatio2Range.value);
    
    BinaryTree.widthRatio1 = Number(binaryTreeWidthRatio1Range.value) / 100;
    binaryTreeWidthRatio1Txt.innerHTML = Number(binaryTreeWidthRatio1Range.value);
    BinaryTree.widthRatio2 = Number(binaryTreeWidthRatio2Range.value) / 100;
    binaryTreeWidthRatio2Txt.innerHTML = Number(binaryTreeWidthRatio2Range.value);
    
    BinaryTree.offsetHue1 = binaryTreeOffsetHue1Txt.innerHTML = Number(binaryTreeOffsetHue1Range.value);
    BinaryTree.offsetHue2 = binaryTreeOffsetHue2Txt.innerHTML = Number(binaryTreeOffsetHue2Range.value);
    
    BinaryTree.inverseColors = binaryTreeInverseColorsCheckbox.checked;
    
    if (drawTree) BinaryTree.draw();
  }
  
  function randomizeRange(element) {
    return Number(randBetween(Number(element.min), Number(element.max))).toMultipleOf(Number(element.step));
  }
  
  function randomizeSettings71() {
    if (!confirm("Are you sure you want to randomize all settings?")) return;
    binaryTreeStartLengthRange.value = Math.round(randBetween(200, 400));
    binaryTreeStartWidthRange.value = randomizeRange(binaryTreeStartWidthRange);
    binaryTreeMinWidthRange.value = randomizeRange(binaryTreeMinWidthRange);
    binaryTreeRainbowBranchesCheckbox.checked = Math.random() >= 0.5;
    binaryTreeInverseColorsCheckbox.checked = Math.random() >= 0.5;
    binaryTreeStartHueRange.value = randomizeRange(binaryTreeStartHueRange);
    binaryTreeOffsetAngle1Range.value = randomizeRange(binaryTreeOffsetAngle1Range);
    binaryTreeLengthRatio1Range.value = Math.round(randBetween(25, 95));
    binaryTreeWidthRatio1Range.value = randomizeRange(binaryTreeWidthRatio1Range);
    binaryTreeOffsetHue1Range.value = randomizeRange(binaryTreeOffsetHue1Range);
    binaryTreeOffsetAngle2Range.value = randomizeRange(binaryTreeOffsetAngle2Range);
    binaryTreeLengthRatio2Range.value = Math.round(randBetween(25, 95));
    binaryTreeWidthRatio2Range.value = randomizeRange(binaryTreeWidthRatio2Range);
    binaryTreeOffsetHue2Range.value = randomizeRange(binaryTreeOffsetHue2Range);
    
    updateSettings71(true);
  }
</script>
<canvas id = "canvas70" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas70()">Start/Stop</button>
<button onclick = "BrownianWalker.reset()">Reset</button>
<div><b><u>Turbo:</u></b></div>
<input type = "checkbox" id = "brownianWalkerTurboCheckbox" oninput = "updateSettings70()">
<div><b><u>Friction:</u></b> <span id = "brownianWalkerFrictionTxt">5</span>%</div>
<input type = "range" min = "5" max = "50" step = "5" value = "5" id = "brownianWalkerFrictionRange" oninput = "updateSettings70()">
<div><b><u>Acceleration Mult:</u></b> <span id = "brownianWalkerAccMultTxt">0.5</span>x</div>
<input type = "range" min = "25" max = "300" step = "25" value = "50" id = "brownianWalkerAccMultRange" oninput = "updateSettings70()">
<div><b><u>Velocity Mult:</u></b> <span id = "brownianWalkerVelMultTxt">0.5</span>x</div>
<input type = "range" min = "10" max = "500" step = "10" value = "50" id = "brownianWalkerVelMultRange" oninput = "updateSettings70()">
<div class = "desc"><b><i>(9/16/2021)</i></b> Brownian motion simulator. I figured out that the other Brownian motion implementations I had, which were basically just a random walk, were not actually as representative of what Brownian motion actually looks like. This one adds a random unit vector to the velocity each step, scaled by the acceleration mult, and then scales down the velocity by the friction coefficient. The walker then steps forward based on the current velocity, scaled by the velocity mult.</div>
<hr><hr>
<script>
  const ctx70 = canvas70.getContext("2d");
  canvas70.width = canvas70.height = 1000;
  let canvas70Running = false;
  
  let BrownianWalker = {
    x: canvas70.width / 2,
    y: canvas70.height / 2,
    lastX: canvas70.width / 2,
    lastY: canvas70.height / 2,
    vx: 0,
    vy: 0,
    friction: 0.05,
    accMult: 0.5,
    velMult: 0.5,
    stepsPerFrame: 100
  };
  BrownianWalker.walk = function() {
    for (let i = 0; i < this.stepsPerFrame; i++) {
      let a = Math.random() * Math.PI * 2;
      this.vx += this.accMult * Math.cos(a);
      this.vy += this.accMult * Math.sin(a);
      
      this.vx *= 1 - this.friction;
      this.vy *= 1 - this.friction;
      
      this.lastX = this.x;
      this.lastY = this.y;
      this.x += this.vx * this.velMult;
      this.y += this.vy * this.velMult;
      
      if (this.x > canvas70.width || this.x < 0) {
        this.x = (this.x + canvas70.width) % canvas70.width;
        this.lastX = this.x;
      }
      if (this.y > canvas70.height || this.y < 0) {
        this.y = (this.y + canvas70.height) % canvas70.height;
        this.lastY = this.y;
      }
      
      ctx70.beginPath();
      ctx70.moveTo(this.lastX, this.lastY);
      ctx70.lineTo(this.x, this.y);
      ctx70.stroke();
    }
  };
  BrownianWalker.reset = function() {
    ctx70.clearRect(0, 0, canvas70.width, canvas70.height);
    this.x = this.lastX = canvas70.width / 2;
    this.y = this.lastY = canvas70.height / 2;
    this.vx = this.vy = 0;
    this.walk();
  };
  
  function frame70() {
    BrownianWalker.walk();
    
    if (canvas70Running) requestAnimationFrame(frame70);
  }
  frame70();
  
  function startCanvas70() {
    if (canvas70Running) canvas70Running = false;
    else {
      canvas70Running = true;
      frame70();
    }
  }
  
  function updateSettings70() {
    BrownianWalker.friction = Number(brownianWalkerFrictionRange.value) / 100;
    brownianWalkerFrictionTxt.innerHTML = brownianWalkerFrictionRange.value;
    BrownianWalker.accMult = brownianWalkerAccMultTxt.innerHTML = Number(brownianWalkerAccMultRange.value) / 100;
    BrownianWalker.velMult = brownianWalkerVelMultTxt.innerHTML = Number(brownianWalkerVelMultRange.value) / 100;
    BrownianWalker.stepsPerFrame = brownianWalkerTurboCheckbox.checked ? 2000 : 100;
  }
</script>
<canvas id = "canvas69" style = "background-color: black"></canvas>
<button onclick = "startCanvas69()">Start/Stop</button>
<div class = "desc"><b><i>(9/14/2021)</i></b> Random Fibonacci Sequence visualizer. Each term either adds or subtracts the two previous terms (scaled by a set scaling value). These values are then plotted around a polar graph, and filled with an even-odd fill rule, creating interesting chaotic spiky islands. Tomorrow I'll probably add sliders for maxValuesLength, scale, angle, and fillRule.<br><b><i>Update: (about 5 minutes later)</i></b> I realized the way I was getting the next term was backwards, I had it at (n - 1) - (n), when it should have been (n) - (n - 1). Fixing this completely changed the way the spirals form, and now the whole design is thrown off and tends towards zero, which creates very dull and uninteresting patterns. I had to mess with the scaling some to make it scale less when increasing, but this feels like it's no longer a good representation of the sequence because of how much I have to play with these values. At some point I want to fix the visualization to look good while still having the Random Fibonacci Sequence generate correctly.</div>
<hr><hr>
<script>
  const ctx69 = canvas69.getContext("2d");
  canvas69.width = canvas69.height = 1000;
  let canvas69Running = false;
  
  ctx69.translate(canvas69.width / 2, canvas69.height / 2);
  
  let RandomFibonacci = {
    values: [1, 1],
    maxValuesLength: 1000,
    scale: 5,
    angle: 10,
    offsetAngle: 0,
    fillRule: "evenodd",
    color: "blue"
  };
  RandomFibonacci.update = function() {
    if (Math.random() >= 0.5) this.values.push(this.values[this.values.length - 1] + (this.values[this.values.length - 2] / (this.scale * 0.8)));
    else this.values.push(this.values[this.values.length - 1] - (this.values[this.values.length - 2] / this.scale));
    if (this.values.length > this.maxValuesLength) {
      this.values.shift();
      this.offsetAngle += this.angle;
      this.angle = (this.angle + 360) % 360;
    }
  };
  RandomFibonacci.draw = function() {
    let maxValue = 0;
    for (let i = 0; i < this.values.length; i++) {
      if (Math.abs(this.values[i]) >= maxValue) maxValue = Math.abs(this.values[i]);
    }
    
    ctx69.fillStyle = this.color;
    ctx69.beginPath();
    ctx69.moveTo(0, 0);
    for (let i = 0; i < this.values.length; i++) {
      let len = (Math.abs(this.values[i]) / maxValue) * canvas69.width * 0.5;
      let a = toRad((i * this.angle) + this.offsetAngle)
      ctx69.lineTo(len * Math.cos(a), len * Math.sin(a));
    }
    ctx69.lineTo(0, 0);
    if (this.fillRule === "evenodd") ctx69.fill("evenodd");
    else ctx69.fill();
  };
  
  function frame69() {
    ctx69.clearRect(-canvas69.width / 2, -canvas69.height / 2, canvas69.width, canvas69.height);
    
    RandomFibonacci.update();
    RandomFibonacci.draw();
    
    if (canvas69Running) requestAnimationFrame(frame69);
  }
  frame69();
  
  function startCanvas69() {
    if (canvas69Running) canvas69Running = false;
    else {
      canvas69Running = true;
      frame69();
    }
  }
</script>
<canvas id = "canvas68" style = "background-color: black"></canvas>
<button onclick = "startCanvas68()">Start/Stop</button>
<div><b><u>Offset Angle:</u></b> <span id = "ball68OffsetAngleTxt">0</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "15" value = "0" id = "ball68OffsetAngleRange" oninput = "updateSettings68()">
<div class = "desc"><b><i>(9/13/2021)</i></b> Vector field visualizer with a ball flying around, and the vectors all pointing towards the mouse cursor, turned by a set offset angle from that angle.</div>
<hr><hr>
<script>
  const ctx68 = canvas68.getContext("2d");
  canvas68.width = canvas68.height = 1000;
  let canvas68Ratio = canvas68.width / 300;
  let canvas68Running = false;
  let canvas68Rect = canvas68.getBoundingClientRect();
  
  let Ball68 = {
    x: canvas68.width / 2,
    y: canvas68.height / 2,
    vx: 0,
    vy: 0,
    radius: 25,
    color: "blue",
    offsetAngle: 0,
    tail: [],
    tailLength: 500
  };
  Ball68.update = function() {
    this.x += this.vx;
    this.y += this.vy;
    
    let dx = Mouse68.x - this.x;
    let dy = Mouse68.y - this.y;
    let a = Math.atan2(dy, dx) + Ball68.offsetAngle;
    this.vx += Math.cos(a);
    this.vy += Math.sin(a);
    
    this.vx *= 0.95;
    this.vy *= 0.95;
    
    //this.x = (this.x + canvas68.width) % canvas68.width;
    //this.y = (this.y + canvas68.height) % canvas68.height;
    
    this.tail.push({x: this.x, y: this.y});
    if (this.tail.length > this.tailLength) this.tail.shift();
  };
  Ball68.draw = function() {
    ctx68.beginPath();
    for (let i = 0; i < this.tail.length; i++) ctx68.lineTo(this.tail[i].x, this.tail[i].y);
    
    ctx68.lineWidth = 10;
    ctx68.strokeStyle = "white";
    ctx68.stroke();
    
    ctx68.lineWidth = 5;
    ctx68.strokeStyle = this.color;
    ctx68.stroke();
    
    
    
    ctx68.fillStyle = this.color;
    ctx68.fillCircle(this.x, this.y, this.radius);
    
    ctx68.lineWidth = 3;
    ctx68.strokeStyle = "white";
    ctx68.strokeCircle(this.x, this.y, this.radius);
    
    
    
    ctx68.lineWidth = 10;
    ctx68.strokeStyle = "white";
    ctx68.drawArrow(this.x, this.y, this.x + (this.vx * 10), this.y + (this.vy * 10), toRad(60), 15);
    
    ctx68.lineWidth = 5;
    ctx68.strokeStyle = this.color;
    ctx68.drawArrow(this.x, this.y, this.x + (this.vx * 10), this.y + (this.vy * 10), toRad(60), 15);
  };
  
  let Mouse68 = {
    x: Ball68.x,
    y: Ball68.y
  };
  
  CanvasRenderingContext2D.prototype.drawArrow = function(startX, startY, endX, endY, headAngle, headLength) {
    let dx = endX - startX;
    let dy = endY - startY;
    let angle = Math.atan2(dy, dx);
    this.lineJoin = this.lineCap = "round";
    this.beginPath();
    this.moveTo(startX, startY);
    this.lineTo(endX, endY);
    this.moveTo(endX + (headLength * Math.cos(angle - headAngle - (Math.PI / 2))), endY + (headLength * Math.sin(angle - headAngle - (Math.PI / 2))));
    this.lineTo(endX, endY);
    this.lineTo(endX + (headLength * Math.cos(angle + headAngle + (Math.PI / 2))), endY + (headLength * Math.sin(angle + headAngle + (Math.PI / 2))));
    this.stroke();
  };
  
  let gridSize68 = 10;
  let tileSize68 = canvas68.width / gridSize68;
  function Vector68(x, y) {
    this.x = x * tileSize68;
    this.y = y * tileSize68;
    this.angle = 0;
    this.tileSize = tileSize68;
    this.magnitude = this.tileSize * 0.75;
    this.power = 1;
  }
  Vector68.prototype.draw = function() {
    ctx68.strokeStyle = "yellow";
    ctx68.lineWidth = 5;
    let halfMagX = this.magnitude * 0.5 * Math.cos(this.angle);
    let halfMagY = this.magnitude * 0.5 * Math.sin(this.angle);
    ctx68.drawArrow(this.x - halfMagX, this.y - halfMagY, this.x + halfMagX, this.y + halfMagY, toRad(60), 15);
  };
  Vector68.prototype.pointTowards = function(x, y, offsetAngle) {
    let dx = x - this.x;
    let dy = y - this.y;
    this.angle = Math.atan2(dy, dx) + offsetAngle;
  };
  let vector68Array = [];
  for (let x = 0; x < gridSize68; x++) {
    for (let y = 0; y < gridSize68; y++) {
      vector68Array.push(new Vector68(x + 0.5, y + 0.5));
    }
  }
  for (let i = 0; i < vector68Array.length; i++) {
    //vector68Array[i].angle = Math.floor(Math.random() * 4) * Math.PI * 0.5;
    vector68Array[i].pointTowards(Ball68.x, Ball68.y, 0);
  }
  
  function frame68() {
    ctx68.clearRect(0, 0, canvas68.width, canvas68.height);
    
    for (let i = 0; i < vector68Array.length; i++) vector68Array[i].draw();
    
    Ball68.update();
    Ball68.draw();
    
    if (canvas68Running) requestAnimationFrame(frame68);
  }
  frame68();
  
  function startCanvas68() {
    if (canvas68Running) canvas68Running = false;
    else {
      canvas68Running = true;
      frame68();
    }
  }
  
  canvas68.addEventListener("mousemove", e => {
    if (!canvas68Running) return;
    canvas68Rect = canvas68.getBoundingClientRect();
    let eX = (e.clientX - canvas68Rect.left) * canvas68Ratio;
    let eY = (e.clientY - canvas68Rect.top) * canvas68Ratio;
    Mouse68.x = eX;
    Mouse68.y = eY;
    for (let i = 0; i < vector68Array.length; i++) vector68Array[i].pointTowards(eX, eY, Ball68.offsetAngle);
  });
  
  function updateSettings68() {
    Ball68.offsetAngle = toRad(Number(ball68OffsetAngleRange.value));
    ball68OffsetAngleTxt.innerHTML = Number(ball68OffsetAngleRange.value);
  }
</script>
<canvas id = "canvas67"></canvas>
<button onclick = "startCanvas67()">Start/Stop</button>
<div class = "desc"><b><i>(9/9/2021)</i></b> I started the base code for a N-Bob Pendulum system, which at some point I want to implement, using the differential equations from <a href = "https://www.researchgate.net/publication/336868500_Equations_of_Motion_Formulation_of_a_Pendulum_Containing_N-point_Masses" target = "_blank">www.researchgate.net/publication/336868500_Equations_of_Motion_Formulation_of_a_Pendulum_Containing_N-point_Masses</a>. Currently, it does literally nothing, but eventually I want it to work like a pendulum with N amount of bobs.</div>
<hr><hr>
<script>
  const ctx67 = canvas67.getContext("2d");
  canvas67.width = canvas67.height = 1000;
  let canvas67Running = false;
  
  let Pendulum67 = {
    anchorX: canvas67.width / 2,
    anchorY: canvas67.height / 2,
    bobArray: [],
    bobNum: 6,
    gravity: 10
  };
  for (let i = 0; i < Pendulum67.bobNum; i++) {
    Pendulum67.bobArray.push({
      tempAngle: 0,
      angle: randBetween(-Math.PI / 2, Math.PI / 2),
      velocity: 0,
      acceleration: 0,
      stringLength: 50,
      mass: 15
    });
  }
  Pendulum67.tick = function() {
    
  };
  Pendulum67.draw = function() {
    ctx67.clearRect(0, 0, canvas67.width, canvas67.height);
    
    let endX = this.anchorX;
    let endY = this.anchorY;
    
    ctx67.lineWidth = 5;
    ctx67.lineCap = ctx67.lineJoin = "round";
    ctx67.beginPath();
    ctx67.moveTo(endX, endY);
    for (let i = 0; i < this.bobArray.length; i++) {
      endX += this.bobArray[i].stringLength * Math.cos(this.bobArray[i].angle + (Math.PI / 2));
      endY += this.bobArray[i].stringLength * Math.sin(this.bobArray[i].angle + (Math.PI / 2));
      ctx67.lineTo(endX, endY);
    }
    ctx67.stroke();
    
    endX = this.anchorX;
    endY = this.anchorY;
    for (let i = 0; i < this.bobArray.length; i++) {
      endX += this.bobArray[i].stringLength * Math.cos(this.bobArray[i].angle + (Math.PI / 2));
      endY += this.bobArray[i].stringLength * Math.sin(this.bobArray[i].angle + (Math.PI / 2));
      ctx67.fillCircle(endX, endY, this.bobArray[i].mass);
    }
  };
  
  function frame67() {
    Pendulum67.draw();
    
    if (canvas67Running) requestAnimationFrame(frame67);
  }
  frame67();
  
  function startCanvas67() {
    if (canvas67Running) canvas67Running = false;
    else {
      canvas67Running = true;
      frame67();
    }
  }
</script>
<canvas id = "canvas66" style = "width: 400px; height: 400px; background-color: black"></canvas>
<button onclick = "startCanvas66()">Start/Stop</button>
<button onclick = "Pendulum66.randomize()">Randomize</button>
<div><b><u>Bob 1 Mass:</u></b> <span id = "pendulum66Mass1Txt">30</span></div>
<input type = "range" min = "5" max = "50" step = "5" value = "30" id = "pendulum66Mass1Range" oninput = "updateSettings66()">
<div><b><u>Bob 2 Mass:</u></b> <span id = "pendulum66Mass2Txt">15</span></div>
<input type = "range" min = "5" max = "50" step = "5" value = "15" id = "pendulum66Mass2Range" oninput = "updateSettings66()">
<div class = "desc"><b><i>(9/8/2021)</i></b> Interactive double pendulum simulation, also based on differential equations. I had to use the code I stole <a href = "pendulum.html" target = "_blank">the last time I made a double pendulum</a>, but I improved the simulation and added the ability to drag it around with the mouse.<br><b><i><mark>Actually finished! (9/9/2021)</mark> Moved to <a href = "neon-pendulum.html" target = "_blank">neon-pendulum.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx66 = canvas66.getContext("2d");
  canvas66.width = canvas66.height = 1000;
  let canvas66Ratio = canvas66.width / 400;
  let canvas66Running = false;
  let canvas66Rect = canvas66.getBoundingClientRect();
  
  function randomizeRange(element) {
    return Number(randBetween(Number(element.min), Number(element.max))).toMultipleOf(Number(element.step));
  }
  
  let Mouse66 = {
    angleTo: 0,
    distTo: 0,
    down: false
  };
  
  let Pendulum66 = {
    x: canvas66.width / 2,
    y: canvas66.height / 2,
    gravity: 9.8,
    timeSpeed: 0.25,
    stringLength1: 150,
    stringLength2: 250,
    mass1: 30,
    mass2: 15,
    angle1: (Math.PI / 3) - (Math.PI / 2),
    angle2: (-Math.PI / 3) - (Math.PI / 2),
    velocity1: 0,
    velocity2: 0,
    acceleration1: 0,
    acceleration2: 0,
    tail: [],
    tailLength: 1000
  };
  Pendulum66.tick = function() {
    if (Mouse66.down) {
      this.angle1 = Mouse66.angleTo;
      //this.angle2 = Math.sin(Mouse66.angleTo) * Math.PI;
      this.stringLength1 = Mouse66.distTo;
      //this.stringLength2 = 300 - (this.stringLength1 / 2);
      this.velocity1 = this.velocity2 = 0;
      this.tail = [];
      this.addTailPoint();
      return;
    }
    
    let mu = 1 + (this.mass1 / this.mass2);
    
    this.acceleration1 = (this.gravity * (Math.sin(this.angle2) * Math.cos(this.angle1 - this.angle2) - mu * Math.sin(this.angle1)) - (this.stringLength2 * this.velocity2 * this.velocity2 + this.stringLength1 * this.velocity1 * this.velocity1 * Math.cos(this.angle1 - this.angle2)) * Math.sin(this.angle1 - this.angle2)) / (this.stringLength1 * (mu - Math.cos(this.angle1 - this.angle2) * Math.cos(this.angle1 - this.angle2)));
    this.acceleration2 = (mu * this.gravity * (Math.sin(this.angle1) * Math.cos(this.angle1 - this.angle2) - Math.sin(this.angle2)) + (mu * this.stringLength1 * this.velocity1 * this.velocity1 + this.stringLength2 * this.velocity2 * this.velocity2 * Math.cos(this.angle1 - this.angle2)) * Math.sin(this.angle1 - this.angle2)) / (this.stringLength2 * (mu - Math.cos(this.angle1 - this.angle2) * Math.cos(this.angle1 - this.angle2)));
    
    this.velocity1 += this.acceleration1 * this.timeSpeed;
    if (Math.abs(this.velocity1) >= 1.5) this.velocity1 = 1.5 * Math.sign(this.velocity1);
    this.velocity2 += this.acceleration2 * this.timeSpeed;
    this.angle1 += this.velocity1 * this.timeSpeed;
    this.angle1 = (this.angle1 + (Math.PI * 2)) % (Math.PI * 2);
    this.angle2 += this.velocity2 * this.timeSpeed;
    this.angle2 = (this.angle2 + (Math.PI * 2)) % (Math.PI * 2);
    
    this.addTailPoint();
  };
  Pendulum66.addTailPoint = function() {
    let bob1x = this.x + (this.stringLength1 * Math.cos(this.angle1 + (Math.PI / 2)));
    let bob1y = this.y + (this.stringLength1 * Math.sin(this.angle1 + (Math.PI / 2)));
    let bob2x = bob1x + (this.stringLength2 * Math.cos(this.angle2 + (Math.PI / 2)));
    let bob2y = bob1y + (this.stringLength2 * Math.sin(this.angle2 + (Math.PI / 2)));
    this.tail.push({x: bob2x, y: bob2y});
    while (this.tail.length > this.tailLength) this.tail.shift();
  };
  Pendulum66.draw = function() {
    ctx66.clearRect(0, 0, canvas66.width, canvas66.height);
    
    let bob1x = this.x + (this.stringLength1 * Math.cos(this.angle1 + (Math.PI / 2)));
    let bob1y = this.y + (this.stringLength1 * Math.sin(this.angle1 + (Math.PI / 2)));
    let bob2x = bob1x + (this.stringLength2 * Math.cos(this.angle2 + (Math.PI / 2)));
    let bob2y = bob1y + (this.stringLength2 * Math.sin(this.angle2 + (Math.PI / 2)));
    
    ctx66.lineWidth = 5;
    ctx66.lineCap = ctx66.lineJoin = "round";
    ctx66.strokeStyle = "white";
    ctx66.fillStyle = "black";
    ctx66.shadowBlur = 15;
    ctx66.shadowColor = "white";
    
    ctx66.beginPath();
    ctx66.moveTo(this.x, this.y);
    ctx66.lineTo(bob1x, bob1y);
    ctx66.lineTo(bob2x, bob2y);
    ctx66.stroke();
    
    ctx66.fillCircle(bob1x, bob1y, this.mass1);
    ctx66.strokeCircle(bob1x, bob1y, this.mass1);
    ctx66.fillCircle(bob2x, bob2y, this.mass2);
    ctx66.strokeCircle(bob2x, bob2y, this.mass2);
    
    ctx66.lineWidth = 3;
    ctx66.shadowBlur = 0;
    for (let i = 0; i < this.tail.length; i++) {
      ctx66.strokeStyle = `hsl(${(i / this.tail.length) * 3600}deg, 100%, 50%)`;
      ctx66.beginPath();
      ctx66.moveTo(this.tail[Math.max(0, i - 1)].x, this.tail[Math.max(0, i - 1)].y);
      ctx66.lineTo(this.tail[i].x, this.tail[i].y);
      ctx66.stroke();
    }
  };
  Pendulum66.randomize = function() {
    this.stringLength1 = randBetween(50, 300);
    this.stringLength2 = randBetween(50, 300);
    this.angle1 = Math.random() * Math.PI * 2;
    this.angle2 = Math.random() * Math.PI * 2;
    this.velocity1 = this.velocity2 = 0;
    
    pendulum66Mass1Range.value = randomizeRange(pendulum66Mass1Range);
    pendulum66Mass2Range.value = randomizeRange(pendulum66Mass2Range);
    
    updateSettings66();
    
    this.tail = [];
    this.addTailPoint();
  };
  
  
  function frame66() {
    Pendulum66.tick();
    Pendulum66.draw();
    
    if (canvas66Running) requestAnimationFrame(frame66);
  }
  frame66();
  
  function startCanvas66() {
    if (canvas66Running) canvas66Running = false;
    else {
      canvas66Running = true;
      frame66();
    }
  }
  
  canvas66.addEventListener("mousedown", e => {
    if (!canvas66Running) return;
    e.preventDefault();
    Mouse66.down = true;
    canvas66Rect = canvas66.getBoundingClientRect();
    let eX = (e.clientX - canvas66Rect.left) * canvas66Ratio;
    let eY = (e.clientY - canvas66Rect.top) * canvas66Ratio;
    let dX = Pendulum66.x - eX;
    let dY = Pendulum66.y - eY;
    let angleTo = Math.atan2(dY, dX);
    let distTo = Math.sqrt((dX * dX) + (dY * dY));
    Mouse66.angleTo = angleTo + (Math.PI / 2);
    Mouse66.distTo = distTo;
  });
  window.addEventListener("mouseup", e => {
    if (!canvas66Running) return;
    Mouse66.down = false;
  });
  canvas66.addEventListener("mousemove", e => {
    if (!canvas66Running || !Mouse66.down) return;
    e.preventDefault();
    canvas66Rect = canvas66.getBoundingClientRect();
    let eX = (e.clientX - canvas66Rect.left) * canvas66Ratio;
    let eY = (e.clientY - canvas66Rect.top) * canvas66Ratio;
    let dX = Pendulum66.x - eX;
    let dY = Pendulum66.y - eY;
    let angleTo = Math.atan2(dY, dX);
    let distTo = Math.sqrt((dX * dX) + (dY * dY));
    Mouse66.angleTo = angleTo + (Math.PI / 2);
    Mouse66.distTo = distTo;
  });
  
  function updateSettings66() {
    Pendulum66.mass1 = pendulum66Mass1Txt.innerHTML = Number(pendulum66Mass1Range.value);
    Pendulum66.mass2 = pendulum66Mass2Txt.innerHTML = Number(pendulum66Mass2Range.value);
    
    if (!canvas66Running) Pendulum66.draw();
  }
</script>
<canvas id = "canvas65" style = "width: 400px; height: 400px; background-color: black"></canvas>
<button onclick = "startCanvas65()">Start/Stop</button>
<br>
<button onclick = "Pendulum65.velocity += 0.05 * Math.sign(Pendulum65.velocity)">Speed Up</button>
<div class = "desc"><b><i>(9/8/2021)</i></b> Interactive pendulum swinging simulation, based on differential equations. Calculates angle and distance to the mouse when you drag it or click, letting you drag the pendulum bob around.</div>
<hr><hr>
<script>
  const ctx65 = canvas65.getContext("2d");
  canvas65.width = canvas65.height = 1000;
  let canvas65Ratio = canvas65.width / 400;
  let canvas65Running = false;
  let canvas65Rect = canvas65.getBoundingClientRect();
  
  let Mouse65 = {
    angleTo: 0,
    distTo: 0,
    down: false
  };
  
  let Pendulum65 = {
    x: canvas65.width / 2,
    y: canvas65.height / 2,
    gravity: 1.5,
    stringLength: 300,
    resistance: 0.005,
    angle: -Math.PI / 3,
    velocity: 0,
    acceleration: 0,
    timeStep: 1
  };
  Pendulum65.accelerate = function() {
    this.acceleration = (-this.resistance * this.velocity) - ((this.gravity / this.stringLength) * Math.sin(this.angle));
  };
  Pendulum65.tick = function() {
    if (Mouse65.down) {
      this.angle = Mouse65.angleTo;
      this.velocity = this.acceleration = 0;
      this.stringLength = Mouse65.distTo;
    }
    else {
      for (let i = 0; i < 100; i += this.timeStep) {
        this.accelerate();
        this.angle += this.velocity * (this.timeStep / 100);
        this.velocity += this.acceleration * (this.timeStep / 100);
      }
      if (Math.abs(this.velocity) >= 0.5) this.velocity = 0.5 * Math.sign(this.velocity);
    }
  };
  Pendulum65.draw = function() {
    let bobX = this.x + (this.stringLength * Math.cos(this.angle + (Math.PI / 2)));
    let bobY = this.y + (this.stringLength * Math.sin(this.angle + (Math.PI / 2)));
    ctx65.lineWidth = 5;
    ctx65.lineCap = ctx65.lineJoin = "round";
    ctx65.strokeStyle = "white";
    ctx65.fillStyle = "black";
    ctx65.shadowBlur = 15;
    ctx65.shadowColor = "white";
    ctx65.beginPath();
    ctx65.moveTo(this.x, this.y);
    ctx65.lineTo(bobX, bobY);
    ctx65.stroke();
    ctx65.fillCircle(bobX, bobY, 15);
    ctx65.strokeCircle(bobX, bobY, 15);
  };
  
  function frame65() {
    ctx65.clearRect(0, 0, canvas65.width, canvas65.height);
    
    Pendulum65.tick();
    Pendulum65.draw();
    
    if (canvas65Running) requestAnimationFrame(frame65);
  }
  frame65();
  
  function startCanvas65() {
    if (canvas65Running) canvas65Running = false;
    else {
      canvas65Running = true;
      frame65();
    }
  }
  
  canvas65.addEventListener("mousedown", e => {
    if (!canvas65Running) return;
    e.preventDefault();
    Mouse65.down = true;
    canvas65Rect = canvas65.getBoundingClientRect();
    let eX = (e.clientX - canvas65Rect.left) * canvas65Ratio;
    let eY = (e.clientY - canvas65Rect.top) * canvas65Ratio;
    let dX = Pendulum65.x - eX;
    let dY = Pendulum65.y - eY;
    let angleTo = Math.atan2(dY, dX);
    let distTo = Math.sqrt((dX * dX) + (dY * dY));
    Mouse65.angleTo = angleTo + (Math.PI / 2);
    Mouse65.distTo = distTo;
  });
  window.addEventListener("mouseup", e => {
    if (!canvas65Running) return;
    Mouse65.down = false;
  });
  canvas65.addEventListener("mousemove", e => {
    if (!canvas65Running || !Mouse65.down) return;
    e.preventDefault();
    canvas65Rect = canvas65.getBoundingClientRect();
    let eX = (e.clientX - canvas65Rect.left) * canvas65Ratio;
    let eY = (e.clientY - canvas65Rect.top) * canvas65Ratio;
    let dX = Pendulum65.x - eX;
    let dY = Pendulum65.y - eY;
    let angleTo = Math.atan2(dY, dX);
    let distTo = Math.sqrt((dX * dX) + (dY * dY));
    Mouse65.angleTo = angleTo + (Math.PI / 2);
    Mouse65.distTo = distTo;
  });
</script>
<span>When you hear about most really big numbers, it can be hard to visualize exactly <i>how</i> big they really are. Exactly how big <i>is</i> 1e</span>
<input type = "number" min = "80" id = "bigNumberDescInput" value = "100">
<span>?</span>
<button onclick = "generateBigNumberDesc()">Submit</button>
<div id = "bigNumberDescTxt"></div>
<div class = "desc"><b><i>(9/7/2021)</i></b> Generator to help describe and visualize massive numbers.<br><b><i>(9/8/2021)</i></b> Created the X years, X days, etc. function.</div>
<hr><hr>
<script>
  function totalTimeFromSeconds(s) {
    let comma = n => n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    
    let time = [];
    
    let t5 = s;
    let years = Math.floor(t5 / 31536000);
    if (years !== 0) time.push(comma(years) + " year" + (years === 1 ? "" : "s"));
    
    let t4 = t5 % 31536000;
    let days = Math.floor(t4 / 86400);
    if (days !== 0) time.push(days + " day" + (days === 1 ? "" : "s"));
      
    let t3 = t4 % 86400;
    let hours = Math.floor(t3 / 3600);
    if (hours !== 0) time.push(hours + " hour" + (hours === 1 ? "" : "s"));
    
    let t2 = t3 % 3600;
    let minutes = Math.floor(t2 / 60);
    if (minutes !== 0) time.push(minutes + " minute" + (minutes === 1 ? "" : "s"));
    
    let t1 = t2 % 60;
    let seconds = Math.floor(t1);
    if (seconds !== 0) time.push(seconds + " second" + (seconds === 1 ? "" : "s"));
    
    if (time.length !== 1) time[time.length - 1] = "and " + time[time.length - 1];
    
    return time.length === 2 ? time.join(" ") : time.join(", ");
  }
  function generateBigNumberDesc() {
    let comma = n => n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    let num = Math.floor(Number(bigNumberDescInput.value));
    if (num < 80) num = 80;
    if (num > Number.MAX_SAFE_INTEGER) num = Number.MAX_SAFE_INTEGER;
    bigNumberDescInput.value = num;
    let n80 = Math.floor(num / 80);
    let n1 = num + 1;
    bigNumberDescTxt.innerHTML = `1e${comma(num)} is a number that is ${comma(n1)} digits long. If you wrote 2 digits every second, it would take you ${totalTimeFromSeconds(Math.floor(n1 / 2))} to write the entire number down.<br><br>Scientists estimate there are around 1e80 atoms in the observable universe. This means that if you took every single atom in the universe and put the entire universe inside each of them, you would have 1e160 atoms. And if you did this process a second time, and put the entire universe inside each one of <i>those</i> atoms, you would have 1e240 atoms. You would have to do this process a total of ${comma(Math.floor(num / 80))} time${n80 === 1 ? "" : "s"} ${n80 * 80 === num ? ("to have 1e" + comma(num) + " atoms.") : ("and the number of atoms would still be 1e" + comma(num - (n80 * 80)) + " times smaller than 1e" + comma(num) + ".")}`;
  }
</script>
<canvas id = "canvas64" style = "width: 400px; height: 400px"></canvas>
<button onclick = "LSystem.iterate()">Go</button>
<br>
<div><b><u>Iterations:</u></b> <span id = "lSystemIterationsTxt">1</span></div>
<br>
<div><b><u>Directions Length:</u></b> <span id = "lSystemDirectionsLengthTxt">7</span></div>
<br>
<div id = "lSystemPresetsDiv"></div>
<div class = "desc"><b><i>(9/6/2021)</i></b> L-System generator, with a few presets, using <a href = "http://paulbourke.net/fractals/lsys" target = "_blank">paulbourke.net/fractals/lsys</a> and <a href = "https://en.wikipedia.org/wiki/L-system" target = "_blank">en.wikipedia.org/wiki/L-system</a> as a guide. There is a lot of unused potential in this system that at some point I want to fully utilize.<br><b><i>(9/7/2021)</i></b> Added a lot more presets, and added custom replace direction functions per preset, to allow for more systems such as using X or G. I also added the ability to use [ and ] to save and restore the current position and angle, and symbols like |, (, and ).</div>
<hr><hr>
<script>
  const ctx64 = canvas64.getContext("2d");
  canvas64.width = canvas64.height = 1000;
  
  let LSystem = {};
  LSystem.iterate = function() {
    let oldDirections = this.directions;
    if (oldDirections.length < 2000000) this.replaceDirections();
    if (this.directions.length >= 2000000) this.directions = oldDirections;
    else this.iterations++;
    lSystemIterationsTxt.innerHTML = this.iterations;
    lSystemDirectionsLengthTxt.innerHTML = this.directions.length.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    this.draw();
  };
  LSystem.draw = function() {
    ctx64.clearRect(0, 0, canvas64.width, canvas64.height);
    let x = this.x;
    let y = this.y;
    let a = this.getAngle();
    let r = this.angle;
    let s = this.size * Math.pow(this.scalingFactor, this.iterations);
    let save = [{x: x, y: y, a: a, r: r}];
    let currSave = -1;
    ctx64.lineJoin = ctx64.lineCap = "round";
    ctx64.beginPath();
    ctx64.moveTo(x, y);
    //let minX,maxX,minY,maxY;minX=minY=Infinity;maxX=maxY=0;
    for (let i = 0; i < this.directions.length; i++) {
      if (this.directions.charAt(i) === "F" || this.directions.charAt(i) === "G" || this.directions.charAt(i) === "H") {
        x += s * Math.cos(toRad(a));
        y += s * Math.sin(toRad(a));
        ctx64.lineTo(x, y);
        //if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;
      }
      if (this.directions.charAt(i) === "M") {
        ctx64.stroke();
        x += s * Math.cos(toRad(a));
        y += s * Math.sin(toRad(a));
        ctx64.beginPath();
        ctx64.moveTo(x, y);
        //if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;
      }
      if (this.directions.charAt(i) === "-") a += r;
      else if (this.directions.charAt(i) === "+") a -= r;
      else if (this.directions.charAt(i) === "[") {
        currSave++;
        save[currSave] = {x: x, y: y, a: a, r: r};
      }
      else if (this.directions.charAt(i) === "]") {
        ctx64.stroke();
        ctx64.beginPath();
        x = save[currSave].x;
        y = save[currSave].y;
        a = save[currSave].a;
        r = save[currSave].r;
        ctx64.moveTo(x, y);
        currSave--;
        //if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;
      }
      else if (this.directions.charAt(i) === "|") a += 180;
      else if (this.directions.charAt(i) === "(") r -= this.angleIncrement;
      else if (this.directions.charAt(i) === ")") r += this.angleIncrement;
    }
    //console.log(maxY - minY);
    ctx64.stroke();
  };
  LSystem.reset = function() {
    this.iterations = 1;
    this.directions = this.startingDirections;
    lSystemIterationsTxt.innerHTML = this.iterations;
    lSystemDirectionsLengthTxt.innerHTML = this.directions.length.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    this.draw();
  };
  LSystem.preset = function(n) {
    if (n === 1) {
      this.x = 50;
      this.y = 950;
      this.size = 2700;
      this.scalingFactor = 1 / 3;
      this.angle = 90;
      this.offsetAngle = 0;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F+F+F+F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "FF+F+F+F+FF");
    }
    else if (n === 2) {
      this.x = 220;
      this.y = 780;
      this.size = 2250;
      this.scalingFactor = 0.25;
      this.angle = 90;
      this.offsetAngle = 0;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F+F+F+F"//"F-F"//"F+F-F+F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "F+F-F-FF+F+F-F");//"F+F--F";
    }
    else if (n === 3) {
      this.x = 710;
      this.y = 670;
      this.size = 600;
      this.scalingFactor = Math.SQRT1_2;
      this.angle = 45;
      this.offsetAngle = 180;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "-F++F-");
    }
    else if (n === 4) {
      this.x = 275;
      this.y = 885;
      this.size = 1200;
      this.scalingFactor = Math.sqrt(1 / 3);
      this.angle = 120;
      this.offsetAngle = 0;
      this.angleFactor = -30;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F+F+F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "F-F+F");
    }
    else if (n === 5) {
      this.x = 34;
      this.y = 965;
      this.size = 2800;
      this.scalingFactor = 1 / 3;
      this.angle = 90;
      this.offsetAngle = 0;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F+F+F+F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "FF+F++F+F");
    }
    else if (n === 6) {
      this.x = 85;
      this.y = 740;
      this.size = 2500;
      this.scalingFactor = 1 / 3;
      this.angle = 60;
      this.offsetAngle = 0;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F++F++F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "F-F++F-F");
    }
    else if (n === 7) {
      this.x = 175;
      this.y = 690;
      this.size = 650;
      this.scalingFactor = Math.sqrt(1 / 3);
      this.angle = 60;
      this.offsetAngle = 0;
      this.angleFactor = 30;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F+F+F+F+F+F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "F++F--F");
    }
    else if (n === 8) {
      this.x = 240;
      this.y = 765;
      this.size = 325;
      this.scalingFactor = Math.sqrt(1 / 3);
      this.angle = 30;
      this.offsetAngle = 0;
      this.angleFactor = 30;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F+F+F+F+F+F+F+F+F+F+F+F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "F++++F----F");
    }
    else if (n === 9) {
      this.x = 110;
      this.y = 930;
      this.size = 800;
      this.scalingFactor = 0.5;
      this.angle = 25;
      this.offsetAngle = 295;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "X";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/X/g, "f+[[X]-X]-f[-fX]+X");
        this.directions = this.directions.replace(/F/g, "FF");
        this.directions = this.directions.replace(/f/g, "F");
      };
    }
    else if (n === 10) {
      this.x = 50;
      this.y = 885;
      this.size = 1800;
      this.scalingFactor = 0.5;
      this.angle = 60;
      this.offsetAngle = -60;
      this.angleFactor = 60;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + ((this.iterations % 2) * this.angleFactor);
      this.startingDirections = "F";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/F/g, "g-F-g");
        this.directions = this.directions.replace(/G/g, "F+G+F");
        this.directions = this.directions.replace(/g/g, "G");
      }
    }
    else if (n === 11) {
      this.x = 950;
      this.y = 880;
      this.size = 1800;
      this.scalingFactor = 0.5;
      this.angle = 120;
      this.offsetAngle = 180;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F-G-G";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/F/g, "F-g+F+g-F");
        this.directions = this.directions.replace(/G/g, "GG");
        this.directions = this.directions.replace(/g/g, "G");
      }
    }
    else if (n === 12) {
      this.x = 500;
      this.y = 915;
      this.size = 2500;
      this.scalingFactor = 1 / 3;
      this.angle = 45;
      this.offsetAngle = -90;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "F[+FF][-FF]F[-F][+F]F");
    }
    else if (n === 13) {
      this.x = 100;
      this.y = 100;
      this.size = 2000;
      this.scalingFactor = 0.2;
      this.angle = 90;
      this.offsetAngle = 0;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "-HF";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/G/g, "GFG-hF-hF+FG+FG-hF-hFFG+hF+FGFGhF-FG+hF+FGFG+hF-FGhF-hF-FG+FG+hFhF-");
        this.directions = this.directions.replace(/H/g, "+FGFG-HF-HF+FG+FGHF+FG-HFHF-FG-HF+FGHFHF-FG-HFFG+FG+HF-HF-FG+FG+HFH");
        this.directions = this.directions.replace(/h/g, "H");
      }
    }
    else if (n === 14) {
      this.x = 270;
      this.y = 730;
      this.size = 1000;
      this.scalingFactor = Math.sqrt(1 / 5);
      this.angle = 90;
      this.offsetAngle = -26.5;
      this.angleFactor = 26.5;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F+F+F+F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "F+FF++F+F");
    }
    else if (n === 15) {
      this.x = 215;
      this.y = 935;
      this.size = 1500;
      this.scalingFactor = 0.382;
      this.angle = 36;
      this.offsetAngle = 0;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F++F++F++F++F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "F++F++F|F-F++F");
    }
    else if (n === 16) {
      this.x = 550;
      this.y = 940;
      this.size = 600;
      this.scalingFactor = 0.5;
      this.angle = 25;
      this.offsetAngle = -90;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "X";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/F/g, "FF");
        this.directions = this.directions.replace(/X/g, "F+[-F-XF-X][+FF][--XF[+X]][++F-X]");
      };
    }
    else if (n === 17) {
      this.x = 550;
      this.y = 940;
      this.size = 600;
      this.scalingFactor = 0.5;
      this.angle = 10;
      this.offsetAngle = -90;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "X";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/F/g, "FF");
        this.directions = this.directions.replace(/X/g, "F+[F+X-X][X-F+F][F[+F]+X]");
      };
    }
    else if (n === 18) {
      this.x = 550;
      this.y = 940;
      this.size = 900;
      this.scalingFactor = 0.5;
      this.angle = 15;
      this.offsetAngle = -90;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "X";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/F/g, "FF");
        this.directions = this.directions.replace(/X/g, "F[+++X++X][X-X+X][-X--X]");
      };
    }
    else if (n === 19) {
      this.x = 250;
      this.y = 985;
      this.size = 650;
      this.scalingFactor = 0.5;
      this.angle = 15;
      this.offsetAngle = -45;
      this.angleFactor = 0;
      this.angleIncrement = 15;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "X";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/F/g, "FF");
        this.directions = this.directions.replace(/X/g, "F+[F--X+X][X++X-F]FF");
      };
    }
    else if (n === 20) {
      this.x = 450;
      this.y = 940;
      this.size = 600;
      this.scalingFactor = 0.5;
      this.angle = 15;
      this.offsetAngle = -90;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "XY";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/F/g, "FF");
        this.directions = this.directions.replace(/X/g, "F[+++X-y][X--X+y][--y-X]y");
        this.directions = this.directions.replace(/Y/g, "F[+++Y--X][--X+Y-F]X");
        this.directions = this.directions.replace(/y/g, "Y");
      };
    }
    else if (n === 21) {
      this.x = 450;
      this.y = 940;
      this.size = 450;
      this.scalingFactor = 0.5;
      this.angle = 15;
      this.offsetAngle = -90;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "XY";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/F/g, "FF");
        this.directions = this.directions.replace(/X/g, "F[+y+X--y+XF][+X---yFX]");
        this.directions = this.directions.replace(/Y/g, "FF[+X--Y][-YF++XF]");
        this.directions = this.directions.replace(/y/g, "Y");
      };
    }
    else if (n === 22) {
      this.x = 400;
      this.y = 940;
      this.size = 360;
      this.scalingFactor = 0.5;
      this.angle = 15;
      this.offsetAngle = -90;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "[++Y][Y][--Y]";
      this.replaceDirections = () => {
        this.directions = this.directions.replace(/F/g, "FF");
        this.directions = this.directions.replace(/X/g, "F[+X+F+y[--y--X]][+X--y]");
        this.directions = this.directions.replace(/Y/g, "F[-Y-XY]F[-XF++Y]FF");
        this.directions = this.directions.replace(/y/g, "Y");
      };
    }
    /*else if (n === #) {
      this.x = canvas64.width / 2;
      this.y = canvas64.height / 2;
      this.size = 1000;
      this.scalingFactor = 0.5;
      this.angle = 90;
      this.offsetAngle = 0;
      this.angleFactor = 0;
      this.angleIncrement = 0;
      this.getAngle = () => this.offsetAngle + (this.iterations * this.angleFactor);
      this.startingDirections = "F";
      this.replaceDirections = () => this.directions = this.directions.replace(/F/g, "F+");
    }*/
    this.reset();
  };
  LSystem.preset(1);
  
  /*function rand64() {
    let len = Math.round(randBetween(3, 6));
    let str = "";
    let a = "FXY+-";
    for (let i = 0; i < len; i++) str += a.charAt(Math.floor(Math.random() * a.length));
    return str;
  }*/
  
  let numPresets64 = 22;
  
  for (let i = 1; i <= numPresets64; i++) {
    let btn = document.createElement("button");
    btn.style.margin = "2px";
    btn.style.backgroundColor = i === 1 ? "gray" : "white";
    btn.innerHTML = i;
    btn.id = "lSystemPresetBtn" + i;
    btn.onclick = () => {
      LSystem.preset(i);
      for (let j = 1; j <= numPresets64; j++) {
        document.getElementById("lSystemPresetBtn" + j).style.backgroundColor = "white";
      }
      btn.style.backgroundColor = "gray";
    }
    lSystemPresetsDiv.appendChild(btn);
  }
  
  let canvas64Rect = canvas64.getBoundingClientRect();
  let canvas64Ratio = canvas64.width / 400;
  canvas64.addEventListener("mousedown", e => {
    canvas64Rect = canvas64.getBoundingClientRect();
    LSystem.x = (e.clientX - canvas64Rect.left) * canvas64Ratio;
    LSystem.y = (e.clientY - canvas64Rect.top) * canvas64Ratio;
    LSystem.draw();
  });
</script>
<canvas id = "canvas63" style = "width: 400px; height: 400px; background-color: black"></canvas>
<button onclick = "TerdragonCurve.iterate(); TerdragonCurve.draw()">Go</button>
<button onclick = "TerdragonCurve.reset()">Reset</button>
<div><b><u>Iterations:</u></b> <span id = "terdragonCurveIterationsTxt">1</span></div>
<br>
<div><b><u>Directions Length:</u></b> <span id = "terdragonCurveDirectionsLengthTxt">1</span></div>
<div class = "desc"><b><i>(9/6/2021)</i></b> Terdragon Curve generator.</div>
<hr><hr>
<script>
  const ctx63 = canvas63.getContext("2d");
  canvas63.width = canvas63.height = 1000;
  
  let TerdragonCurve = {
    x: 150,
    y: 300,
    directions: "F",
    stepSize: 1400,
    iterations: 1
  };
  TerdragonCurve.iterate = function() {
    this.iterations++;
    this.directions = this.directions.replace(/F/g, "F+F-F");
    terdragonCurveIterationsTxt.innerHTML = this.iterations;
    terdragonCurveDirectionsLengthTxt.innerHTML = this.directions.length.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  };
  TerdragonCurve.draw = function() {
    ctx63.clearRect(0, 0, canvas63.width, canvas63.height);
    let a = this.iterations * 30;
    let x = this.x;
    let y = this.y;
    let s = this.stepSize * Math.pow(Math.sqrt(1 / 3), this.iterations);
    ctx63.lineJoin = ctx63.lineCap = "round";
    ctx63.strokeStyle = "blue";
    ctx63.beginPath();
    ctx63.moveTo(x, y);
    for (let i = 0; i < this.directions.length; i++) {
      if (this.directions.charAt(i) === "F") {
        x += s * Math.cos(toRad(a));
        y += s * Math.sin(toRad(a));
        ctx63.lineTo(x, y);
      }
      else if (this.directions.charAt(i) === "-") a += 120;
      else if (this.directions.charAt(i) === "+") a -= 120;
    }
    ctx63.stroke();
  };
  TerdragonCurve.reset = function() {
    this.iterations = 1;
    this.directions = "F";
    this.draw();
    terdragonCurveIterationsTxt.innerHTML = this.iterations;
    terdragonCurveDirectionsLengthTxt.innerHTML = this.directions.length.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  };
  TerdragonCurve.draw();
</script>
<canvas id = "canvas62" style = "width: 400px; height: 400px; background-color: black"></canvas>
<button onclick = "DragonCurve.iterate(); DragonCurve.draw()">Go</button>
<button onclick = "DragonCurve.reset()">Reset</button>
<div><b><u>Iterations:</u></b> <span id = "dragonCurveIterationsTxt">1</span></div>
<br>
<div><b><u>Folds:</u></b> <span id = "dragonCurveFoldsTxt">1</span></div>
<div class = "desc"><b><i>(9/6/2021)</i></b> Simple Heighway Dragon Curve generator.</div>
<hr><hr>
<script>
  const ctx62 = canvas62.getContext("2d");
  canvas62.width = canvas62.height = 1000;
  
  let DragonCurve = {
    x: 370,
    y: 700,
    directions: "R",
    stepSize: 800,
    iterations: 2
  };
  DragonCurve.iterate = function() {
    this.iterations++;
    let reverse = this.directions.split("").reverse().join("");
    reverse = reverse.replace(/R/g, "l");
    reverse = reverse.replace(/L/g, "R");
    reverse = reverse.replace(/l/g, "L");
    this.directions += "R" + reverse;
    dragonCurveIterationsTxt.innerHTML = this.iterations - 1;
    dragonCurveFoldsTxt.innerHTML = this.directions.length.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  };
  DragonCurve.reset = function() {
    this.iterations = 2;
    this.directions = "R";
    this.draw();
    dragonCurveIterationsTxt.innerHTML = this.iterations - 1;
    dragonCurveFoldsTxt.innerHTML = this.directions.length.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  };
  DragonCurve.draw = function() {
    ctx62.clearRect(0, 0, canvas62.width, canvas62.height);
    let a = this.iterations * (-Math.PI / 4);
    let x = this.x + (this.stepSize * Math.pow(Math.SQRT1_2, this.iterations)) * Math.cos(a);
    let y = this.y + (this.stepSize * Math.pow(Math.SQRT1_2, this.iterations)) * Math.sin(a);
    let s = this.stepSize * Math.pow(Math.SQRT1_2, this.iterations);
    ctx62.lineJoin = ctx62.lineCap = "round";
    //ctx62.strokeStyle = `hsl(60deg, 100%, 10%)`;
    ctx62.strokeStyle = "yellow";
    ctx62.beginPath();
    ctx62.moveTo(this.x, this.y);
    ctx62.lineTo(x, y);
    ctx62.stroke();
    for (let i = 0; i < this.directions.length; i++) {
      //ctx62.fillStyle = this.directions.charAt(i) === "R" ? "red" : "blue";
      //ctx62.fillCircle(x, y, (this.stepSize * Math.pow(Math.SQRT1_2, this.iterations)) / 2);
      let oldX = x;
      let oldY = y;
      a += this.directions.charAt(i) === "R" ? Math.PI / 2 : -Math.PI / 2;
      x += s * Math.cos(a);
      y += s * Math.sin(a);
      //ctx62.strokeStyle = `hsl(60deg, 100%, ${((i / this.directions.length) * 80) + 10}%)`;
      //ctx62.strokeStyle = `hsl(${(i / this.directions.length) * 1440}deg, 100%, ${((i / this.directions.length) * 70) + 15}%)`;
      ctx62.beginPath();
      ctx62.moveTo(oldX, oldY);
      ctx62.lineTo(x, y);
      ctx62.stroke();
    }
  };
  DragonCurve.draw();
</script>
<canvas id = "canvas61"></canvas>
<button onclick = "startCanvas61()">Start/Stop</button>
<button onclick = "CurlWalker.resetPos()">Reset</button>
<br>
<button onclick = "CurlWalker.s = Math.SQRT2; CurlWalker.resetPos()">&Sqrt;2</button>
<button onclick = "CurlWalker.s = Math.sqrt(3); CurlWalker.resetPos()">&Sqrt;3</button>
<button onclick = "CurlWalker.s = Math.sqrt(5); CurlWalker.resetPos()">&Sqrt;5</button>
<button onclick = "CurlWalker.s = Math.sqrt(8); CurlWalker.resetPos()">&Sqrt;8</button>
<button onclick = "CurlWalker.s = Math.PI; CurlWalker.resetPos()">&pi;</button>
<button onclick = "CurlWalker.s = Math.E; CurlWalker.resetPos()">e</button>
<br><br>
<button onclick = "CurlWalker.s = Math.LN2; CurlWalker.resetPos()">ln(2)</button>
<button onclick = "CurlWalker.s = Math.LN10; CurlWalker.resetPos()">ln(10)</button>
<button onclick = "CurlWalker.s = (1 + Math.sqrt(5)) / 2; CurlWalker.resetPos()">&phi;</button>
<div class = "desc"><b><i>(9/5/2021)</i></b> Curlicue Fractal generator, from <a href = "https://oolong.co.uk/curlicue.htm" target = "_blank">oolong.co.uk/curlicue.htm</a> and <a href = "https://archive.lib.msu.edu/crcmath/math/math/c/c850.htm" target = "_blank">archive.lib.msu.edu/crcmath/math/math/c/c850.htm</a>.</div>
<hr><hr>
<script>
  const ctx61 = canvas61.getContext("2d");
  canvas61.width = canvas61.height = 1000;
  let canvas61Running = false;
  
  ctx61.globalAlpha = 0.2;
  
  let CurlWalker = {
    x: canvas61.width / 2,
    y: canvas61.height / 2,
    iterationsPerFrame: 5000,
    theta: 0,
    phi: 0,
    s: Math.SQRT2
  };
  CurlWalker.walk = function() {
    for (let j = 0; j < this.iterationsPerFrame; j++) {
      this.theta = (this.theta + (this.s * Math.PI * 2)) % (Math.PI * 2);
      this.phi = (this.phi + this.theta) % (Math.PI * 2);
      
      this.x += Math.cos(this.phi);
      this.y += Math.sin(this.phi);
      
      this.x = (this.x + canvas61.width) % canvas61.width;
      this.y = (this.y + canvas61.height) % canvas61.height;
      
      ctx61.fillRect(this.x, this.y, 1, 1);
    }
  };
  CurlWalker.resetPos = function() {
    ctx61.clearRect(0, 0, canvas61.width, canvas61.height);
    this.theta = this.phi = 0;
    this.x = canvas61.width / 2;
    this.y = canvas61.height / 2;
    this.walk();
  };
  
  function frame61() {
    CurlWalker.walk();
    
    if (canvas61Running) requestAnimationFrame(frame61);
  }
  frame61();
  
  function startCanvas61() {
    if (canvas61Running) canvas61Running = false;
    else {
      canvas61Running = true;
      frame61();
    }
  }
</script>
<canvas id = "canvas60" style = "background-color: black"></canvas>
<button onclick = "startCanvas60()">Start/Stop</button>
<div class = "desc"><b><i>(9/4/2021)</i></b> Bezier Curve visualizer, using plotting points from different t-values. I want to further use this to its full potential, I imagine some kind of cool wave design with dots racing along it. Right now it's set to just create random paths but in theory I want them to be spaced regularly to create cool designs.<br><b><i>(9/5/2021)</i></b> Made the curves more regularly spaced around a circle and having the end points follow the mouse.</div>
<hr><hr>
<script>
  const ctx60 = canvas60.getContext("2d");
  canvas60.width = canvas60.height = 500;
  let canvas60Running = false;
  let canvas60Rect = canvas60.getBoundingClientRect();
  let canvas60Ratio = canvas60.width / 300;
  
  function CurvePath(c1, c2, color) {
    this.c1 = c1;
    this.c2 = c2;
    
    //this.p1 = {x: 0, y: canvas60.height};
    //this.p2 = {x: canvas60.width, y: 0};
    this.p1 = {x: canvas60.width / 2, y: canvas60.width / 2};
    this.p2 = {x: canvas60.width / 2, y: canvas60.width / 2};
    
    let a = Math.random() * Math.PI * 2;
    let v = randBetween(1, 3);
    this.vec1 = {
      x: v * Math.cos(a),
      y: v * Math.sin(a)
    };
    a = Math.random() * Math.PI * 2;
    v = randBetween(1, 3);
    this.vec2 = {
      x: v * Math.cos(a),
      y: v * Math.sin(a)
    };
    
    this.color = color;
  }
  CurvePath.prototype.moveControls = function() {
    this.c1.x += this.vec1.x;
    this.c1.y += this.vec1.y;
    this.c2.x += this.vec2.x;
    this.c2.y += this.vec2.y;
    
    if (this.c1.x > canvas60.width) {
      this.c1.x = canvas60.width;
      this.vec1.x *= -1;
    }
    if (this.c1.x < 0) {
      this.c1.x = 0;
      this.vec1.x *= -1;
    }
    if (this.c1.y > canvas60.height) {
      this.c1.y = canvas60.height;
      this.vec1.y *= -1;
    }
    if (this.c1.y < 0) {
      this.c1.y = 0;
      this.vec1.y *= -1;
    }
    
    if (this.c2.x > canvas60.width) {
      this.c2.x = canvas60.width;
      this.vec2.x *= -1;
    }
    if (this.c2.x < 0) {
      this.c2.x = 0;
      this.vec2.x *= -1;
    }
    if (this.c2.y > canvas60.height) {
      this.c2.y = canvas60.height;
      this.vec2.y *= -1;
    }
    if (this.c2.y < 0) {
      this.c2.y = 0;
      this.vec2.y *= -1;
    }
  };
  CurvePath.prototype.drawPath = function() {
    ctx60.strokeStyle = this.color;//"rgba(255, 255, 255, 0.1)";
    ctx60.lineJoin = ctx60.lineCap = "round";
    ctx60.globalAlpha = 0.25;
    ctx60.beginPath();
    ctx60.moveTo(this.p1.x, this.p1.y);
    ctx60.bezierCurveTo(this.c1.x, this.c1.y, this.c2.x, this.c2.y, this.p2.x, this.p2.y);
    ctx60.stroke();
    ctx60.globalAlpha = 1;
  };
  CurvePath.prototype.plotPoint = function(t) {
    let A = lerp(this.p1.x, this.p1.y, this.c1.x, this.c1.y, t);
    let B = lerp(this.c1.x, this.c1.y, this.c2.x, this.c2.y, t);
    let C = lerp(this.c2.x, this.c2.y, this.p2.x, this.p2.y, t);
    let D = lerp(A.x, A.y, B.x, B.y, t);
    let E = lerp(B.x, B.y, C.x, C.y, t);
    let P = lerp(D.x, D.y, E.x, E.y, t);
    
    ctx60.fillStyle = this.color;
    ctx60.fillCircle(P.x, P.y, 2);
  };
  
  let curvePathArray = [];
  let startingCurvePaths = 100;
  for (let i = 0; i < startingCurvePaths; i++) {
    curvePathArray.push(new CurvePath(
      { // c1
        x: (canvas60.width / 2) + (canvas60.width * 0.5 * Math.cos((i / startingCurvePaths) * Math.PI * 2)),//(canvas60.width / 2) + (i * randBetween(0.5, 1.5) * randSign() * 25),
        y: (canvas60.height / 2) + (canvas60.height * 0.5 * Math.sin((i / startingCurvePaths) * Math.PI * 2))//(canvas60.height / 2) + (i * randBetween(0.5, 1.5) * 25)
      },
      { // c2
        x: (canvas60.width / 2) + (canvas60.width * 0.5 * Math.sin((i / startingCurvePaths) * Math.PI * 2)),//(canvas60.width / 2) - (i * randBetween(0.5, 1.5) * 25),
        y: (canvas60.height / 2) + (canvas60.height * 0.5 * Math.cos((i / startingCurvePaths) * Math.PI * 2))//(canvas60.height / 2) - (i * randBetween(0.5, 1.5) * randSign() * 25)
      },
      `hsl(${(i / startingCurvePaths) * 360}deg, 100%, 50%)` // color
    ));
  }
  
  function lerp(x1, y1, x2, y2, t) {
    return {x: ((1 - t) * x1) + (t * x2), y: ((1 - t) * y1) + (t * y2)};
  }
  
  let t60 = 0;
  let p60 = 500;
  let showPaths60 = true;
  
  function frame60() {
    ctx60.globalAlpha = 1//0.05;
    ctx60.fillStyle = "black";
    ctx60.fillRect(0, 0, canvas60.width, canvas60.height);
    ctx60.globalAlpha = 1;
    
    let smoothT = (Math.sin((t60 * Math.PI * 2) - (Math.PI / 2)) + 1) / 2;
    
    for (let i = 0; i < curvePathArray.length; i++) {
      //curvePathArray[i].moveControls();
      if (showPaths60) curvePathArray[i].drawPath();
      curvePathArray[i].plotPoint(smoothT);
      curvePathArray[i].plotPoint(1 - smoothT);
    }
    
    t60 += 1 / p60;
    if (t60 > 1) t60 = 0;
    
    if (canvas60Running) requestAnimationFrame(frame60);
  }
  frame60();
  
  function startCanvas60() {
    if (canvas60Running) canvas60Running = false;
    else {
      canvas60Running = true;
      frame60();
    }
  }
  
  canvas60.addEventListener("mousemove", e => {
    if (!canvas60Running) return;
    canvas60Rect = canvas60.getBoundingClientRect();
    for (let i = 0; i < curvePathArray.length; i++) {
      let eX = (e.clientX - canvas60Rect.left) * canvas60Ratio;
      let eY = (e.clientY - canvas60Rect.top) * canvas60Ratio;
      curvePathArray[i].p1.x = eX;
      curvePathArray[i].p1.y = eY;
      curvePathArray[i].p2.x = eY;
      curvePathArray[i].p2.y = eX;
    }
  });
</script>
<canvas id = "canvas59"></canvas>
<button onclick = "startCanvas59()">Start/Stop</button>
<div class = "desc"><b><i>(9/2/2021)</i></b> I tried to make a music generator by generating sounds in JavaScript that play when each ball bounces, but it's not very cross-browser compatible and it sounds awful.</div>
<hr><hr>
<script>
  const ctx59 = canvas59.getContext("2d");
  canvas59.width = canvas59.height = 300;
  let canvas59Running = false;
  let canvas59Rect = canvas59.getBoundingClientRect();
  
  function Sphere59(x, y) {
    this.x = x;
    this.y = y;
    this.vy = 0;
    this.radius = randBetween(10, 20);
    this.color = `hsla(${Math.random() * 360}deg, 100%, 50%, 0.25)`;
    this.gravity = 0.5//randBetween(0.05, 0.25);
    this.soundLength = Math.floor(randBetween(100, 200));
    
    this.stx = new AudioContext();
    this.osc = this.stx.createOscillator();
    let r = Math.floor(Math.random() * 4);
    if (r === 0) this.osc.type = "sine";
    if (r === 0) this.osc.type = "square";
    if (r === 0) this.osc.type = "triangle";
    if (r === 0) this.osc.type = "sawtooth";
    this.osc.frequency.value = randBetween(300, 1000);
    this.osc.start();
  }
  Sphere59.prototype.render = function() {
    this.y += this.vy;
    
    if (this.y + this.radius > canvas59.height) { // Bounce off the bottom
      let overrun = this.y + this.radius - canvas59.height;
      this.y = canvas59.height - this.radius;
      this.vy -= (overrun / this.vy) * this.gravity;
      this.vy *= -1;
      this.osc.connect(this.stx.destination);
      setTimeout(() => this.osc.disconnect(this.stx.destination), this.soundLength);
    }
    else this.vy += this.gravity; // Else fall downwards
    
    ctx59.fillStyle = this.color;
    ctx59.fillCircle(this.x, this.y, this.radius);
    ctx59.strokeStyle = "black";
    ctx59.lineWidth = 2;
    ctx59.strokeCircle(this.x, this.y, this.radius);
  };
  let sphere59Array = [];
  
  function frame59() {
    ctx59.clearRect(0, 0, canvas59.width, canvas59.height);
    
    for (let i = 0; i < sphere59Array.length; i++) sphere59Array[i].render();
    
    if (canvas59Running) requestAnimationFrame(frame59);
  }
  frame59();
  
  function startCanvas59() {
    if (canvas59Running) canvas59Running = false;
    else {
      canvas59Running = true;
      frame59();
    }
  }
  
  canvas59.addEventListener("mousedown", e => {
    e.preventDefault();
    canvas59Rect = canvas59.getBoundingClientRect();
    sphere59Array.push(new Sphere59(e.clientX - canvas59Rect.left, e.clientY - canvas59Rect.top));
  });
</script>
<canvas id = "canvas58"></canvas>
<button onclick = "drawWoodPlanks()">Go</button>
<div class = "desc"><b><i>(9/2/2021)</i></b> Just a simple little wooden plank floor generator.</div>
<hr><hr>
<script>
  const ctx58 = canvas58.getContext("2d");
  canvas58.width = canvas58.height = 1000;
  
  let widthMin58 = 30;
  let widthMax58 = 60;
  let heightMin58 = 100;
  let heightMax58 = 200;
  
  let hue58 = 35;
  
  function drawWoodPlanks() {
    ctx58.clearRect(0, 0, canvas58.width, canvas58.height);
    let x = 0;
    let w = 0;
    while (x < canvas58.width) {
      w = randBetween(widthMin58, widthMax58);
      let y = 0;
      let h = 0;
      while (y < canvas58.height) {
        h = randBetween(heightMin58, heightMax58);
        ctx58.fillStyle = `hsl(${hue58}deg, ${randBetween(80, 100)}%, ${randBetween(70, 85)}%)`;
        ctx58.fillRect(x - 1, y - 1, w + 2, h + 2);
        y += h;
      }
      x += w;
    }
  }
  drawWoodPlanks();
</script>
<canvas id = "canvas57"></canvas>
<button onclick = "startCanvas57()">Start/Stop</button>
<div class = "desc"><b><i>(9/2/2021)</i></b> An attempt to make a thing where people try to avoid one certain person, but currently it's pretty jumpy and doesn't look great.</div>
<hr><hr>
<script>
  const ctx57 = canvas57.getContext("2d");
  canvas57.width = canvas57.height = 500;
  let canvas57Running = false;
  
  let PushPerson = {
    x: canvas57.width / 2,
    y: canvas57.height / 2,
    radius: 100,
    size: 25,
    speed: 2,
    keyUp: false,
    keyRight: false,
    keyDown: false,
    keyLeft: false
  };
  PushPerson.render = function() {
    if (this.keyUp) this.y -= this.speed;
    if (this.keyRight) this.x += this.speed;
    if (this.keyDown) this.y += this.speed;
    if (this.keyLeft) this.x -= this.speed;
    ctx57.fillStyle = "rgba(0, 255, 0, 0.5)";
    ctx57.fillCircle(this.x, this.y, this.size);
  };
  
  let personSprite = new Image();
  personSprite.src = "https://www.freeiconspng.com/uploads/person-icon-blue-13.png";
  
  function Person() {
    this.x = Math.random() * canvas57.width;
    this.y = Math.random() * canvas57.height;
    this.radius = 40;
    this.size = 25;
    this.speed = 0.25;
  }
  Person.prototype.render = function() {
    for (let i = 0; i < personArray.length; i++) {
      if (i !== personArray.indexOf(this)) {
        let distX = this.x - personArray[i].x;
        let distY = this.y - personArray[i].y;
        let distSq = (distX * distX) + (distY * distY);
        if (distSq <= this.radius * this.radius) {
          this.x += distX * this.speed;
          this.y += distY * this.speed;
        }
      }
    }
    let distX = this.x - PushPerson.x;
    let distY = this.y - PushPerson.y;
    let distSq = (distX * distX) + (distY * distY);
    if (distSq <= PushPerson.radius * PushPerson.radius) {
      this.x += distX * this.speed;
      this.y += distY * this.speed;
    }
    
    this.x = (this.x + canvas57.width) % canvas57.width;
    this.y = (this.y + canvas57.height) % canvas57.height;
    
    ctx57.drawImageFromCenter(personSprite, this.x, this.y, this.size, this.size * 2);
  }
  let personArray = [];
  for (let i = 0; i < 100; i++) personArray.push(new Person());
  
  function frame57() {
    ctx57.clearRect(0, 0, canvas57.width, canvas57.height);
    
    for (let i = 0; i < personArray.length; i++) personArray[i].render();
    
    PushPerson.render();
    
    if (canvas57Running) requestAnimationFrame(frame57);
  }
  frame57();
  
  function startCanvas57() {
    if (canvas57Running) canvas57Running = false;
    else {
      canvas57Running = true;
      frame57();
    }
  }
  
  function keyDownHandler57(e) {
    if (!canvas57Running) return;
    e.preventDefault();
    if (e.code === "ArrowUp") PushPerson.keyUp = true;
    if (e.code === "ArrowRight") PushPerson.keyRight = true;
    if (e.code === "ArrowDown") PushPerson.keyDown = true;
    if (e.code === "ArrowLeft") PushPerson.keyLeft = true;
  }
  function keyUpHandler57(e) {
    if (!canvas57Running) return;
    if (e.code === "ArrowUp") PushPerson.keyUp = false;
    if (e.code === "ArrowRight") PushPerson.keyRight = false;
    if (e.code === "ArrowDown") PushPerson.keyDown = false;
    if (e.code === "ArrowLeft") PushPerson.keyLeft = false;
  }
  addEventListener("keydown", keyDownHandler57);
  addEventListener("keyup", keyUpHandler57);
</script>
<canvas id = "canvas56"></canvas>
<button onclick = "startCanvas56()">Start/Stop</button>
<button onclick = "reset56()">Reset</button>
<div class = "desc"><b><i>(8/31/2021)</i></b> An attempt to make a simple sand particle simulation to build a sand pile, which doesn't work at all.<br><b><i>(9/24/2021)</i></b> Completely rewrote the code, so that it works like the snowfall simulation (except without the averaging or Tetris row removing). I'm still not completely satisfied with it, and sand particles will be inside other ones a lot, and it doesn't always look like a sand pile, but atleast it works now. I have it so that each sand particle has a set max age that increases each frame it's touching a sand pile, and when it reaches its max age, it gets stuck.</div>
<hr><hr>
<script>
  const ctx56 = canvas56.getContext("2d");
  canvas56.width = canvas56.height = 1000;
  let canvas56Running = false;
  
  let gridSize56 = 200;
  let tileSize56 = canvas56.width / gridSize56;
  
  let slip56 = 25;
  
  let rows56 = [];
  for (let i = 0; i < gridSize56; i++) rows56.push(0);
  
  function SandParticle() {
    this.x = Math.round((gridSize56 / 2) + randBetween(-10, 10));//Math.floor(Math.random() * gridSize56);
    this.y = 0;
    this.stuck = false;
    this.touchingAge = 0;
    this.maxTouchingAge = Math.floor(Math.random() * slip56);
  }
  SandParticle.prototype.update = function() {
    this.y++;
    if (Math.floor(this.y) >= gridSize56 - rows56[this.x]) {
      this.touchingAge++;
      if (this.touchingAge >= this.maxTouchingAge) {
        rows56[this.x]++;
        this.stuck = true;
        return;
      }
      else {
        let nextX = (this.x + randSign() + gridSize56) % gridSize56;
        if (Math.floor(this.y) <= gridSize56 - rows56[nextX]) {
          this.x = nextX;
        }
      }
    }
    
    /*if (Math.floor(this.y) > gridSize56 - rows56[this.x]) {
      rows56[this.x]++;
      this.stuck = true;
      return;
    }*/
  };
  SandParticle.prototype.draw = function() {
    ctx56.fillRect(Math.floor(this.x) * tileSize56, Math.min(Math.floor(this.y), gridSize56 - rows56[this.x] - 1) * tileSize56, tileSize56, tileSize56);
  };
  let sandParticleArray = [];
  sandParticleArray.push(new SandParticle());
  
  function frame56() {
    ctx56.clearRect(0, 0, canvas56.width, canvas56.height);
    
    for (let j = 0; j < 3; j++) {
      sandParticleArray.push(new SandParticle());
      
      for (let i = 0; i < sandParticleArray.length; i++) {
        sandParticleArray[i].update();
        if (sandParticleArray[i].stuck) {
          sandParticleArray.splice(i, 1);
          i--;
        }
      }
    }
    
    for (let i = 0; i < sandParticleArray.length; i++) sandParticleArray[i].draw();
    
    for (let i = 0; i < rows56.length; i++) {
      let height = gridSize56 - rows56[i];
      ctx56.fillRect(i * tileSize56, height * tileSize56, tileSize56, rows56[i] * tileSize56);
    }
    
    if (canvas56Running) requestAnimationFrame(frame56);
  }
  frame56();
  
  function startCanvas56() {
    if (canvas56Running) canvas56Running = false;
    else {
      canvas56Running = true;
      frame56();
    }
  }
  
  function reset56() {
    tileSize56 = canvas56.width / gridSize56;
    sandParticleArray = [];
    rows56 = [];
    for (let i = 0; i < gridSize56; i++) rows56.push(0);
    if (!canvas56Running) frame56();
  }
</script>
<canvas id = "canvas55"></canvas>
<button onclick = "startCanvas55()">Start/Stop</button>
<button onclick = "reset55()">Reset</button>
<div class = "desc"><b><i>(8/28/2021)</i></b> Messing around with smearing effects made by drawing the canvas on top of itself with less alpha.</div>
<hr><hr>
<script>
  const ctx55 = canvas55.getContext("2d");
  canvas55.width = canvas55.height = 300;
  let canvas55Running = false;
  
  let t55 = 0;
  let saturation55 = 100;
  let lightness55 = 80;
  
  function frame55() {
    for (let i = 0; i < 100; i++) {
      ctx55.fillStyle = `hsl(${Math.random() * 360}deg, ${saturation55}%, ${lightness55}%)`;
      let y = Math.random() * canvas55.height;
      ctx55.fillRect((canvas55.width / 2) + randBetween(-y / 4, y / 4), y, 1, 1);
      
      ctx55.globalAlpha = 0.01;
      ctx55.drawImage(canvas55, (t55 - 0.5) * 2 * randBetween(0.5, 1), (t55 - 0.5) * 2 * randBetween(0.5, 1));
      ctx55.globalAlpha = 1;
      
      t55 += 0.01;
      if (t55 > 1) t55 = 0;
    }
    
    if (canvas55Running) requestAnimationFrame(frame55);
  }
  frame55();
  
  function reset55() {
    ctx55.clearRect(0, 0, canvas55.width, canvas55.height);
    t55 = 0;
  }
  
  function startCanvas55() {
    if (canvas55Running) canvas55Running = false;
    else {
      canvas55Running = true;
      frame55();
    }
  }
</script>
<canvas id = "canvas54" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas54()">Start/Stop</button>
<div class = "desc"><b><i>(8/27/2021)</i></b> I want to make this a simple car simulator, where you drive the car around and it leaves tire tracks that slowly disappear, and it drives and turns like a real car.</div>
<hr><hr>
<script>
  const ctx54 = canvas54.getContext("2d");
  canvas54.width = canvas54.height = 2000;
  let canvas54Running = false;
  
  let Car = {};
  Car.x = canvas54.width / 2;
  Car.y = canvas54.height / 2;
  Car.angle = 0;
  Car.velocity = 0;
  Car.sprite = new Image();
  Car.sprite.src = "images/car.png"; // ~1x2
  Car.width = 200;
  Car.height = 100;
  Car.acceleration = 0.2;
  Car.maxVelocity = 20;
  Car.brakePower = 0.9;
  Car.keysDown = {
    upArrow: false,
    downArrow: false,
    leftArrow: false,
    rightArrow: false
  };
  Car.render = function() {
    if (this.keysDown.upArrow) this.velocity += this.acceleration;
    if (this.keysDown.downArrow) this.velocity -= this.acceleration;
    if (this.keysDown.rightArrow) this.angle++;
    if (this.keysDown.leftArrow) this.angle--;
    if ((this.velocity < 0 && this.velocity > 0.01) || (this.velocity > 0 && this.velocity < 0.001)) this.velocity = 0;
    this.angle = (this.angle + 360) % 360;
    
    if (!this.keysDown.upArrow && !this.keysDown.downArrow) this.velocity *= 0.95;
    
    if (this.velocity > 0 && this.velocity > this.maxVelocity) this.velocity = this.maxVelocity;
    if (this.velocity < 0 && this.velocity < -this.maxVelocity) this.velocity = -this.maxVelocity;
    
    this.x += this.velocity * Math.cos(toRad(this.angle));
    this.y += this.velocity * Math.sin(toRad(this.angle));
    
    if (this.x > canvas54.width + this.width) this.x = -this.width;
    else if (this.x < -this.width) this.x = canvas54.width + this.width;
    if (this.y > canvas54.height + this.height) this.y = -this.height;
    else if (this.y < -this.height) this.y = canvas54.height + this.height;
    
    ctx54.drawRotatedImageFromCenter(this.sprite, this.x, this.y, this.width, this.height, this.angle);
  };
  
  function frame54() {
    ctx54.clearRect(0, 0, canvas54.width, canvas54.height);
    
    Car.render();
    
    if (canvas54Running) requestAnimationFrame(frame54);
  }
  frame54();
  
  function startCanvas54() {
    if (canvas54Running) canvas54Running = false;
    else {
      canvas54Running = true;
      frame54();
    }
  }
  
  function keyDownHandler54(e) {
    if (!canvas54Running) return;
    e.preventDefault();
    if (e.code == "ArrowUp") Car.keysDown.upArrow = true;
    if (e.code == "ArrowDown") Car.keysDown.downArrow = true;
    if (e.code == "ArrowLeft") Car.keysDown.leftArrow = true;
    if (e.code == "ArrowRight") Car.keysDown.rightArrow = true;
  }
  function keyUpHandler54(e) {
    if (!canvas54Running) return;
    if (e.code == "ArrowUp") Car.keysDown.upArrow = false;
    if (e.code == "ArrowDown") Car.keysDown.downArrow = false;
    if (e.code == "ArrowLeft") Car.keysDown.leftArrow = false;
    if (e.code == "ArrowRight") Car.keysDown.rightArrow = false;
  }
  addEventListener("keydown", keyDownHandler54);
  addEventListener("keyup", keyUpHandler54);
</script>
<canvas id = "canvas53"></canvas>
<button onclick = "startCanvas53()">Start/Stop</button>
<div class = "desc"><b><i>(8/26/2021)</i></b> An attempt to simulate the Belousov-Zhabotinsky Reaction, using <a href = "https://scipython.com/blog/simulating-the-belousov-zhabotinsky-reaction" target = "_blank">this</a> as a reference. I couldn't get it working at all.</div>
<hr><hr>
<script>
  const ctx53 = canvas53.getContext("2d");
  canvas53.width = canvas53.height = 100;
  let canvas53Running = false;
  
  let Constants53 = {
    alpha: 1,
    beta: 1,
    gamma: 1
  };
  
  let pxArray53 = [];
  let nextPxArray53 = new Array(canvas53.width).fill(0).map(() => new Array(canvas53.height).fill(0));
  for (let x = 0; x < canvas53.width; x++) {
    let row = [];
    for (let y = 0; y < canvas53.height; y++) {
      row.push(Math.random());//({a: Math.random(), b: Math.random(), c: Math.random()});
    }
    pxArray53.push(row);
  }
  
  function frame53() {
    ctx53.clearRect(0, 0, canvas53.width, canvas53.height);
    
    nextPxArray53 = new Array(canvas53.width).fill(0).map(() => new Array(canvas53.height).fill(0));
    
    for (let x = 0; x < canvas53.width; x++) {
      for (let y = 0; y < canvas53.height; y++) {
        // Average neighbors
        let total = 0;
        total += pxArray53[x][y] * 5; // Middle
        total += pxArray53[x][((y - 1) + canvas53.height) % canvas53.height] / 2; // Top
        total += pxArray53[(x + 1) % canvas53.height][((y - 1) + canvas53.height) % canvas53.height] / 2; // Top right
        total += pxArray53[(x + 1) % canvas53.height][y] / 2; // Right
        total += pxArray53[(x + 1) % canvas53.height][(y + 1) % canvas53.height] / 2; // Bottom right
        total += pxArray53[x][(y + 1) % canvas53.height] / 2; // Bottom
        total += pxArray53[((x - 1) + canvas53.width) % canvas53.width][(y + 1) % canvas53.height] / 2; // Bottom left
        total += pxArray53[((x - 1) + canvas53.width) % canvas53.width][y] / 2; // Left
        total += pxArray53[((x - 1) + canvas53.width) % canvas53.width][((y - 1) + canvas53.width) % canvas53.height] / 2; // Top left
        nextPxArray53[x][y] = (total / 9)// * randBetween(0.75, 1.25);
        
        // Draw pixel
        ctx53.fillStyle = `hsl(0deg, 0%, ${nextPxArray53[x][y] * 100}%)`;
        ctx53.fillRect(x, y, 1, 1);
      }
    }
    pxArray53 = nextPxArray53;
    
    if (canvas53Running) requestAnimationFrame(frame53);
  }
  //frame53();
  
  function startCanvas53() {
    if (canvas53Running) canvas53Running = false;
    else {
      canvas53Running = true;
      frame53();
    }
  }
</script>
<canvas id = "canvas52" style = "background-color: black"></canvas>
<button onclick = "startCanvas52()">Start/Stop</button>
<div class = "desc"><b><i>(8/25/2021)</i></b> Another attempt to replicate the Primordial Particle System from <a href = "https://softologyblog.wordpress.com/2019/05/05/primordial-particle-systems" target = "_blank">Softology</a>, which I couldn't get working yet again.</div>
<hr><hr>
<script>
  const ctx52 = canvas52.getContext("2d");
  canvas52.width = canvas52.height = 300;
  let canvas52Running = false;
  
  let particle52Radius = 55;
  let particle52Alpha = 10//120;
  let particle52Beta = -6;
  let particle52Velocity = 5;
  
  function Particle52() {
    this.x = Math.random() * canvas52.width;
    this.y = Math.random() * canvas52.height;
    this.angle = Math.random() * 360;
    this.color = `hsl(${Math.random() * 360}deg, 100%, 50%)`;
  }
  Particle52.prototype.render = function() {
    this.x += particle52Velocity * Math.cos(toRad(this.angle));
    this.y += particle52Velocity * Math.sin(toRad(this.angle));
    this.angle += particle52Alpha;
    
    let leftCount = 0;
    let rightCount = 0;
    
    for (let i = 0; i < particle52Array.length; i++) {
      if (i != particle52Array.indexOf(this)) {
        let distX = this.x - particle52Array[i].x;
        let distY = this.y - particle52Array[i].y;
        let distSq = (distX * distX) + (distY * distY);
        if (distSq <= particle52Radius * particle52Radius) {
          let angleTo = toDeg(Math.atan2(distY, distX));
          let angleDiff = angleTo - this.angle;
          if (angleDiff < 180 && angleDiff > 0) rightCount++;
          else leftCount++;
        }
      }
    }
    //this.angle += particle52Beta * Math.sign(rightCount - leftCount);
    if (rightCount > leftCount) this.angle += particle52Beta * (rightCount - leftCount);
    else if (leftCount > rightCount) this.angle -= particle52Beta * (leftCount - rightCount);
    
    ctx52.fillStyle = this.color;
    ctx52.fillCircle(this.x, this.y, 3);
  };
  let particle52Array = [];
  for (let i = 0; i < 150; i++) particle52Array.push(new Particle52());
  
  function frame52() {
    ctx52.clearRect(0, 0, canvas52.width, canvas52.height);
    
    for (let i = 0; i < particle52Array.length; i++) particle52Array[i].render();
    
    if (canvas52Running) requestAnimationFrame(frame52);
  }
  frame52();
  
  function startCanvas52() {
    if (canvas52Running) canvas52Running = false;
    else {
      canvas52Running = true;
      frame52();
    }
  }
</script>
<canvas id = "canvas51" style = "width: 400px; height: 400px"></canvas>
<button onclick = "drawRandomMaze()">Regenerate</button>
<div><b><u>Maze Size:</u></b> <span id = "mazeGridSizeTxt">25x25</span></div>
<input type = "range" min = "5" max = "100" step = "5" value = "25" id = "mazeGridSizeRange" oninput = "updateSettings51()">
<div><b><u>Direction Bias:</u></b> <span id = "mazeDirectionBiasTxt">None</span></div>
<input type = "range" min = "0" max = "2" step = "1" value = "0" id = "mazeDirectionBiasRange" oninput = "updateSettings51()">
<div><b><u>Bias Strength:</u></b> <span id = "mazeBiasStrengthTxt">0</span>x</div>
<input type = "range" min = "0" max = "50" step = "1" value = "0" id = "mazeBiasStrengthRange" oninput = "updateSettings51()">
<div class = "desc"><b><i>(8/24/2021)</i></b> Random maze generator, made by moving along a grid and at each square drawing a line at either the top, right, bottom, or left.<br><b><i>(8/25/2021)</i></b> Added direction bias and bias strength variables, which affect the chance of a wall being either to the top / bottom or right / left.</div>
<hr><hr>
<script>
  const ctx51 = canvas51.getContext("2d");
  canvas51.width = canvas51.height = 1000;
  
  ctx51.lineWidth = 4;
  ctx51.lineCap = ctx51.lineJoin = "round";
  
  let mazeGridSize = 25;
  let mazeTileSize = canvas51.width / mazeGridSize;
  let mazeDirectionBias = 0; // 0: None | 1: Top / Bottom | 2: Right / Left
  let mazeBiasStrength = 0;
  
  function drawRandomMaze() {
    ctx51.clearRect(0, 0, canvas51.width, canvas51.height);
    mazeTileSize = canvas51.width / mazeGridSize;
    ctx51.lineWidth = 8;
    ctx51.strokeRect(0, 0, canvas51.width, canvas51.height);
    ctx51.lineWidth = 4;
    for (let x = 0; x < mazeGridSize; x++) {
      for (let y = 0; y < mazeGridSize; y++) {
        let side = Math.floor(Math.random() * 4);
        if (mazeDirectionBias != 0) side += Math.floor(Math.random() * mazeBiasStrength);//6);//8);
        let scaledX = x * mazeTileSize;
        let scaledY = y * mazeTileSize;
        if (side == 0 || (mazeDirectionBias == 1 && side > 3)) { // Top
          ctx51.lineBetween(scaledX, scaledY, scaledX + mazeTileSize, scaledY);
          ctx51.stroke();
        }
        else if (side == 1 || (mazeDirectionBias == 2 && side > 3)) { // Right
          ctx51.lineBetween(scaledX + mazeTileSize, scaledY, scaledX + mazeTileSize, scaledY + mazeTileSize);
          ctx51.stroke();
        }
        else if (side == 2 || (mazeDirectionBias == 1 && side > 3)) { // Bottom
          ctx51.lineBetween(scaledX, scaledY + mazeTileSize, scaledX + mazeTileSize, scaledY + mazeTileSize);
          ctx51.stroke();
        }
        else if (side == 3 || (mazeDirectionBias == 2 && side > 3)) { // Left
          ctx51.lineBetween(scaledX, scaledY, scaledX, scaledY + mazeTileSize);
          ctx51.stroke();
        }
        /*else if (side == 4) { // Diagonal 1
          ctx51.lineBetween(scaledX, scaledY, scaledX + mazeTileSize, scaledY + mazeTileSize);
          ctx51.stroke();
        }
        else if (side == 5) { // Diagonal 2
          ctx51.lineBetween(scaledX + mazeTileSize, scaledY, scaledX, scaledY + mazeTileSize);
          ctx51.stroke();
        }
        else if (side == 6) { // Vertical middle
          ctx51.lineBetween(scaledX + (mazeTileSize / 2), scaledY, scaledX + (mazeTileSize / 2), scaledY + mazeTileSize);
          ctx51.stroke();
        }
        else if (side == 7) { // Horizontal middle
          ctx51.lineBetween(scaledX, scaledY + (mazeTileSize / 2), scaledX + mazeTileSize, scaledY + (mazeTileSize / 2));
          ctx51.stroke();
        }*/
      }
    }
  }
  CanvasRenderingContext2D.prototype.lineBetween = function(x1, y1, x2, y2) {
    this.beginPath();
    this.moveTo(x1, y1);
    this.lineTo(x2, y2);
  };
  drawRandomMaze();
  
  function updateSettings51() {
    mazeDirectionBias = Number(mazeDirectionBiasRange.value);
    if (mazeDirectionBias == 0) mazeDirectionBiasTxt.innerHTML = "None";
    else if (mazeDirectionBias == 1) mazeDirectionBiasTxt.innerHTML = "Top / Bottom";
    else mazeDirectionBiasTxt.innerHTML = "Right / Left";
    mazeBiasStrength = mazeBiasStrengthTxt.innerHTML = Number(mazeBiasStrengthRange.value);
    mazeGridSize = mazeGridSizeTxt.innerHTML = Number(mazeGridSizeRange.value);
    
    drawRandomMaze();
  }
</script>
<canvas id = "canvas50"></canvas>
<button onclick = "Walker50.walk()">Go</button>
<button onclick = "swapColor50()">Swap Color</button>
<button onclick = "reset50()">Reset</button>
<div><b><u>Steps:</u></b> <span id = "walker50IterationsTxt">0</span></div>
<div><b><u>Turn Angle:</u></b> <span id = "walker50TurnAngleTxt">30</span>&deg;</div>
<input type = "range" min = "0" max = "180" step = "1" value = "30" id = "walker50TurnAngleRange" oninput = "updateSettings50()">
<div><b><u>Velocity:</u></b> <span id = "walker50VelocityTxt">5</span>px</div>
<input type = "range" min = "1" max = "25" step = "1" value = "5" id = "walker50VelocityRange" oninput = "updateSettings50()">
<div><b><u>Turn Chance:</u></b> <span id = "walker50TurnChanceTxt">100</span>%</div>
<input type = "range" min = "5" max = "100" step = "5" value = "100" id = "walker50TurnChanceRange" oninput = "updateSettings50()">
<div><b><u>Smooth Turning:</u></b></div>
<input type = "checkbox" id = "walker50SmoothTurningCheckbox" oninput = "updateSettings50()">
<div><b><u>Random Turning:</u></b></div>
<input type = "checkbox" id = "walker50RandomTurningCheckbox" oninput = "updateSettings50()">
<div class = "desc"><b><i>(8/23/2021)</i></b> Random walker aligned to a circle instead of a grid, with random angle and set velocity, along with a slider for the chance of it turning each frame.<br><b><i>(8/24/2021)</i></b> Added more settings and sliders, for turn angle, velocity, smooth turning, and random turning. This way you can choose between turning a random direction each step, or turning a certain angle each step randomly, either exactly or smoothly (random turn between 0&deg; and turn angle&deg;).</div>
<hr><hr>
<script>
  const ctx50 = canvas50.getContext("2d");
  canvas50.width = canvas50.height = 500;
  let canvas50Running = false;
  
  let Walker50 = {};
  Walker50.x = canvas50.width / 2;
  Walker50.y = canvas50.height / 2;
  Walker50.lastX = Walker50.x;
  Walker50.lastY = Walker50.y;
  Walker50.angle = Math.random() * Math.PI * 2;
  Walker50.velocity = 5;
  Walker50.turnChance = 1;
  Walker50.turnAngle = 30;
  Walker50.smoothTurning = false;
  Walker50.randomTurning = false;
  Walker50.stepsPerFrame = 1000;
  Walker50.color = "black";
  Walker50.iterations = 0;
  Walker50.walk = function() {
    for (let i = 0; i < this.stepsPerFrame; i++) {
      this.iterations++;
      if (Math.random() <= this.turnChance) {
        if (this.smoothTurning) this.angle += Math.random() * toRad(this.turnAngle) * randSign();
        else this.angle += toRad(this.turnAngle) * randSign();
        if (this.randomTurning) this.angle = Math.random() * Math.PI * 2;
      }
      this.angle = (this.angle + (Math.PI * 2)) % (Math.PI * 2);
      this.x += this.velocity * Math.cos(this.angle);
      this.y += this.velocity * Math.sin(this.angle);
      
      ctx50.strokeStyle = this.color;
      ctx50.beginPath();
      ctx50.moveTo(this.lastX, this.lastY);
      ctx50.lineTo(this.x, this.y);
      ctx50.stroke();
      
      this.x = (this.x + canvas50.width) % canvas50.width;
      this.y = (this.y + canvas50.height) % canvas50.height;
      
      this.lastX = this.x;
      this.lastY = this.y;
    }
    walker50IterationsTxt.innerHTML = this.iterations.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  };
  Walker50.walk();
  
  function updateSettings50() {
    Walker50.turnAngle = walker50TurnAngleTxt.innerHTML = Number(walker50TurnAngleRange.value);
    Walker50.velocity = walker50VelocityTxt.innerHTML = Number(walker50VelocityRange.value);
    Walker50.turnChance = Number(walker50TurnChanceRange.value) / 100;
    Walker50.smoothTurning = walker50SmoothTurningCheckbox.checked;
    Walker50.randomTurning = walker50RandomTurningCheckbox.checked;
    walker50TurnChanceTxt.innerHTML = walker50TurnChanceRange.value;
    
    reset50();
  }
  
  function swapColor50() {
    if (Walker50.color == "black") Walker50.color = "white";
    else Walker50.color = "black";
    
    Walker50.walk();
  }
  
  function reset50() {
    ctx50.clearRect(0, 0, canvas50.width, canvas50.height);
    Walker50.x = canvas50.width / 2;
    Walker50.y = canvas50.height / 2;
    Walker50.lastX = Walker50.x;
    Walker50.lastY = Walker50.y;
    Walker50.angle = Math.random() * Math.PI * 2;
    Walker50.color = "black";
    Walker50.iterations = 0;
    
    Walker50.walk();
  }
  
</script>
<canvas id = "canvas49" style = "background-color: #000033; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas49()">Start/Stop</button>
<div class = "desc"><b><i>(8/21/2021)</i></b> Some sort of rain simulation / art thingy, I'm not really sure.</div>
<hr><hr>
<script>
  const ctx49 = canvas49.getContext("2d");
  canvas49.width = canvas49.height = 1000;
  let canvas49Running = false;
  
  function Raindrop(x, y) {
    this.baseX = x;
    this.x = this.baseX + randBetween(-5, 5);
    this.y = this.lastY = y - randBetween(100, 50);
    this.size = randBetween(3, 6);
  }
  Raindrop.prototype.render = function() {
    this.y += 10;
    this.x += (((windInterval / 100) * 10) - 5) * randBetween(0.5, 1);//randBetween(0.5, 2);
    if (this.y >= canvas49.height) {
      this.y = this.lastY = randBetween(-50, -25);
      this.x = this.baseX + randBetween(-5, 5);
    }
    this.x = (this.x + canvas49.width) % canvas49.width;
    ctx49.strokeStyle = "rgba(255, 255, 255, 0.5)";
    ctx49.lineWidth = this.size;
    ctx49.lineCap = ctx49.lineJoin = "round";
    
    ctx49.beginPath();
    ctx49.moveTo(this.x, this.lastY);
    ctx49.lineTo(this.x, this.y);
    ctx49.stroke();
    
    ctx49.beginPath();
    ctx49.moveTo(this.x - canvas49.width, this.lastY);
    ctx49.lineTo(this.x - canvas49.width, this.y);
    ctx49.stroke();
    
    ctx49.beginPath();
    ctx49.moveTo(this.x + canvas49.width, this.lastY);
    ctx49.lineTo(this.x + canvas49.width, this.y);
    ctx49.stroke();
    
    this.lastY = this.y;
  };
  let raindropArray = [];
  for (let i = 0; i <= 20; i++) {
    for (let j = 0; j <= 30; j++) {
      raindropArray.push(new Raindrop((j / 30) * canvas49.width, -i * 50));
    }
  }
  
  let windInterval = 50;
  let vWindInterval = 0.1;
  
  function frame49() {
    ctx49.fillStyle = "#000033";
    ctx49.globalAlpha = 0.3;
    ctx49.fillRect(0, 0, canvas49.width, canvas49.height);
    ctx49.globalAlpha = 1;
    
    windInterval += vWindInterval;
    if (windInterval > 100) {
      windInterval = 100;
      vWindInterval = -randBetween(0.05, 0.25);
      //vWindInterval *= -1;
    }
    if (windInterval < 0) {
      windInterval = 0;
      vWindInterval = randBetween(0.05, 0.25);
      //vWindInterval *= -1;
    }
    
    ctx49.fillStyle = "rgba(255, 255, 255, 0.25)";
    ctx49.shadowColor = "white";
    ctx49.shadowBlur = 10;
    ctx49.beginPath();
    ctx49.moveTo(200, 150);
    ctx49.ellipse(200, 150, 60, 50, 0, Math.PI / 2, Math.PI * 1.5);
    ctx49.ellipse(200, 150, 40, 50, 0, Math.PI * 1.5, Math.PI / 2, true);
    ctx49.fill();
    //ctx49.fillCircle(200, 150, 50);
    ctx49.shadowBlur = 0;
    
    for (let i = 0; i < raindropArray.length; i++) raindropArray[i].render();
    
    ctx49.fillStyle = "black";
    ctx49.moveTo(canvas49.width, canvas49.height - 50);
    ctx49.lineTo(canvas49.width, canvas49.height);
    ctx49.lineTo(0, canvas49.height);
    ctx49.lineTo(0, canvas49.height - 250);
    ctx49.quadraticCurveTo(canvas49.width / 2, canvas49.height - 50, canvas49.width, canvas49.height - 50);
    ctx49.fill();
    
    if (canvas49Running) requestAnimationFrame(frame49);
  }
  frame49();
  
  function startCanvas49() {
    if (canvas49Running) canvas49Running = false;
    else {
      canvas49Running = true;
      frame49();
    }
  }
</script>
<canvas id = "canvas48" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas48()">Start/Stop</button>
<div class = "desc"><b><i>(8/21/2021)</i></b> Rocket game, similar to <a href = "https://scratch.mit.edu/projects/344754598" target = "_blank">Guitar Rat</a>, but with rockets and eventually I want to add different modes, like Arcade and Infinite.</div>
<hr><hr>
<script>
  const ctx48 = canvas48.getContext("2d");
  canvas48.width = canvas48.height = 1000;
  let canvas48Running = false;
  
  let Rocket = {};
  Rocket.sprite = new Image();
  Rocket.sprite.src = "images/rocket.png"; // 9 x 5
  Rocket.width = 90;
  Rocket.height = 50;
  Rocket.x = canvas48.width / 2;
  Rocket.y = canvas48.height / 2;
  Rocket.angle = 0;
  Rocket.velocity = 0;
  Rocket.dead = false;
  Rocket.thrustOn = false;
  Rocket.turningLeft = false;
  Rocket.turningRight = false;
  Rocket.thrustPower = 1;
  Rocket.turnPower = 0.5;
  Rocket.turnSpeed = 0;
  Rocket.maxTurnSpeed = 5;
  Rocket.maxVelocity = 8;
  Rocket.score = 0;
  Rocket.lives = 3;
  Rocket.update = function() {
    if (this.dead) return;
    if (this.turningRight) this.turnSpeed += this.turnPower;
    if (this.turningLeft) this.turnSpeed -= this.turnPower;
    if (this.thrustOn) {
      this.velocity += this.thrustPower;
      for (let i = 0; i < 5; i++) particle48Array.push(new Particle48(
        this.x - (((this.width / 2) - 20) * Math.cos(toRad(this.angle))), // x
        this.y - ((this.height / 2) * Math.sin(toRad(this.angle))), // y
        this.angle + 180 + randBetween(-60, 60), // angle
        randBetween(0.2, 4), // velocity
        randBetween(10, 15), // size
        randBetween(20, 40) // max age
      ));
    }
    this.velocity *= 0.9;
    this.velocity = Math.min(this.maxVelocity, Math.abs(this.velocity)) * Math.sign(this.velocity);
    this.angle += this.turnSpeed;
    this.turnSpeed *= 0.85;
    this.turnSpeed = Math.min(this.maxTurnSpeed, Math.abs(this.turnSpeed)) * Math.sign(this.turnSpeed);
    this.x += this.velocity * Math.cos(toRad(this.angle));
    this.y += this.velocity * Math.sin(toRad(this.angle));
    
    this.x = this.x.clamp(50, canvas48.width - 50);
    this.y = this.y.clamp(50, canvas48.height - 50);
    
    if (rectsTouching(this.x, this.y, this.width, this.width, Portal.x, Portal.y, Portal.width, Portal.height)) {
      reset48();
      Rocket.score++;
    }
    
    /*if (this.x > canvas48.width + 50) this.x = -50;
    if (this.x < -50) this.x = canvas48.width + 50;
    if (this.y > canvas48.height + 50) this.y = -50;
    if (this.y < -50) this.y = canvas48.height + 50;*/
  };
  Rocket.draw = function() {
    if (this.dead) return;
    ctx48.globalAlpha = (this.lives + 2) / 5;
    ctx48.drawRotatedImageFromCenter(this.sprite, this.x, this.y, this.width, this.height, this.angle);
    ctx48.globalAlpha = 1;
  };
  Rocket.explode = function() {
    this.dead = true;
    for (let i = 0; i < 60; i++) {
      particle48Array.push(new Particle48(
        this.x, // x
        this.y, // y
        Math.random() * 360, // angle
        randBetween(1, 8), // velocity
        randBetween(15, 25), // size
        randBetween(40, 80) // max age
      ));
    }
  };
  
  let EvilRocket = {};
  EvilRocket.sprite = new Image();
  EvilRocket.sprite.src = "images/evil-rocket.png"; // 9 x 5
  EvilRocket.width = 72//90;
  EvilRocket.height = 40//50;
  EvilRocket.x = 0;
  EvilRocket.y = 0;
  EvilRocket.angle = Math.random() * 360;
  EvilRocket.velocity = 0;
  EvilRocket.dead = false;
  EvilRocket.thrustPower = 0.4;
  EvilRocket.turnPower = 3;
  EvilRocket.turnSpeed = 0;
  EvilRocket.maxTurnSpeed = 5;
  EvilRocket.maxVelocity = 8;
  EvilRocket.update = function() {
    if (this.dead || Rocket.dead) return;
    let targetAngle = toDeg(Math.atan2(this.y - Rocket.y, this.x - Rocket.x) - Math.PI);
    targetAngle = (targetAngle + 360) % 360;
    let netAngle = (this.angle - targetAngle + 360) % 360;
    let delta = Math.min(Math.abs(netAngle - 360), netAngle, this.turnPower);
    let sign = netAngle >= 180 ? 1 : -1;
    this.angle += sign * delta;
    this.angle = (this.angle + 360) % 360;
    this.velocity += this.thrustPower;
    for (let i = 0; i < 3; i++) particle48Array.push(new Particle48(
      this.x - (((this.width / 2) - 20) * Math.cos(toRad(this.angle))), // x
      this.y - ((this.height / 2) * Math.sin(toRad(this.angle))), // y
      this.angle + 180 + randBetween(-60, 60), // angle
      randBetween(0.1, 2), // velocity
      randBetween(3, 6), // size
      randBetween(15, 30) // max age
    ));
    this.velocity *= 0.9;
    this.velocity = Math.min(this.maxVelocity, Math.abs(this.velocity)) * Math.sign(this.velocity);
    this.angle += this.turnSpeed;
    this.turnSpeed *= 0.85;
    this.turnSpeed = Math.min(this.maxTurnSpeed, Math.abs(this.turnSpeed)) * Math.sign(this.turnSpeed);
    this.x += this.velocity * Math.cos(toRad(this.angle));
    this.y += this.velocity * Math.sin(toRad(this.angle));
    if (rectsTouching(this.x, this.y, this.width, this.width, Rocket.x, Rocket.y, Rocket.width, Rocket.width)) {
      if (Rocket.lives <= 0) Rocket.explode();
      else {
        Rocket.lives--;
        this.explode();
      }
    }
  };
  EvilRocket.draw = function() {
    if (this.dead) return;
    ctx48.drawRotatedImageFromCenter(this.sprite, this.x, this.y, this.width, this.height, this.angle);
  };
  EvilRocket.explode = function() {
    for (let i = 0; i < 30; i++) {
      particle48Array.push(new Particle48(
        this.x, // x
        this.y, // y
        Math.random() * 360, // angle
        randBetween(0.5, 4), // velocity
        randBetween(10, 15), // size
        randBetween(20, 40) // max age
      ));
    }
    this.resetPos();
  };
  EvilRocket.resetPos = function() {
    let side = Math.floor(Math.random() * 4);
    if (side == 0) {
      this.x = randBetween(-50, canvas48.width + 50);
      this.y = -50;
    }
    else if (side == 1) {
      this.x = canvas48.width + 50;
      this.y = randBetween(-50, canvas48.height + 50);
    }
    else if (this.side == 2) {
      this.x = randBetween(-50, canvas48.width + 50);
      this.y = canvas48.height + 50;
    }
    else {
      this.x = -50;
      this.y = randBetween(-50, canvas48.height + 50);
    }
  };
  EvilRocket.resetPos();
  
  function Particle48(x, y, angle, velocity, size, maxAge) {
    this.x = x;
    this.y = y;
    this.angle = toRad(angle);
    this.velocity = velocity;
    this.size = size;
    this.age = 0;
    this.maxAge = maxAge;
    this.color = `hsl(${randBetween(0, 60)}deg, 100%, 50%)`;
    this.dead = false;
  }
  Particle48.prototype.update = function() {
    if (this.dead) return;
    this.x += this.velocity * Math.cos(this.angle);
    this.y += this.velocity * Math.sin(this.angle);
    this.age++;
    if (this.age >= this.maxAge) this.dead = true;
  };
  Particle48.prototype.draw = function() {
    if (this.dead) return;
    ctx48.globalAlpha = 1 - (this.age / this.maxAge);
    ctx48.fillStyle = this.color;
    ctx48.fillRectFromCenter(this.x, this.y, this.size, this.size);
    ctx48.globalAlpha = 1;
  };
  let particle48Array = [];
  
  function Star48() {
    this.x = Math.random() * canvas48.width;
    this.y = Math.random() * canvas48.height;
    this.size = randBetween(2, 6);
    this.color = `hsl(${Math.random() * 360}deg, 100%, 80%)`;
  }
  Star48.prototype.draw = function() {
    ctx48.fillStyle = this.color;
    ctx48.fillRect(this.x, this.y, this.size, this.size);
  };
  let star48Array = [];
  let numStars48 = Math.round(randBetween(50, 100));
  for (let i = 0; i < numStars48; i++) star48Array.push(new Star48());
  
  let Portal = {};
  Portal.sprite = new Image();
  Portal.sprite.src = "images/pixel-portal.png"; // 35 x 35
  Portal.x = Math.random() * canvas48.width;
  Portal.y = Math.random() * canvas48.height;
  Portal.width = 150;
  Portal.height = 150;
  Portal.angle = 0;
  Portal.turnSpeed = 0.75;
  Portal.update = function() {
    this.angle += this.turnSpeed;
    this.angle = (this.angle + 360) % 360;
  };
  Portal.draw = function() {
    ctx48.drawRotatedImageFromCenter(this.sprite, this.x, this.y, this.width, this.height, this.angle);
  };
  Portal.resetPos = function() {
    let x = Math.random() * canvas48.width;
    let y = Math.random() * canvas48.height;
    while (pointInRect(x, y, Rocket.x - 150, Rocket.y - 150, 300, 300)) {
      x = Math.random() * canvas48.width;
      y = Math.random() * canvas48.height;
    }
    this.x = x;
    this.y = y;
  };
  
  function frame48() {
    ctx48.clearRect(0, 0, canvas48.width, canvas48.height);
    
    for (let i = 0; i < star48Array.length; i++) star48Array[i].draw();
    
    Portal.update();
    Portal.draw();
    
    Rocket.update();
    Rocket.draw();
    
    EvilRocket.update();
    EvilRocket.draw();
    
    for (let i = 0; i < particle48Array.length; i++) {
      particle48Array[i].update();
      particle48Array[i].draw();
      if (particle48Array[i].dead) {
        particle48Array.splice(i, 1);
        i--;
      }
    }
    
    ctx48.fillStyle = "white";
    ctx48.font = "bold 40px monospace";
    ctx48.fillText("Score: " + Rocket.score, 50, 90);
    ctx48.fillText("Lives: " + Rocket.lives, 50, 150);
    
    if (canvas48Running) requestAnimationFrame(frame48);
  }
  frame48();
  
  function reset48() {
    particle48Array = [];
    Rocket.x = Portal.x;
    Rocket.y = Portal.y
    Rocket.velocity = 0;
    EvilRocket.resetPos();
    EvilRocket.angle = Math.random() * 360;
    EvilRocket.velocity = 0;
    Portal.resetPos();
    
    star48Array = [];
    numStars48 = Math.round(randBetween(50, 100));
    for (let i = 0; i < numStars48; i++) star48Array.push(new Star48());
  }
  
  function keyDownHandler48(e) {
    if (!canvas48Running) return;
    e.preventDefault();
    if (e.code == "ArrowUp") Rocket.thrustOn = true;
    if (e.code == "ArrowLeft") Rocket.turningLeft = true;
    if (e.code == "ArrowRight") Rocket.turningRight = true;
  }
  function keyUpHandler48(e) {
    if (e.code == "ArrowUp") Rocket.thrustOn = false;
    if (e.code == "ArrowLeft") Rocket.turningLeft = false;
    if (e.code == "ArrowRight") Rocket.turningRight = false;
  }
  addEventListener("keydown", keyDownHandler48);
  addEventListener("keyup", keyUpHandler48);
  
  function rectsTouching(ax, ay, aw, ah, bx, by, bw, bh) {
    let minAx = ax - (aw / 2);
    let minAy = ay - (ah / 2);
    let maxAx = ax + (aw / 2);
    let maxAy = ay + (ah / 2);
    let minBx = bx - (bw / 2);
    let minBy = by - (bh / 2);
    let maxBx = bx + (bw / 2);
    let maxBy = by + (bh / 2);
    return maxAx >= minBx && minAx <= maxBx && minAy <= maxBy && maxAy >= minBy;
  }
  
  function pointInRect(x, y, ax, ay, aw, ah) {
    return x >= ax && x <= ax + aw && y <= ay + ah && y >= ay;
  }
  
  function startCanvas48() {
    if (canvas48Running) canvas48Running = false;
    else {
      canvas48Running = true;
      frame48();
    }
  }
</script>
<canvas id = "canvas47"></canvas>
<button onclick = "startCanvas47()">Start/Stop</button>
<div><b><u>Angle X:</u></b></div>
<input type = "range" min = "0" max = "360" step = "1" value = "0" id = "cameraAngleXRange" oninput = "updateSettings47()">
<div><b><u>Angle Y:</u></b></div>
<input type = "range" min = "0" max = "360" step = "1" value = "45" id = "cameraAngleYRange" oninput = "updateSettings47()">
<div class = "desc"><b><i>(8/21/2021)</i></b> An attempt to make a simple isometric 3D renderer.</div>
<hr><hr>
<script>
  const ctx47 = canvas47.getContext("2d");
  canvas47.width = canvas47.height = 300;
  let canvas47Running = false;
  
  let Camera = {};
  Camera.angleX = 0;
  Camera.angleY = 45;
  
  let Ground = {};
  Ground.x = canvas47.width / 2;
  Ground.y = canvas47.height / 2;
  Ground.width = 200;
  Ground.height = 200;
  Ground.fillColor = (new HSL(undefined, randBetween(50, 100), randBetween(50, 80))).print();
  Ground.outlineColor = (new HSL(undefined, randBetween(50, 100), randBetween(0, 30))).print();
  Ground.vertices = [];
  Ground.render = function() {
    let w = this.width / 2;
    let h = (this.height / 2) * Math.sin(toRad(Camera.angleY));
    this.vertices = [
      {x: this.x + (w * Math.cos(toRad(Camera.angleX))), y: this.y + (h * Math.sin(toRad(Camera.angleX)))},
      {x: this.x + (w * Math.cos(toRad(Camera.angleX) + (Math.PI / 2))), y: this.y + (h * Math.sin(toRad(Camera.angleX) + (Math.PI / 2)))},
      {x: this.x + (w * Math.cos(toRad(Camera.angleX) + Math.PI)), y: this.y + (h * Math.sin(toRad(Camera.angleX) + Math.PI))},
      {x: this.x + (w * Math.cos(toRad(Camera.angleX) + (Math.PI * 1.5))), y: this.y + (h * Math.sin(toRad(Camera.angleX) + (Math.PI * 1.5)))}
    ];
    ctx47.fillStyle = this.fillColor;
    ctx47.strokeStyle = this.outlineColor;
    ctx47.lineWidth = 3;
    ctx47.lineCap = ctx47.lineJoin = "round";
    ctx47.beginPath();
    ctx47.moveTo(this.vertices[0].x, this.vertices[0].y);
    ctx47.lineTo(this.vertices[1].x, this.vertices[1].y);
    ctx47.lineTo(this.vertices[2].x, this.vertices[2].y);
    ctx47.lineTo(this.vertices[3].x, this.vertices[3].y);
    ctx47.lineTo(this.vertices[0].x, this.vertices[0].y);
    ctx47.lineTo(this.vertices[1].x, this.vertices[1].y);
    ctx47.fill();
    if (Camera.angleY > 180) {
      ctx47.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx47.fill();
    }
    ctx47.stroke();
  };
  
  function frame47() {
    ctx47.clearRect(0, 0, canvas47.width, canvas47.height);
    
    Ground.render();
    
    if (canvas47Running) requestAnimationFrame(frame47);
  }
  frame47();
  
  function startCanvas47() {
    if (canvas47Running) canvas47Running = false;
    else {
      canvas47Running = true;
      frame47();
    }
  }
  
  function updateSettings47() {
    Camera.angleX = Number(cameraAngleXRange.value);
    Camera.angleY = Number(cameraAngleYRange.value);
    
    if (!canvas47Running) frame47();
  }
</script>
<canvas id = "canvas46"></canvas>
<div><b><u>Width:</u></b></div>
<input type = "range" min = "10" max = "200" step = "10" value = "100" id = "diamondWidthRange" oninput = "updateSettings46()">
<div><b><u>Height:</u></b></div>
<input type = "range" min = "10" max = "200" step = "10" value = "200" id = "diamondHeightRange" oninput = "updateSettings46()">
<div><b><u>Angle:</u></b></div>
<input type = "range" min = "0" max = "360" step = "1" value = "0" id = "diamondAngleRange" oninput = "updateSettings46()">
<div class = "desc"><b><i>(8/21/2021)</i></b> An attempt to make a simple diamond canvas function, which works fine except when you try to rotate it.<br><b><i>(8/22/2021)</i></b> Fixed a stupid mistake where I swapped width and height values, now it works perfectly fine.</div>
<hr><hr>
<script>
  const ctx46 = canvas46.getContext("2d");
  canvas46.width = canvas46.height = 300;
  
  let diamondX = canvas46.width / 2;
  let diamondY = canvas46.height / 2;
  let diamondWidth = 100;
  let diamondHeight = 200;
  let diamondAngle = 0;
  let diamondFillColor = (new HSL(undefined, randBetween(50, 100), randBetween(0, 30))).print();
  let diamondOutlineColor = (new HSL(undefined, randBetween(50, 100), randBetween(50, 80))).print();
  
  function drawDiamond() {
    ctx46.clearRect(0, 0, canvas46.width, canvas46.height);
    
    ctx46.lineWidth = 3;
    ctx46.lineCap = ctx46.lineJoin = "round";
    ctx46.strokeStyle = diamondFillColor;
    ctx46.fillStyle = diamondOutlineColor;
    
    ctx46.fillDiamond(diamondX, diamondY, diamondWidth, diamondHeight, diamondAngle);
    ctx46.strokeDiamond(diamondX, diamondY, diamondWidth, diamondHeight, diamondAngle);
  }
  
  function updateSettings46() {
    diamondWidth = Number(diamondWidthRange.value);
    diamondHeight = Number(diamondHeightRange.value);
    diamondAngle = toRad(Number(diamondAngleRange.value));
    
    drawDiamond();
  }
  
  CanvasRenderingContext2D.prototype.strokeDiamond = function(x, y, width, height, angle) {
    let w = width / 2;
    let h = height / 2;
    this.beginPath();
    this.moveTo(x + (w * Math.cos(angle)), y + (w * Math.sin(angle)));
    this.lineTo(x + (h * Math.cos(angle + (Math.PI / 2))), y + (h * Math.sin(angle + (Math.PI / 2))));
    this.lineTo(x + (w * Math.cos(angle + Math.PI)), y + (w * Math.sin(angle + Math.PI)));
    this.lineTo(x + (h * Math.cos(angle + (Math.PI * 1.5))), y + (h * Math.sin(angle + (Math.PI * 1.5))));
    this.lineTo(x + (w * Math.cos(angle)), y + (w * Math.sin(angle)));
    this.stroke();
  };
  CanvasRenderingContext2D.prototype.fillDiamond = function(x, y, width, height, angle) {
    let w = width / 2;
    let h = height / 2;
    this.beginPath();
    this.moveTo(x + (w * Math.cos(angle)), y + (w * Math.sin(angle)));
    this.lineTo(x + (h * Math.cos(angle + (Math.PI / 2))), y + (h * Math.sin(angle + (Math.PI / 2))));
    this.lineTo(x + (w * Math.cos(angle + Math.PI)), y + (w * Math.sin(angle + Math.PI)));
    this.lineTo(x + (h * Math.cos(angle + (Math.PI * 1.5))), y + (h * Math.sin(angle + (Math.PI * 1.5))));
    this.lineTo(x + (w * Math.cos(angle)), y + (w * Math.sin(angle)));
    this.fill();
  };
  
  drawDiamond();
</script>
<canvas id = "canvas45"></canvas>
<button onclick = "startCanvas45()">Start/Stop</button>
<button onclick = "reset45()">Reset</button>
<br><br>
<div><b><u>Current Boxes:</u></b> <span id = "currentBoxesTxt">0</span>/1000</div>
<div class = "desc"><b><i>(8/18/2021)</i></b> Same as the circle packing, except with square packing. Faster than the old circle packing algorithm because of the faster calculations for rectangle intersection.</div>
<hr><hr>
<script>
  const ctx45 = canvas45.getContext("2d");
  canvas45.width = canvas45.height = 2000;
  let canvas45Running = false;
  
  let maxBoxes45 = 1000;
  let currHue45 = Math.random() * 360;
  
  function rectsTouching(ax, ay, aw, ah, bx, by, bw, bh) {
    let minAx = ax - (aw / 2);
    let minAy = ay - (ah / 2);
    let maxAx = ax + (aw / 2);
    let maxAy = ay + (ah / 2);
    let minBx = bx - (bw / 2);
    let minBy = by - (bh / 2);
    let maxBx = bx + (bw / 2);
    let maxBy = by + (bh / 2);
    return maxAx >= minBx && minAx <= maxBx && minAy <= maxBy && maxAy >= minBy;
  }
  
  function Box45() {
    this.x = Math.random() * canvas45.width;
    this.y = Math.random() * canvas45.height;
    this.size = 0;
    this.running = true;
  }
  Box45.prototype.render = function() {
    if (!this.running) return;
    while (this.running) {
      for (let i = 0; i < box45Array.length; i++) {
        if (i != box45Array.indexOf(this)) {
          if (rectsTouching(this.x, this.y, this.size, this.size, box45Array[i].x, box45Array[i].y, box45Array[i].size, box45Array[i].size)) {
            if (this.size == 0) {
              this.x = Math.random() * canvas45.width;
              this.y = Math.random() * canvas45.height;
              return;
            }
            this.running = false;
            if (box45Array.length < maxBoxes45) box45Array.push(new Box45());
            return;
          }
        }
      }
      let halfSize = this.size / 2;
      let distToTop = this.y - halfSize;
      let distToRight = canvas45.width - (this.x + halfSize);
      let distToBottom = canvas45.height - (this.y + halfSize);
      let distToLeft = this.x - halfSize;
      if (distToTop <= 0 || distToRight <= 0 || distToBottom <= 0 || distToLeft <= 0) {
        this.running = false;
        if (box45Array.length < maxBoxes45) box45Array.push(new Box45());
        return;
      }
      this.size++;
    }
  };
  Box45.prototype.draw = function() {
    ctx45.fillStyle = `hsl(${((this.size / (canvas45.width / 2)) * 720) + currHue45}deg, 100%, 50%)`;
    ctx45.fillRectFromCenter(this.x, this.y, this.size, this.size);
    ctx45.lineWidth = 5;
    ctx45.strokeRectFromCenter(this.x, this.y, this.size, this.size);
  };
  let box45Array = [new Box45()];
  
  function frame45() {
    ctx45.clearRect(0, 0, canvas45.width, canvas45.height);
    for (let j = 0; j < 10; j++) {
      for (let i = 0; i < box45Array.length; i++) box45Array[i].render();
    }
    for (let i = 0; i < box45Array.length; i++) box45Array[i].draw();
    
    currentBoxesTxt.innerHTML = box45Array.length;
    
    if (canvas45Running) requestAnimationFrame(frame45);
  }
  frame45();
  
  function startCanvas45() {
    if (canvas45Running) canvas45Running = false;
    else {
      canvas45Running = true;
      frame45();
    }
  }
  
  function reset45() {
    currHue45 = Math.random() * 360;
    box45Array = [new Box45()];
    if (!canvas45Running) frame45();
  }
</script>
<canvas id = "canvas44" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas44()">Start/Stop</button>
<button onclick = "reset44()">Reset</button>
<div><b><u>Current Circles:</u></b> <span id = "currentCirclesTxt">0</span>/2000</div>
<div class = "desc"><b><i>(8/18/2021)</i></b> Circle packing algorithm, currently pretty slow to do only 1000 circles.<br><b><i>(8/19/2021)</i></b> Improved the algorithm some, so that instead of slowly growing and checking for intersections, it calculates the closest distance and then just sets it to that size right away. This makes it faster because there's less callbacks to the same "grow and check" function, but with the downside of having to use lots of expensive square root calls every frame. Update: added a function to calculate if the current X and Y intersects any circles <i>before</i> it chooses a new position for the new circle, as well as making each circle draw once and not having the canvas clear. This sped things up a LOT and FPS averages around 40-60 up to 1000.<br><b><i>(8/22/2021)</i></b> Added minimum circle size and maximum circle size variables.</div>
<hr><hr>
<script>
  const ctx44 = canvas44.getContext("2d");
  canvas44.width = canvas44.height = 2000;
  let canvas44Running = false;
  
  let maxCircles44 = 2000;
  let currHue44 = Math.random() * 360;
  let canvas44Filled = false;
  let minCircle44Size = 0//25;
  let maxCircle44Size = Infinity//50;
  
  function Circle44() {
    let x = Math.random() * canvas44.width;
    let y = Math.random() * canvas44.height;
    let tries = 0;
    while (isPointInCircles44(x, y)) {
      if (tries > 1000) canvas44Filled = true;
      x = Math.random() * canvas44.width;
      y = Math.random() * canvas44.height;
      tries++;
    }
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.running = true;
    this.color = (new RGB()).print();
  }
  Circle44.prototype.render = function() {
    if (!this.running) return;
    let smallestDist = Infinity;
    for (let i = 0; i < circle44Array.length; i++) {
      if (i != circle44Array.indexOf(this)) {
        let distX = this.x - circle44Array[i].x;
        let distY = this.y - circle44Array[i].y;
        let dist = Math.sqrt((distX * distX) + (distY * distY)) - circle44Array[i].radius;
        if (dist <= smallestDist) smallestDist = dist;
      }
    }
    let distToTop = this.y;
    if (distToTop <= smallestDist) smallestDist = distToTop;
    let distToRight = canvas44.width - this.x;
    if (distToRight <= smallestDist) smallestDist = distToRight;
    let distToBottom = canvas44.height - this.y;
    if (distToBottom <= smallestDist) smallestDist = distToBottom;
    let distToLeft = this.x;
    if (distToLeft <= smallestDist) smallestDist = distToLeft;
    this.radius = Math.min(smallestDist, maxCircle44Size);
    this.radiusSq = this.radius * this.radius;
    this.running = false;
    this.draw();
    //if (circle44Array.length < maxCircles44) circle44Array.push(new Circle44());
  };
  Circle44.prototype.draw = function() {
    ctx44.fillStyle = this.color;//`hsl(${((this.radius / (canvas44.width / 2)) * 720) + currHue44}deg, 100%, 50%)`;
    ctx44.lineWidth = 5;
    ctx44.beginPath();
    ctx44.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx44.fill();
    ctx44.stroke();
  };
  let circle44Array = [];
  circle44Array.push(new Circle44());
  
  function isPointInCircles44(x, y) {
    for (let i = 0; i < circle44Array.length; i++) {
      let distX = x - circle44Array[i].x;
      let distY = y - circle44Array[i].y;
      let distSq = (distX * distX) + (distY * distY);
      if (distSq <= (circle44Array[i].radius + minCircle44Size) * (circle44Array[i].radius + minCircle44Size)) {
        return true;
      }
    }
    return false;
  }
  
  let circles44PerFrame = 10;
  
  //let lastFrame44Time = 0;
  function frame44() {
    //console.log(1000 / (Date.now() - lastFrame44Time));
    //lastFrame44Time = Date.now();
    for (let j = 0; j < circles44PerFrame; j++) {
      circle44Array[circle44Array.length - 1].render();
      if (circle44Array.length < maxCircles44 && !canvas44Filled) circle44Array.push(new Circle44());
    }
    
    currentCirclesTxt.innerHTML = circle44Array.length;
    
    if (canvas44Running) requestAnimationFrame(frame44);
  }
  frame44();
  
  function startCanvas44() {
    if (canvas44Running) canvas44Running = false;
    else {
      canvas44Running = true;
      frame44();
    }
  }
  
  function reset44() {
    ctx44.clearRect(0, 0, canvas44.width, canvas44.height);
    currHue44 = Math.random() * 360;
    circle44Array = [new Circle44()];
    canvas44Filled = false;
    if (!canvas44Running) frame44();
  }
</script>
<canvas id = "canvas43" style = "width: 400px; height: 400px"></canvas>
<button onclick = "RGBWalker.walk()">Walk</button>
<div class = "desc"><b><i>(8/17/2021)</i></b> The algorithm I used to try to generate an all RGB image to upload to <a href = "https://allrgb.com" target = "_blank">allrgb.com</a> (VERY SLOW).<br><b><i><mark>Actually finished! (8/18/2021)</mark> Uploaded at <a href = "https://allrgb.com/random-walk-e4494s" target = "_blank">allrgb.com/random-walk-e4494s</a>.</i></b></div>
<hr><hr>
<script>
  const ctx43 = canvas43.getContext("2d");
  canvas43.width = canvas43.height = 4096;
  
  let RGBWalker = {};
  RGBWalker.x = 0;
  RGBWalker.y = 0;
  RGBWalker.r = RGBWalker.g = RGBWalker.b = 0;
  RGBWalker.stepsPerFrame = 1000;
  RGBWalker.squareSize = 64;
  RGBWalker.walk = function() {
    if (this.b >= 256) {
      console.log("Already done!");
      return;
    }
    for (let i = 0; i < this.stepsPerFrame; i++) {
      let dir = Math.floor(Math.random() * 4);
      if (dir == 0) this.y -= this.squareSize;
      else if (dir == 1) this.x += this.squareSize;
      else if (dir == 2) this.y += this.squareSize
      else this.x -= this.squareSize;
      
      this.x = (this.x + canvas43.width) % canvas43.width;
      this.y = (this.y + canvas43.height) % canvas43.height;
      
      let data = ctx43.getImageData(this.x, this.y, 1, 1).data;
      if (data[0] == 0 && data[1] == 0 && data[2] == 0 && data[3] == 0) {
        for (let x = 0; x < this.squareSize; x++) {
          for (let y = 0; y < this.squareSize; y++) {
            ctx43.fillStyle = `rgb(${this.r}, ${this.g}, ${this.b})`;
            ctx43.fillRect(this.x + x, this.y + y, 1, 1);
            this.r++;
            if (this.r >= 256) {
              this.r = 0;
              this.g++;
              if (this.g >= 256) {
                this.g = 0;
                this.b++;
                if (this.b >= 256) {
                  console.log("Done!");
                  return;
                }
              }
            }
          }
        }
      }
    }
  };
</script>
<canvas id = "canvas42" style = "width: 500px; height: 500px"></canvas>
<button onclick = "drawCollatzTree(1000)">+1000</button>
<div class = "desc"><b><i>(8/16/2021)</i></b> Collatz Conjecture visualizer, lots of unused potential for cool designs, such as randomizing the angle / distance, changing the line thickness, etc.</div>
<hr><hr>
<script>
  const ctx42 = canvas42.getContext("2d");
  canvas42.width = canvas42.height = 2000;
  
  function collatzSequence(n) {
    let i = n;
    let sequence = [i];
    while (i != 1) {
      if (i % 2 == 0) i /= 2;
      else i = ((i * 3) + 1) / 2;
      sequence.push(i);
    }
    return sequence.reverse();
  }
  
  let collatzIterations = 0;
  let collatzAngle = 15;
  let collatzSegmentLength = 20;
  
  
  function drawCollatzTree(n) {
    for (let j = 0; j < n; j++) {
      collatzIterations++;
      
      let sequence = collatzSequence(collatzIterations);
      ctx42.save();
      ctx42.translate(canvas42.width / 2, canvas42.height / 2);
      ctx42.beginPath();
      ctx42.moveTo(0, 0);
      for (let i = 0; i < sequence.length; i++) {
        let mult = 1//randBetween(0.5, 1.5);
        if (sequence[i] % 2 == 0) ctx42.rotate(toRad(mult * collatzAngle));
        else ctx42.rotate(toRad(-mult * collatzAngle));
        ctx42.lineTo(0, -mult * collatzSegmentLength);
        ctx42.strokeStyle = "rgba(0, 0, 0, 0.25)";
        //ctx42.fillCircle(0, -collatzSegmentLength, 3);
        ctx42.translate(0, -mult * collatzSegmentLength);
      }
      ctx42.stroke();
      ctx42.restore();
    }
  }
  drawCollatzTree(1000);
</script>
<canvas id = "canvas41"></canvas>
<button onclick = "startCanvas41()">Start/Stop</button>
<button onclick = "reset41()">Reset</button>
<div class = "desc"><b><i>(8/16/2021)</i></b> DLA, except it's connected by lines instead of just touching circles, making a cracking pattern.<br><b><i>(8/25/2021)</i></b> Added a change where each time the walker reaches a point it connects to the 2 nearest, making the cracking look cooler.</div>
<hr><hr>
<script>
  const ctx41 = canvas41.getContext("2d");
  canvas41.width = canvas41.height = 1000;
  let canvas41Running = false;
  
  let expPoints = [{x: canvas41.width / 2, y: canvas41.height / 2}];
  
  let ExpWalker = {};
  ExpWalker.x = 0;
  ExpWalker.y = 0;
  ExpWalker.connectDist = 20;
  ExpWalker.maxConnections = 3;
  ExpWalker.stepsPerFrame = 10000;
  ExpWalker.stickiness = 1//0.5;
  
  ExpWalker.walk = function() {
    for (let j = 0; j < this.stepsPerFrame; j++) {
      if (expPoints.length >= 1000) return;
      let a = Math.random() * Math.PI * 2;
      let v = this.connectDist//randBetween(3, 15);
      this.x += v * Math.cos(a);
      this.y += v * Math.sin(a);
      this.x = this.x.clamp(0, canvas41.width);
      this.y = this.y.clamp(0, canvas41.height);
      
      let willReset = false;
      let currentConnections = 0;
      for (let i = expPoints.length - 1; i >= 0; i--) {//for (let i = 0; i < expPoints.length; i++) {
        let distX = this.x - expPoints[i].x;
        let distY = this.y - expPoints[i].y;
        let distSq = (distX * distX) + (distY * distY);
        if (distSq <= this.connectDist * this.connectDist && Math.random() <= this.stickiness && currentConnections <= this.maxConnections) {
          ctx41.lineWidth = 3;
          ctx41.lineCap = ctx41.lineJoin = "round";
          ctx41.beginPath();
          ctx41.moveTo(expPoints[i].x, expPoints[i].y);
          ctx41.lineTo(this.x, this.y);
          ctx41.stroke();
          willReset = true;
          currentConnections++;
        }
      }
      if (willReset) {
        expPoints.push({x: this.x, y: this.y});
        this.resetPos();
      }
    }
  };
  ExpWalker.resetPos = function() {
    let r = Math.floor(Math.random() * 4);
    if (r == 0) {
      this.x = Math.random() * canvas41.width;
      this.y = 0;
    }
    else if (r == 1) {
      this.x = canvas41.width;
      this.y = Math.random() * canvas41.height;
    }
    else if (r == 2) {
      this.x = Math.random() * canvas41.width;
      this.y = canvas41.height;
    }
    else {
      this.x = 0;
      this.y = Math.random() * canvas41.height;
    }
  };
  
  function frame41() {
    ExpWalker.walk();
    
    if (canvas41Running) requestAnimationFrame(frame41);
  }
  ExpWalker.resetPos();
  frame41();
  
  function startCanvas41() {
    if (canvas41Running) canvas41Running = false;
    else {
      canvas41Running = true;
      frame41();
    }
  }
  
  function reset41() {
    ctx41.clearRect(0, 0, canvas41.width, canvas41.height);
    expPoints = [{x: canvas41.width / 2, y: canvas41.height / 2}];
    ExpWalker.resetPos();
  }
</script>
<canvas id = "canvas40" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas40()">Start/Stop</button>
<div class = "desc"><b><i>(8/16/2021)</i></b> Boid simulation, from <a href = "https://www.youtube.com/watch?v=bqtqltqcQhw" target = "_blank">https://www.youtube.com/watch?v=bqtqltqcQhw</a>. I couldn't get the first and third rules implemented correctly (steer away from, move towards center).</div>
<hr><hr>
<script>
  const ctx40 = canvas40.getContext("2d");
  canvas40.width = canvas40.height = 1000;
  let canvas40Running = false;
  
  function Bird() {
    this.x = Math.random() * canvas40.width;
    this.y = Math.random() * canvas40.height;
    this.angle = Math.random() * Math.PI * 2;
    this.velocity = 5//randBetween(3, 10);
    this.size = 15;
    this.senseRadius = 100//randBetween(50, 100);
    this.turningRatio = 0.01//0.5//randBetween(0.02, 0.1);
  }
  Bird.prototype.render = function() {
    this.x += this.velocity * Math.cos(this.angle);
    this.y += this.velocity * Math.sin(this.angle);
    
    for (let i = 0; i < birdArray.length; i++) {
      if (i != birdArray.indexOf(this)) {
        let distX = this.x - birdArray[i].x;
        let distY = this.y - birdArray[i].y;
        let dist = (distX * distX) + (distY * distY);
        if (dist <= this.senseRadius * this.senseRadius) {
          let angleTo = Math.atan2(this.y - birdArray[i].y, this.x - birdArray[i].x) - this.angle;
          //this.angle += (angleTo - this.angle) / 10;
          this.angle += (birdArray[i].angle - this.angle) * this.turningRatio;
          this.angle = (this.angle + (Math.PI * 2)) % (Math.PI * 2);
        }
      }
    }
    
    this.x = (this.x + canvas40.width) % canvas40.width;
    this.y = (this.y + canvas40.height) % canvas40.height;
    
    //ctx40.fillStyle = "rgba(0, 255, 0, 0.25)";
    //ctx40.fillCircle(this.x, this.y, this.senseRadius);
    ctx40.fillStyle = "white";
    ctx40.strokeStyle = "black";
    ctx40.lineWidth = 3;
    ctx40.save();
    ctx40.translate(this.x, this.y);
    ctx40.rotate(this.angle);
    ctx40.beginPath();
    ctx40.moveTo(this.size, 0);
    ctx40.lineTo(-this.size, this.size / 2);
    ctx40.lineTo(-this.size / 2, 0);
    ctx40.lineTo(-this.size, -this.size / 2);
    ctx40.lineTo(this.size, 0);
    ctx40.lineTo(-this.size, this.size / 2);
    ctx40.fill();
    ctx40.stroke();
    ctx40.restore();
  };
  let birdArray = [];
  for (let i = 0; i < 40; i++) birdArray.push(new Bird());
  
  function frame40() {
    ctx40.clearRect(0, 0, canvas40.width, canvas40.height);
    
    for (let i = 0; i < birdArray.length; i++) birdArray[i].render();
    
    if (canvas40Running) requestAnimationFrame(frame40);
  }
  frame40();
  
  function startCanvas40() {
    if (canvas40Running) canvas40Running = false;
    else {
      canvas40Running = true;
      frame40();
    }
  }
</script>
<canvas id = "canvas39"></canvas>
<button onclick = "randomizeWorleyPoints()">Reset</button>
<div class = "desc"><b><i>(8/15/2021)</i></b> Worley noise visualizer.</div>
<hr><hr>
<script>
  const ctx39 = canvas39.getContext("2d");
  canvas39.width = canvas39.height = 100;
  
  let worleyPoints = [];
  let startingWorleyPoints = 10;
  for (let i = 0; i < startingWorleyPoints; i++) worleyPoints.push({x: Math.random() * canvas39.width, y: Math.random() * canvas39.height});
  let worleyNoiseIndex = 1;
  let worleyNoiseIntensity = 50;
  let worleyNoiseHue = 240;
  
  function randomizeWorleyPoints() {
    worleyPoints = [];
    for (let i = 0; i < startingWorleyPoints; i++) worleyPoints.push({x: Math.random() * canvas39.width, y: Math.random() * canvas39.height, color: (new RGB()).print()});
    drawWorleyNoise();
  }
  
  function drawWorleyNoise() {
    for (let x = 0; x < canvas39.width; x++) {
      for (let y = 0; y < canvas39.height; y++) {
        let distArray = [];
        for (let i = 0; i < worleyPoints.length; i++) {
          let dist = Math.hypot(x - worleyPoints[i].x, y - worleyPoints[i].y);
          distArray.push(dist);
        }
        let sortedDistArray = distArray.sort((a, b) => a - b);
        //ctx39.fillStyle = `hsl(${(sortedDistArray[worleyNoiseIndex] / worleyNoiseIntensity) * 360}deg, 100%, 50%)`;
        ctx39.fillStyle = `hsl(${worleyNoiseHue}deg, 100%, ${(sortedDistArray[worleyNoiseIndex] / worleyNoiseIntensity) * 100}%)`;
        ctx39.fillRect(x, y, 1, 1);
      }
    }
    
    /*ctx39.fillStyle = "lime";
    for (let i = 0; i < worleyPoints.length; i++) {
      ctx39.fillCircle(worleyPoints[i].x, worleyPoints[i].y, 3);
    }*/
  }
  drawWorleyNoise();
</script>
<canvas id = "canvas38" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas38()">Start/Stop</button>
<br><br>
<div><b><u>Multiplier:</u></b> <span id = "roseMultiplierTxt">2</span>x</div>
<input type = "range" min = "1" max = "15" step = "1" value = "2" id = "roseMultiplierRange" oninput = "updateSettings38()">
<br><br>
<div><b><u>Offset Angle:</u></b> <span id = "roseOffsetAngleTxt">29</span>&deg;</div>
<input type = "range" min = "1" max = "359" step = "1" value = "29" id = "roseOffsetAngleRange" oninput = "updateSettings38()">
<br><br>
<div><b><u>Show Path:</u></b></div>
<input type = "checkbox" id = "showRoseCheckbox" oninput = "updateSettings38()">
<div class = "desc"><b><i>(8/13/2021)</i></b> Animated Maurer Rose generator.</div>
<hr><hr>
<script>
  const ctx38 = canvas38.getContext("2d");
  canvas38.width = canvas38.height = 1000;
  let canvas38Running = false;
  
  let showRose = false;
  let vRoseOffsetAngle = 0.5;
  
  let roseMultiplier = 2;
  let roseOffsetAngle = 29;
  let roseRadius = 450;
  
  ctx38.translate(canvas38.width / 2, canvas38.height / 2);
  
  function drawRose() {
    ctx38.fillStyle = canvas38Running ? "rgba(255, 255, 255, 0.1)" : "white";
    ctx38.fillRect(-canvas38.width / 2, -canvas38.height / 2, canvas38.width, canvas38.height);
    
    ctx38.strokeStyle = "black";
    ctx38.lineWidth = 1;
    ctx38.beginPath();
    ctx38.moveTo(0, 0);
    for (let i = 0; i <= 360; i++) {
      let a = i;
      let r = Math.sin(toRad(roseMultiplier * i * Math.floor(roseOffsetAngle)));
      let x = r * Math.cos(toRad(i * Math.floor(roseOffsetAngle)));
      let y = r * Math.sin(toRad(i * Math.floor(roseOffsetAngle)));
      ctx38.lineTo(x * roseRadius, y * roseRadius);
    }
    ctx38.stroke();
    
    if (showRose) {
      ctx38.strokeStyle = "red";
      ctx38.lineWidth = 5;
      ctx38.beginPath();
      ctx38.moveTo(0, 0);
      for (let i = 0; i <= 360; i++) {
        let a = toRad(i);
        let r = Math.sin(toRad(roseMultiplier * i));
        let x = r * Math.cos(a);
        let y = r * Math.sin(a);
        ctx38.lineTo(x * roseRadius, y * roseRadius);
      }
      ctx38.stroke();
    }
    
    if (canvas38Running) {
      roseOffsetAngle += vRoseOffsetAngle;
      if (roseOffsetAngle >= 359) {
        roseOffsetAngle = 359;
        vRoseOffsetAngle *= -1;
      }
      if (roseOffsetAngle <= 0) {
        roseOffsetAngle = 0;
        vRoseOffsetAngle *= -1;
      }
      roseOffsetAngleTxt.innerHTML = roseOffsetAngleRange.value = Math.floor(roseOffsetAngle);
      requestAnimationFrame(drawRose);
    }
  }
  drawRose();
  
  function updateSettings38() {
    roseMultiplier = roseMultiplierTxt.innerHTML = Number(roseMultiplierRange.value);
    roseOffsetAngle = roseOffsetAngleTxt.innerHTML = Number(roseOffsetAngleRange.value);
    showRose = showRoseCheckbox.checked;
    
    if (!canvas38Running) drawRose();
  }
  
  function startCanvas38() {
    if (canvas38Running) canvas38Running = false;
    else {
      canvas38Running = true;
      drawRose();
    }
  }
</script>
<canvas id = "canvas37"></canvas>
<button onclick = "drawLines()">Go</button>
<br><br>
<div><b><u>Grid Size:</u></b> <span id = "lineGridSizeTxt">30x30</span></div>
<input type = "range" min = "2" max = "100" step = "1" value = "30" id = "lineGridSizeRange" oninput = "updateSettings37()">
<br><br>
<div><b><u>Line Slant:</u></b></div>
<input type = "range" min = "5" max = "95" step = "5" value = "50" id = "lineSlantRange" oninput = "updateSettings37()">
<br><br>
<div><b><u>Line Width:</u></b> <span id = "lineSizeTxt">10</span></div>
<input type = "range" min = "1" max = "20" step = "1" value = "10" id = "lineSizeRange" oninput = "updateSettings37()">
<br><br>
<div class = "desc"><b><i>(8/13/2021)</i></b> Line grid drawn using the 10 PRINT command from COMMODORE 64.<br><b><i>(8/15/2021)</i></b> Added more sliders, I want to have different modes of how the lines are drawn for more interesting patterns.</div>
<hr><hr>
<script>
  const ctx37 = canvas37.getContext("2d");
  canvas37.width = canvas37.height = 1000;
  
  let lineSize = 10;
  let lineGridSize = 30;
  let lineSlant = 0.5;
  let lineDrawMode = 1;
  
  ctx37.lineCap = ctx37.lineJoin = "square";
  
  function drawLines() {
    ctx37.clearRect(0, 0, canvas37.width, canvas37.height);
    let tileSize = canvas37.width / lineGridSize;
    
    for (let x = 0; x < canvas37.width; x += tileSize) {
      for (let y = 0; y < canvas37.height; y += tileSize) {
        //ctx37.lineWidth = ((x / canvas37.width) * 5) + ((y / canvas37.height) * 5) + 3;
        //ctx37.strokeStyle = `hsl(0deg, ${100 - (((x / canvas37.width) * 50) + ((y / canvas37.height) * 50))}%, 50%)`;
        ctx37.lineWidth = lineSize;
        ctx37.globalAlpha = 1//0.75;
        ctx37.strokeStyle = "black";//`hsl(${Math.floor(Math.random() * 3) * 120}deg, 100%, 50%)`;
        if (Math.random() <= lineSlant) {
          ctx37.beginPath();
          ctx37.moveTo(x, y);
          ctx37.lineTo(x + tileSize, y + tileSize);
          ctx37.stroke();
        }
        else {
          ctx37.beginPath();
          ctx37.moveTo(x + tileSize, y);
          ctx37.lineTo(x, y + tileSize);
          ctx37.stroke();
        }
      }
    }
  }
  drawLines();
  
  function updateSettings37() {
    lineSlant = Number(lineSlantRange.value) / 100;
    lineGridSize = Number(lineGridSizeRange.value);
    lineGridSizeTxt.innerHTML = lineGridSize + "x" + lineGridSize;
    lineSize = lineSizeTxt.innerHTML = Number(lineSizeRange.value);
    
    drawLines();
  }
</script>
<canvas id = "canvas36" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas36()">Start/Stop</button>
<button onclick = "clearCanvas36()">Clear</button>
<br><br>
<div><b><u>Brush Mode:</u></b> <span id = "brushModeTxt">11</span></div>
<input type = "range" min = "1" max = "11" step = "1" value = "11" id = "brushModeRange" oninput = "updateSettings36()" style = "width: 300px">
<br><br>
<div><b><u>Auto-Erase:</u></b></div>
<input type = "checkbox" id = "autoEraseCheckbox" oninput = "updateSettings36()">
<br><br>
<div><b><u>Total Particles Created:</u></b> <span id = "totalParticlesTxt">0</span></div>
<div class = "desc"><b><i>(8/12/2021)</i></b> Generative art drawing, using <a href = "https://www.youtube.com/watch?v=0v4_Dw0K8pw" target = "_blank">this</a> video as a reference.<br><b><i><mark>Actually finished! (8/14/2021)</mark> Moved to <a href = "generative-sketch.html" target = "_blank">generative-sketch.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx36 = canvas36.getContext("2d");
  canvas36.width = canvas36.height = 1000;
  let canvas36Ratio = canvas36.width / 400;
  let canvas36Running = false;
  let canvas36Rect = canvas36.getBoundingClientRect();
  
  let offscreenCanvas36 = document.createElement("canvas");
  offscreenCanvas36.width = offscreenCanvas36.height = canvas36.width;
  const octx36 = offscreenCanvas36.getContext("2d");
  
  let brushMode = 11;
  let autoErase = false;
  let totalParticles = 0;
  let animInterval = 0;
  let animIntervalPeriod = 500;
  
  let mouseDown36 = false;
  
  /*
  
  Ideas:
  - Random walker particle
  - Particle with gravity/wind
  - Particle with angle velocity with angle constantly changing
  
  */
  
  function Particle1(x, y) { // Vines
    this.x = x;
    this.y = y;
    this.vx = Math.random() * 2 * randSign();
    this.vy = Math.random() * 2 * randSign();
    this.angleX = Math.random() * Math.PI * 2;
    this.angleY = Math.random() * Math.PI * 2;
    this.vAngleX = Math.random() * 0.25 * randSign();
    this.vAngleY = Math.random() * 0.25 * randSign();
    this.size = randBetween(1, 3);
    this.maxSize = randBetween(3, 9);
    this.growSpeed = randBetween(0.05, 0.25);
    this.lightness = 10;
    this.dead = false;
  }
  Particle1.prototype.render = function() {
    this.x += this.vx + Math.sin(this.angleX);
    this.y += this.vy + Math.sin(this.angleY);
    this.size += this.growSpeed;
    this.angleX += this.vAngleX;
    this.angleY += this.vAngleY;
    if (this.lightness < 70) this.lightness += 0.75;
    if (this.size <= this.maxSize) {
      ctx36.fillStyle = `hsl(120deg, 100%, ${this.lightness}%)`;
      ctx36.fillCircle(this.x, this.y, this.size);
    }
    else this.dead = true;
  };
  
  function Particle2(x, y) { // Cubes
    this.x = x;
    this.y = y;
    this.vx = Math.random() * 2 * randSign();
    this.vy = Math.random() * 2 * randSign();
    this.size = randBetween(1, 3);
    this.maxSize = randBetween(20, 30);
    this.growSpeed = randBetween(0.5, 0.75);
    this.hue = animInterval * 720;
    this.dead = false;
  }
  Particle2.prototype.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    this.size += this.growSpeed;
    if (this.size <= this.maxSize) {
      ctx36.fillStyle = `hsl(${this.hue}deg, 70%, 70%)`;//"white";
      ctx36.strokeStyle = "black";
      ctx36.lineWidth = 1;
      ctx36.fillRectFromCenter(this.x, this.y, this.size, this.size);
      ctx36.strokeRectFromCenter(this.x, this.y, this.size, this.size);
    }
    else this.dead = true;
  };
  
  function Particle3(x, y) { // Fireworks
    this.x = x;
    this.y = y;
    let a = Math.random() * Math.PI * 2;
    let v = Math.random() * 3;
    this.vx = v * Math.cos(a);
    this.vy = v * Math.sin(a);
    this.size = 0;
    this.ratio = randBetween(0.5, 1);
    this.maxSize = randBetween(10, 20);
    this.growSpeed = randBetween(0.4, 0.5);
    this.angle = Math.random() * Math.PI * 2;
    this.vAngle = Math.random() * 0.1 * randSign();
    this.color = Math.random() >= 0.5 ? "red" : "blue";
    this.angleX = Math.random() * Math.PI * 2;
    this.angleY = Math.random() * Math.PI * 2;
    this.vAngleX = Math.random() * 0.25 * randSign();
    this.vAngleY = Math.random() * 0.25 * randSign();
    this.dead = false;
  }
  Particle3.prototype.render = function() {
    this.x += this.vx + Math.sin(this.angleX) * 1.5;
    this.y += this.vy + Math.sin(this.angleY) * 1.5;
    this.size += this.growSpeed;
    this.angle += this.vAngle;
    this.angleX += this.vAngleX;
    this.angleY += this.vAngleY;
    if (this.size <= this.maxSize) {
      ctx36.fillStyle = "white";
      ctx36.shadowColor = this.color;
      ctx36.shadowBlur = 10;
      ctx36.fillPointedStar(this.x, this.y, (this.size / 2) * this.ratio, this.size * this.ratio, 5, this.angle);
      ctx36.shadowBlur = 0;
    }
    else this.dead = true;
  };
  
  function Particle4(x, y) {
    this.x = x;
    this.y = y;
    this.vx = Math.random() * randSign();
    this.vy = Math.random() * randSign();
    this.angleX = Math.random() * Math.PI * 2;
    this.angleY = Math.random() * Math.PI * 2;
    this.vAngleX = Math.random() * 0.25 * randSign();
    this.vAngleY = Math.random() * 0.25 * randSign();
    this.angle = Math.random() * Math.PI * 2;
    this.vAngle = Math.random() * randSign();
    this.size = 0;
    this.maxSize = randBetween(10, 30);
    this.growSpeed = randBetween(0.5, 0.75);
    this.dead = false;
  }
  Particle4.prototype.render = function() {
    this.x += this.vx + Math.sin(this.angleX);
    this.y += this.vy + Math.sin(this.angleY);
    this.size += this.growSpeed;
    this.angleX += this.vAngleX;
    this.angleY += this.vAngleY;
    this.angle += this.vAngle;
    if (this.size <= this.maxSize) {
      ctx36.globalCompositeOperation = "destination-over";
      ctx36.fillStyle = "white";
      ctx36.shadowColor = "black";
      ctx36.shadowBlur = 5;
      ctx36.fillRotatedRectFromCenter(this.x, this.y, this.size, this.size, this.angle);
      ctx36.globalCompositeOperation = "source-over";
      ctx36.shadowBlur = 0;
    }
    else this.dead = true;
  };
  
  function Particle5(x, y) { // Glass
    this.x = x;
    this.y = y;
    this.velocity = Math.random() * 2 * randSign();
    this.size = randBetween(2, 5);
    this.thickness = randBetween(1, 7);
    this.maxSize = randBetween(20, 60);
    this.growSpeed = randBetween(0.75, 1.5);
    this.sideways = Math.random() >= 0.5;
    this.hue = randBetween(180, 300);
    this.lightness = randBetween(50, 100);
    this.dead = false;
  }
  Particle5.prototype.render = function() {
    if (this.sideways) this.y += this.velocity;
    else this.x += this.velocity;
    this.size += this.growSpeed;
    this.angleX += this.vAngleX;
    this.angleY += this.vAngleY;
    if (this.size <= this.maxSize) {
      ctx36.fillStyle = `hsl(${this.hue}deg, 100%, ${this.lightness}%)`;
      ctx36.strokeStyle = `hsl(${this.hue}deg, 100%, 80%)`;
      ctx36.lineWidth = 2;
      ctx36.shadowColor = "black"
      ctx36.shadowBlur = 5;
      if (this.sideways) {
        ctx36.fillRectFromCenter(this.x, this.y, this.size, this.thickness);
        ctx36.strokeRectFromCenter(this.x, this.y, this.size, this.thickness);
      }
      else {
        ctx36.fillRectFromCenter(this.x, this.y, this.thickness, this.size);
        ctx36.strokeRectFromCenter(this.x, this.y, this.thickness, this.size);
      }
      ctx36.shadowBlur = 0;
    }
    else this.dead = true;
  };
  
  function Particle6(x, y) { // Tendrils
    this.x = x;
    this.y = y;
    this.vx = Math.random() * 2 * randSign();
    this.vy = Math.random() * 2 * randSign();
    this.angleX = Math.random() * Math.PI * 2;
    this.angleY = Math.random() * Math.PI * 2;
    this.vAngleX = Math.random() * 0.5 * randSign();
    this.vAngleY = Math.random() * 0.5 * randSign();
    this.size = randBetween(10, 20);
    this.minSize = 0;
    this.shrinkSpeed = randBetween(0.25, 1);
    this.hue = Math.random() * 360;
    this.dead = false;
  }
  Particle6.prototype.render = function() {
    this.x += this.vx + (Math.sin(this.angleX) * 2);
    this.y += this.vy + (Math.sin(this.angleY) * 2);
    this.size -= this.shrinkSpeed;
    this.angleX += this.vAngleX;
    this.angleY += this.vAngleY;
    if (this.size >= this.minSize) {
      ctx36.fillStyle = `hsl(${this.hue}deg, 100%, 70%)`;
      ctx36.shadowColor = "black";
      ctx36.shadowBlur = 4;
      ctx36.fillCircle(this.x, this.y, this.size);
      ctx36.shadowBlur = 0;
    }
    else this.dead = true;
  };
  
  function Particle7(x, y) { // Strings
    this.x = x;
    this.y = y;
    this.vx = Math.random() * 0.5 * randSign();
    this.vy = Math.random() * 0.5 * randSign();
    this.size = randBetween(1, 2);
    this.age = 0;
    this.maxAge = randBetween(50, 150);
    this.lightness = Math.random() * 100;
    this.dead = false;
  }
  Particle7.prototype.render = function() {
    this.age++;
    this.x += this.vx;
    this.y += this.vy;
    this.vx += Math.random() * 0.25 * randSign();
    this.vy += Math.random() * 0.25 * randSign();
    if (this.age <= this.maxAge) {
      ctx36.fillStyle = `hsl(0deg, 0%, ${this.lightness}%)`;
      ctx36.shadowColor = "black";
      ctx36.shadowBlur = 3;
      ctx36.fillCircle(this.x, this.y, this.size);
      ctx36.shadowBlur = 0;
    }
    else this.dead = true;
  };
  
  function Particle8(x, y) { // Pixels
    this.size = Math.round(randBetween(2, 6)) * 3;
    this.x = Math.round(x / this.size) * this.size;
    this.y = Math.round(y / this.size) * this.size;
    this.vx = Math.random() * randSign();
    this.vy = Math.random() * randSign();
    this.age = 0;
    this.maxAge = randBetween(25, 75);
    this.hue = Math.floor(Math.random() * 6) * 60;
    this.dead = false;
  }
  Particle8.prototype.render = function() {
    this.age++;
    this.x += this.vx;
    this.y += this.vy;
    if (this.age <= this.maxAge) {
      ctx36.fillStyle = `hsl(${this.hue}deg, 100%, 50%)`;
      ctx36.strokeStyle = "black";
      ctx36.lineWidth = 2;
      ctx36.fillRectFromCenter(Math.round(this.x / this.size) * this.size, Math.floor(this.y / this.size) * this.size, this.size, this.size);
      ctx36.strokeRectFromCenter(Math.round(this.x / this.size) * this.size, Math.floor(this.y / this.size) * this.size, this.size, this.size);
    }
    else this.dead = true;
  };
  
  function Particle9(x, y) { // Coils
    this.x = x;
    this.y = y;
    this.angle = Math.random() * Math.PI * 2;
    this.vAngle = randBetween(0.05, 0.1);
    this.velocity = randBetween(1, 3);
    this.size = randBetween(3, 9);
    this.minSize = 0;
    this.shrinkSpeed = randBetween(0.05, 0.25);
    this.lightness = 100;
    this.hue = animInterval * 360;
    this.dead = false;
  }
  Particle9.prototype.render = function() {
    this.x += Math.cos(this.angle) * this.velocity;
    this.y += Math.sin(this.angle) * this.velocity;
    this.size -= this.shrinkSpeed;
    this.angle += this.vAngle * randBetween(0.5, 1.5);
    if (this.lightness > 50) this.lightness -= 0.75;
    if (this.size >= this.minSize) {
      ctx36.fillStyle = `hsl(${this.hue}deg, 100%, ${this.lightness}%)`;
      ctx36.shadowColor = "black";
      ctx36.shadowBlur = 5;
      ctx36.fillCircle(this.x, this.y, this.size);
      ctx36.shadowBlur = 0;
    }
    else this.dead = true;
  };
  
  function Particle10(x, y) { // Watercolor
    this.x = x;
    this.y = y;
    let a = Math.random() * Math.PI * 2;
    let v = randBetween(1, 3);
    this.vx = v * Math.cos(a);
    this.vy = v * Math.sin(a);
    this.size = 0;
    this.maxSize = randBetween(10, 20);
    this.growSpeed = randBetween(0.75, 1.5);
    this.hue = animInterval * 720;
    this.dead = false;
  }
  Particle10.prototype.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    this.size += this.growSpeed;
    if (this.size <= this.maxSize) {
      ctx36.globalCompositeOperation = "darken";
      ctx36.fillStyle = `hsla(${this.hue}deg, 100%, 60%, 0.3)`;
      ctx36.fillCircle(this.x, this.y, this.size);
      ctx36.globalCompositeOperation = "source-over";
    }
    else this.dead = true;
  };
  
  function Particle11(x, y) {
    this.x = x;
    this.y = y;
    let a = Math.random() * Math.PI * 2;
    let v = randBetween(1, 3);
    this.vx = v * Math.cos(a);
    this.vy = v * Math.sin(a);
    this.accY = randBetween(0.05, 0.15);
    this.size = randBetween(10, 20);
    this.minSize = randBetween(3, 9);
    this.shrinkSpeed = randBetween(0.25, 0.5);
    this.hue = animInterval * 360//Math.random() * 360;
    this.lightness = Math.random() * 50;
    this.dead = false;
  }
  Particle11.prototype.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += this.accY;
    this.size -= this.shrinkSpeed;
    this.lightness += 0.5;
    if (this.size >= this.minSize) {
      ctx36.globalCompositeOperation = "lighten";
      ctx36.fillStyle = `hsl(${this.hue}deg, 100%, ${this.lightness}%)`;
      ctx36.strokeStyle = "black";
      ctx36.lineWidth = 12;
      ctx36.fillCircle(this.x, this.y, this.size);
      ctx36.strokeCircle(this.x, this.y, this.size);
      ctx36.globalCompositeOperation = "source-over";
    }
    else this.dead = true;
  };
  
  let particleArray = [];
  
  
  
  
  
  function frame36() {
    animInterval += 1 / animIntervalPeriod;
    if (animInterval >= 1) animInterval = 0;
    if (autoErase) {
      octx36.clearRect(0, 0, offscreenCanvas36.width, offscreenCanvas36.height);
      octx36.globalAlpha = 0.995;
      octx36.drawImage(canvas36, 0, 0);
      ctx36.clearRect(0, 0, canvas36.width, canvas36.height);
      ctx36.drawImage(offscreenCanvas36, 0, 0);
    }
    for (let i = 0; i < particleArray.length; i++) {
      particleArray[i].render();
      if (particleArray[i].dead) {
        particleArray.splice(i, 1);
        i--;
      }
    }
    
    totalParticlesTxt.innerHTML = comma(totalParticles);
    
    if (canvas36Running) requestAnimationFrame(frame36);
  }
  frame36();
  
  canvas36.addEventListener("mousedown", e => {
    mouseDown36 = true;
    canvas36Rect = canvas36.getBoundingClientRect();
    for (let i = 0; i < 50; i++) {
      let x = (e.clientX - canvas36Rect.left) * canvas36Ratio;
      let y = (e.clientY - canvas36Rect.top) * canvas36Ratio;
      let newParticle;
      
      if (brushMode == 1) newParticle = new Particle1(x, y);
      else if (brushMode == 2) newParticle = new Particle2(x, y);
      else if (brushMode == 3) newParticle = new Particle3(x, y);
      else if (brushMode == 4) newParticle = new Particle4(x, y);
      else if (brushMode == 5) newParticle = new Particle5(x, y);
      else if (brushMode == 6) newParticle = new Particle6(x, y);
      else if (brushMode == 7) newParticle = new Particle7(x, y);
      else if (brushMode == 8) newParticle = new Particle8(x, y);
      else if (brushMode == 9) newParticle = new Particle9(x, y);
      else if (brushMode == 10) newParticle = new Particle10(x, y);
      else if (brushMode == 11) newParticle = new Particle11(x, y);
      
      particleArray.push(newParticle);
      
      totalParticles++;
    }
  });
  canvas36.addEventListener("mouseup", e => {
    mouseDown36 = false;
  });
  canvas36.addEventListener("mousemove", e => {
    if (mouseDown36) {
      canvas36Rect = canvas36.getBoundingClientRect();
      for (let i = 0; i < 3; i++) {
        let x = (e.clientX - canvas36Rect.left) * canvas36Ratio;
        let y = (e.clientY - canvas36Rect.top) * canvas36Ratio;
        let newParticle;
        
        if (brushMode == 1) newParticle = new Particle1(x, y);
        else if (brushMode == 2) newParticle = new Particle2(x, y);
        else if (brushMode == 3) newParticle = new Particle3(x, y);
        else if (brushMode == 4) newParticle = new Particle4(x, y);
        else if (brushMode == 5) newParticle = new Particle5(x, y);
        else if (brushMode == 6) newParticle = new Particle6(x, y);
        else if (brushMode == 7) newParticle = new Particle7(x, y);
        else if (brushMode == 8) newParticle = new Particle8(x, y);
        else if (brushMode == 9) newParticle = new Particle9(x, y);
        else if (brushMode == 10) newParticle = new Particle10(x, y);
        else if (brushMode == 11) newParticle = new Particle11(x, y);
        
        particleArray.push(newParticle);
        
        totalParticles++;
      }
    }
  });
  
  function clearCanvas36() {
    particleArray = [];
    ctx36.clearRect(0, 0, canvas36.width, canvas36.height);
  }
  
  function startCanvas36() {
    if (canvas36Running) canvas36Running = false;
    else {
      canvas36Running = true;
      frame36();
    }
  }
  
  function updateSettings36() {
    brushMode = brushModeTxt.innerHTML = Number(brushModeRange.value);
    autoErase = autoEraseCheckbox.checked;
  }
  
  CanvasRenderingContext2D.prototype.strokePointedStar = function(x, y, innerRadius, outerRadius, points, offsetAngle) {
    this.beginPath();
    this.moveTo(x + (outerRadius * Math.cos(offsetAngle - Math.PI / 2)), y + (outerRadius * Math.sin(offsetAngle - Math.PI / 2)));
    for (let i = 0; i < points + 1; i++) {
      let a = (i * ((Math.PI * 2) / points)) - (Math.PI / 2);
      let a2 = ((i + 0.5) * ((Math.PI * 2) / points)) - (Math.PI / 2);
      this.lineTo(x + (outerRadius * Math.cos(a + offsetAngle)), y + (outerRadius * Math.sin(a + offsetAngle)));
      this.lineTo(x + (innerRadius * Math.cos(a2 + offsetAngle)), y + (innerRadius * Math.sin(a2 + offsetAngle)));
    }
    this.stroke();
  };
  CanvasRenderingContext2D.prototype.fillPointedStar = function(x, y, innerRadius, outerRadius, points, offsetAngle) {
    this.beginPath();
    this.moveTo(x + (outerRadius * Math.cos(offsetAngle - Math.PI / 2)), y + (outerRadius * Math.sin(offsetAngle - Math.PI / 2)));
    for (let i = 0; i < points + 1; i++) {
      let a = (i * ((Math.PI * 2) / points)) - (Math.PI / 2);
      let a2 = ((i + 0.5) * ((Math.PI * 2) / points)) - (Math.PI / 2);
      this.lineTo(x + (outerRadius * Math.cos(a + offsetAngle)), y + (outerRadius * Math.sin(a + offsetAngle)));
      this.lineTo(x + (innerRadius * Math.cos(a2 + offsetAngle)), y + (innerRadius * Math.sin(a2 + offsetAngle)));
    }
    this.fill();
  };
  
  CanvasRenderingContext2D.prototype.strokePolygon = function(x, y, radius, sides, offsetAngle) {
    this.beginPath();
    this.moveTo(x + (radius * Math.cos(offsetAngle - Math.PI / 2)), y + (radius * Math.sin(offsetAngle - Math.PI / 2)));
    for (let i = 0; i <= sides + 1; i++) {
      let angle = ((i / sides) * Math.PI * 2) - (Math.PI / 2);
      this.lineTo(x + (Math.cos(angle + offsetAngle) * radius), y + (Math.sin(angle + offsetAngle) * radius));
    }
    this.stroke();
  };
  CanvasRenderingContext2D.prototype.fillPolygon = function(x, y, radius, sides, offsetAngle) {
    this.beginPath();
    this.moveTo(x + (radius * Math.cos(offsetAngle - Math.PI / 2)), y + (radius * Math.sin(offsetAngle - Math.PI / 2)));
    for (let i = 0; i <= sides + 1; i++) {
      let angle = ((i / sides) * Math.PI * 2) - (Math.PI / 2);
      this.lineTo(x + (Math.cos(angle + offsetAngle) * radius), y + (Math.sin(angle + offsetAngle) * radius));
    }
    this.fill();
  };
  
  function comma(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
</script>
<canvas id = "canvas35"></canvas>
<button onclick = "startCanvas35()">Start/Stop</button>
<br><br>
<button onclick = "resetVoronoiPoints()">Reset</button>
<button onclick = "distMetric = (distMetric + 1) % 3; drawVoronoiDiagram()">Switch Distance Metric</button>
<button onclick = "showVoronoiPoints = !showVoronoiPoints; drawVoronoiDiagram()">Show/Hide Points</button>
<div class = "desc"><b><i>(8/12/2021)</i></b> Animated Voronoi diagram with changeable distance metric.</div>
<hr><hr>
<script>
  const ctx35 = canvas35.getContext("2d");
  canvas35.width = canvas35.height = 300;
  let canvas35Running = false;
  let canvas35Callback;
  
  let startingVoronoiPoints = 30;
  let showVoronoiPoints = true;
  
  let distMetric = 0; // 0: Euclidean | 1: Manhattan | 2: Chebyshev
  
  let voronoiPoints = [];
  
  let currMaxDist = 1;
  let maxDistSpeed = 2;
  
  let allPointsColored = false;
  
  function frame35() {
    ctx35.clearRect(0, 0, canvas35.width, canvas35.height);
    allPointsColored = true;
    
    drawVoronoiDiagram();
    
    currMaxDist += maxDistSpeed;
    
    if (canvas35Running && !allPointsColored) canvas35Callback = requestAnimationFrame(frame35);
  }
  
  function drawVoronoiDiagram() {
    for (let x = 0; x < canvas35.width; x++) {
      for (let y = 0; y < canvas35.height; y++) {
        let minDist = Infinity;
        let closestPoint = 0;
        for (let i = 0; i < voronoiPoints.length; i++) {
          let distX = Math.abs(x - voronoiPoints[i].x);
          let distY = Math.abs(y - voronoiPoints[i].y);
          let dist = 0;
          if (distMetric == 0) dist = (distX * distX) + (distY * distY);
          else if (distMetric == 1) dist = distX + distY;
          else if (distMetric == 2) dist = Math.max(distX, distY);
          if (dist <= minDist) {
            minDist = dist;
            closestPoint = i;
          }
        }
        if (minDist < (distMetric == 0 ? currMaxDist * currMaxDist : currMaxDist)) ctx35.fillStyle = voronoiPoints[closestPoint].color;
        else {
          ctx35.fillStyle = "white";
          allPointsColored = false;
        }
        ctx35.fillRect(x, y, 1, 1);
      }
    }
    if (showVoronoiPoints) {
      ctx35.fillStyle = "black";
      for (let i = 0; i < voronoiPoints.length; i++) {
        ctx35.fillCircle(voronoiPoints[i].x, voronoiPoints[i].y, 2);
      }
    }
  }
  
  function resetVoronoiPoints() {
    cancelAnimationFrame(canvas35Callback);
    currMaxDist = 0;
    voronoiPoints = [];
    for (let i = 0; i < startingVoronoiPoints; i++) {
      voronoiPoints.push({
        x: Math.random() * canvas35.width,
        y: Math.random() * canvas35.height,
        color: `hsl(${(i / startingVoronoiPoints) * 360}deg, ${Math.random() * 100}%, ${randBetween(25, 75)}%)`
      });
    }
    frame35();
  }
  resetVoronoiPoints();
  
  function startCanvas35() {
    if (canvas35Running) canvas35Running = false;
    else {
      canvas35Running = true;
      frame35();
    }
  }
</script>
<canvas id = "canvas34"></canvas>
<button onclick = "ColorWalker.walk()">Go</button>
<div class = "desc"><b><i>(8/11/2021)</i></b> Random walker that randomly changes its color per step.</div>
<hr><hr>
<script>
  const ctx34 = canvas34.getContext("2d");
  canvas34.width = canvas34.height = 300;
  
  let ColorWalker = {};
  ColorWalker.x = Math.floor(canvas34.width / 2);
  ColorWalker.y = Math.floor(canvas34.height / 2);
  ColorWalker.r = ColorWalker.g = ColorWalker.b = 0;
  ColorWalker.stepsPerFrame = 100000;
  ColorWalker.walk = function() {
    for (let i = 0; i < this.stepsPerFrame; i++) {
      let direction = Math.floor(Math.random() * 8);
      if (direction == 0) {
        this.y = ((this.y - 1) + canvas34.height) % canvas34.height;
      }
      else if (direction == 1) {
        this.x = (this.x + 1) % canvas34.width;
        this.y = ((this.y - 1) + canvas34.height) % canvas34.height;
      }
      else if (direction == 2) {
        this.x = (this.x + 1) % canvas34.width;
      }
      else if (direction == 3) {
        this.x = (this.x + 1) % canvas34.width;
        this.y = (this.y + 1) % canvas34.height;
      }
      else if (direction == 4) {
        this.y = (this.y + 1) % canvas34.height;
      }
      else if (direction == 5) {
        this.x = ((this.x - 1) + canvas34.width) % canvas34.width;
        this.y = (this.y + 1) % canvas34.height;
      }
      else if (direction == 6) {
        this.x = ((this.x - 1) + canvas34.width) % canvas34.width;
      }
      else {
        this.x = ((this.x - 1) + canvas34.width) % canvas34.width;
        this.y = ((this.y - 1) + canvas34.height) % canvas34.height;
      }
      
      this.r += Math.random() * randSign();
      this.g += Math.random() * randSign();
      this.b += Math.random() * randSign();
      
      this.r = (this.r + 255) % 255;
      this.g = (this.g + 255) % 255;
      this.b = (this.b + 255) % 255;
      
      ctx34.fillStyle = `rgba(${this.r}, ${this.g}, ${this.b}, 0.25)`;
      ctx34.fillRect(this.x, this.y, 1, 1);
    }
  };
</script>
<canvas id = "canvas33" style = "background-color: black; border: none"></canvas>
<button onclick = "startCanvas33()">Start/Stop</button>
<button onclick = "IceParticle.running = true; snowflakeArray = []">Reset</button>
<div class = "desc"><b><i>(8/9/2021)</i></b> Brownian Snowflake generator, using 6 Brownian trees reflected around the center and made symmetrical. It works well enough, but I want it to look like the results from <a href = "https://codegolf.stackexchange.com/questions/42506/draw-a-snowflake">https://codegolf.stackexchange.com/questions/42506/draw-a-snowflake</a>, as well as constrain it within a 30&deg; wedge per tree.<br><b><i><mark>Actually finished! (8/16/2021)</mark> Moved to <a href = "snowflake.html" target = "_blank">snowflake.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx33 = canvas33.getContext("2d");
  canvas33.width = canvas33.height = 1000;
  let canvas33Running = false;
  
  let snowflakeArray = [];
  let snowflakeSymmetry = 6;
  let snowflakeAngle = (Math.PI * 2) / snowflakeSymmetry;
  let maxSnowflakeSize = 400;
  let snowflakeThickness = 8;
  let snowflakeOpacity = 0.5;
  let snowflakeHue = 240;
  
  function rotatePoint(x, y, cx, cy, angle) {
    let tempX = x - cx;
    let tempY = y - cy;
    let rx = (tempX * Math.cos(angle)) - (tempY * Math.sin(angle));
    let ry = (tempX * Math.sin(angle)) + (tempY * Math.cos(angle));
    return {x: rx + cx, y: ry + cy};
  }
  
  let IceParticle = {};
  IceParticle.x = 0;
  IceParticle.y = 0;
  IceParticle.speedY = 5;
  IceParticle.speedX = 2;
  IceParticle.radius = 4;
  IceParticle.stickiness = 0.3;
  IceParticle.stepsPerFrame = 500;
  IceParticle.running = true;
  IceParticle.resetPos = function() {
    this.x = canvas33.width;
    //this.y = canvas33.height / 2;
    this.y = (canvas33.height / 2) + ((canvas33.width / 2) * Math.sin(Math.random() * snowflakeAngle));
  };
  IceParticle.walk = function() {
    if (!this.running) return;
    for (let j = 0; j < this.stepsPerFrame; j++) {
      this.x -= Math.random() * this.speedX;
      this.y += Math.random() * this.speedY * randSign();
      
      let relativeY = this.y - (canvas33.height / 2);
      let relativeX = this.x - (canvas33.width / 2);
      let currentMaxHeight = Math.sin(snowflakeAngle) * relativeX;
      if (relativeY >= currentMaxHeight || relativeY <= 0) {
        //this.y = canvas33.height / 2;
        this.y = (canvas33.height / 2) + ((relativeY + currentMaxHeight) % currentMaxHeight);
      }
      /*if (relativeY < 0) {
        this.y = currentMaxHeight + (canvas33.height / 2);
      }*/
      
      for (let i = 0; i < snowflakeArray.length; i++) {
        let distX = this.x - snowflakeArray[i].x;
        let distY = this.y - snowflakeArray[i].y;
        let distSq = (distX * distX) + (distY * distY);
        if (distSq <= 4 * this.radius * this.radius && Math.floor(Math.random() * (1 / this.stickiness)) == 0) {
          if (this.x < canvas33.width - (this.radius * 2)) {
            snowflakeArray.push({x: this.x, y: this.y});
            this.resetPos();
          }
          else {
            this.running = false;
            return;
          }
        }
      }
      if (this.x <= canvas33.width / 2) {
        snowflakeArray.push({x: this.x, y: this.y});
        this.resetPos();
      }
    }
    
    ctx33.fillStyle = "white";
    ctx33.fillCircle(this.x, this.y, IceParticle.radius);
  };
  
  
  function frame33() {
    ctx33.clearRect(0, 0, canvas33.width, canvas33.height);
    
    snowflakeAngle = (Math.PI * 2) / snowflakeSymmetry;
    
    IceParticle.walk();
    
    if (snowflakeArray.length >= maxSnowflakeSize) {
      snowflakeArray.length = maxSnowflakeSize;
      IceParticle.running = false;
    }
    
    for (let i = 0; i < snowflakeArray.length; i++) {
      ctx33.fillStyle = `hsla(${snowflakeHue}deg, 100%, ${100 - ((i / snowflakeArray.length) * 30)}%, ${snowflakeOpacity})`;
      for (let j = 0; j < snowflakeSymmetry; j++) {
        let rotatedPoint = rotatePoint(snowflakeArray[i].x, snowflakeArray[i].y, canvas33.width / 2, canvas33.height / 2, j * snowflakeAngle);
        let yOffset = (canvas33.height / 2) - rotatedPoint.y;
        ctx33.fillCircle(rotatedPoint.x, rotatedPoint.y, snowflakeThickness);
        ctx33.fillCircle(rotatedPoint.x, (canvas33.height / 2) + yOffset, snowflakeThickness);
      }
      
      //let yOffset = (canvas33.height / 2) - snowflakeArray[i].y;
      //console.log(yOffset);
      //ctx33.fillCircle(snowflakeArray[i].x, snowflakeArray[i].y, IceParticle.radius);
      //ctx33.fillCircle(snowflakeArray[i].x, (canvas33.height / 2) + yOffset, IceParticle.radius);
    }
    
    if (canvas33Running) requestAnimationFrame(frame33);
  }
  IceParticle.resetPos();
  frame33();
  
  function startCanvas33() {
    if (canvas33Running) canvas33Running = false;
    else {
      canvas33Running = true;
      frame33();
    }
  }
</script>
<canvas id = "canvas32" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas32()">Start/Stop</button>
<div class = "desc"><b><i>(8/8/2021)</i></b> DLA Brownian Tree, but aligned to a grid, and with changeable stickiness.</div>
<hr><hr>
<script>
  const ctx32 = canvas32.getContext("2d");
  canvas32.width = canvas32.height = 1000;
  let canvas32Running = false;
  
  let pxGridSize = 100;
  let pxTileSize = canvas32.width / pxGridSize;
  let pxStickiness = 1;
  
  let pxArray = [{x: Math.floor(pxGridSize / 2), y: Math.floor(pxGridSize / 2)}];
  
  let PxWalker = {};
  PxWalker.x = 0;
  PxWalker.y = 0;
  PxWalker.stepsPerTick = 10000;
  PxWalker.walk = function() {
    for (let j = 0; j < this.stepsPerTick; j++) {
      let dir = Math.floor(Math.random() * 4);
      if (dir == 0) this.y--;
      else if (dir == 1) this.x++;
      else if (dir == 2) this.y++;
      else this.x--;
      this.x = this.x.clamp(0, pxGridSize);
      this.y = this.y.clamp(0, pxGridSize);
      for (let i = 0; i < pxArray.length; i++) {
        let distX = Math.abs(this.x - pxArray[i].x);
        let distY = Math.abs(this.y - pxArray[i].y);
        if ((distX <= 1 && distY == 0) || (distY <= 1 && distX == 0)) { // Points connect at sides
        //if (distX == 1 && distY == 1) { // Points connect at diagonals
        //if (distX <= 1 && distY <= 1) { // Points connect at sides and diagonals
          if (Math.floor(Math.random() * (1 / pxStickiness)) == 0) {
            if (this.x != pxArray[i].x || this.y != pxArray[i].y) pxArray.push({x: this.x, y: this.y});
            this.resetPos();
          }
        }
      }
      if (pxArray.length >= 1000) return;
    }
    ctx32.fillRect(this.x * pxTileSize, this.y * pxTileSize, pxTileSize, pxTileSize);
  };
  PxWalker.resetPos = function() {
    let r = Math.floor(Math.random() * 4);
    if (r == 0) {
      this.x = Math.round(Math.random() * pxGridSize);
      this.y = 0;
    }
    else if (r == 1) {
      this.x = pxGridSize;
      this.y = Math.round(Math.random() * pxGridSize);
    }
    else if (r == 2) {
      this.x = Math.round(Math.random() * pxGridSize);
      this.y = pxGridSize;
    }
    else {
      this.x = 0;
      this.y = Math.round(Math.random() * pxGridSize);
    }
  };
  
  function frame32() {
    ctx32.clearRect(0, 0, canvas32.width, canvas32.height);
    
    PxWalker.walk();
    
    for (let i = 0; i < pxArray.length; i++) {
      ctx32.fillRect(pxArray[i].x * pxTileSize, pxArray[i].y * pxTileSize, pxTileSize, pxTileSize);
      //ctx32.fillCircle(pxArray[i].x * pxTileSize, pxArray[i].y * pxTileSize, pxTileSize / 2);
    }
    
    if (canvas32Running) requestAnimationFrame(frame32);
  }
  frame32();
  
  function startCanvas32() {
    if (canvas32Running) canvas32Running = false;
    else {
      canvas32Running = true;
      frame32();
    }
  }
</script>
<canvas id = "canvas31"></canvas>
<div><b><u>M:</u></b> <span id = "constantsmTxt">1</span></div>
<input type = "range" min = "0" max = "10" step = "1" value = "1" id = "constantsmRange" oninput = "updateSettings31()">
<div><b><u>N1:</u></b> <span id = "constantsn1Txt">1</span></div>
<input type = "range" min = "0" max = "5" step = "0.1" value = "1" id = "constantsn1Range" oninput = "updateSettings31()">
<div><b><u>N2:</u></b> <span id = "constantsn2Txt">1</span></div>
<input type = "range" min = "0" max = "5" step = "0.1" value = "1" id = "constantsn2Range" oninput = "updateSettings31()">
<div><b><u>N3:</u></b> <span id = "constantsn3Txt">1</span></div>
<input type = "range" min = "0" max = "5" step = "0.1" value = "1" id = "constantsn3Range" oninput = "updateSettings31()">
<div><b><u>A:</u></b> <span id = "constantsaTxt">100</span></div>
<input type = "range" min = "10" max = "200" step = "10" value = "100" id = "constantsaRange" oninput = "updateSettings31()">
<div><b><u>B:</u></b> <span id = "constantsbTxt">100</span></div>
<input type = "range" min = "10" max = "200" step = "10" value = "100" id = "constantsbRange" oninput = "updateSettings31()">
<div class = "desc"><b><i>(8/8/2021)</i></b> Supershape grapher, based on the supershape equation from <a href = "http://paulbourke.net/geometry/supershape" target = "_blank">http://paulbourke.net/geometry/supershape</a>. It works correctly, but it's pretty boring and I can't figure out what to do with it.</div>
<hr><hr>
<script>
  const ctx31 = canvas31.getContext("2d");
  canvas31.width = canvas31.height = 1000;
  
  let Constants = {
    n1: 1,
    n2: 1,
    n3: 1,
    m: 1,
    a: 100,
    b: 100
  };
  
  function calculateSuperShape(theta) {
    return 1 / Math.pow(Math.pow(Math.abs((1 / Constants.a) * Math.cos((Constants.m / 4) * theta)), Constants.n2) + Math.pow(Math.abs((1 / Constants.b) * Math.sin((Constants.m / 4) * theta)), Constants.n3), 1 / Constants.n1);
  }
  
  function drawSuperShape() {
    ctx31.clearRect(0, 0, canvas31.width, canvas31.height);
    ctx31.lineWidth = 2;
    ctx31.beginPath();
    let r = calculateSuperShape(0);
    ctx31.moveTo((canvas31.width / 2) + r, canvas31.height / 2);
    for (let i = 0; i <= 720; i += 0.5) {
      r = calculateSuperShape(toRad(i));
      ctx31.lineTo((canvas31.width / 2) + Math.cos(toRad(i)) * r, (canvas31.height / 2) + Math.sin(toRad(i)) * r);
    }
    ctx31.stroke();
  }
  drawSuperShape();
  
  function updateSettings31() {
    Constants.n1 = constantsn1Txt.innerHTML = Number(constantsn1Range.value);
    Constants.n2 = constantsn2Txt.innerHTML = Number(constantsn2Range.value);
    Constants.n3 = constantsn3Txt.innerHTML = Number(constantsn3Range.value);
    Constants.m = constantsmTxt.innerHTML = Number(constantsmRange.value);
    Constants.a = constantsaTxt.innerHTML = Number(constantsaRange.value);
    Constants.b = constantsbTxt.innerHTML = Number(constantsbRange.value);
    drawSuperShape();
  }
</script>
<canvas id = "canvas30" style = "height: 200px; width: 750px"></canvas>
<button onclick = "walkGridWalkers()">Go</button>
<br><br>
<div><b><u>Number of Walkers:</u></b> <span id = "startingGridWalkersTxt">50</span></div>
<input type = "range" min = "5" max = "100" step = "5" value = "50" id = "startingGridWalkersRange" oninput = "updateSettings30()">
<br><br>
<div><b><u>Walker Step Height:</u></b> <span id = "gridWalkerStepHeightTxt">2</span>px</div>
<input type = "range" min = "1" max = "20" step = "1" value = "2" id = "gridWalkerStepHeightRange" oninput = "updateSettings30()">
<div class = "desc"><b><i>(8/8/2021)</i></b> Random walker variation where the walkers all start at the same point and walk in a straight line, moving either up or down each step.<br><b><i>(8/18/2021)</i></b> Added sliders.</div>
<hr><hr>
<script>
  const ctx30 = canvas30.getContext("2d");
  canvas30.width = 1500;
  canvas30.height = 400;
  
  let startingGridWalkers = 50;
  let gridWalkerStepHeight = 2;
  
  let gridWalkerColor = "black";
  let gridWalkerSize = 1;
  let gridWalkerOpacity = 0.5;
  
  function GridWalker() {
    this.y = Math.floor(canvas30.height / 2);
    this.yArray = [this.y];
  }
  GridWalker.prototype.walk = function() {
    for (let i = 0; i < canvas30.width; i++) {
      let dir = Math.floor(Math.random() * 3);
      if (dir == 0) this.y += Math.ceil(Math.random() * gridWalkerStepHeight);
      else if (dir == 1) this.y -= Math.ceil(Math.random() * gridWalkerStepHeight);
      this.yArray.push(this.y);
    }
    ctx30.strokeStyle = gridWalkerColor;
    ctx30.lineWidth = gridWalkerSize;
    ctx30.globalAlpha = gridWalkerOpacity;
    ctx30.beginPath();
    for (let i = 0; i < this.yArray.length; i++) {
      ctx30.lineTo(i, this.yArray[i]);
      //ctx30.fillRect(i, this.yArray[i], gridWalkerSize, gridWalkerSize);
    }
    ctx30.stroke();
    ctx30.globalAlpha = 1;
  };
  let gridWalkerArray = [];
  for (let i = 0; i < startingGridWalkers; i++) gridWalkerArray.push(new GridWalker());
  
  function reset30() {
    ctx30.clearRect(0, 0, canvas30.width, canvas30.height);
    while (gridWalkerArray.length < startingGridWalkers) gridWalkerArray.push(new GridWalker());
    while (gridWalkerArray.length > startingGridWalkers) gridWalkerArray.pop();
    for (let i = 0; i < gridWalkerArray.length; i++) {
      gridWalkerArray[i].y = Math.floor(canvas30.height / 2);
      gridWalkerArray[i].yArray = [gridWalkerArray[i].y];
    }
  }
  
  function walkGridWalkers() {
    reset30();
    for (let i = 0; i < gridWalkerArray.length; i++) {
      gridWalkerArray[i].walk();
    }
  }
  walkGridWalkers();
  
  function updateSettings30() {
    startingGridWalkers = startingGridWalkersTxt.innerHTML = Number(startingGridWalkersRange.value);
    gridWalkerStepHeight = gridWalkerStepHeightTxt.innerHTML = Number(gridWalkerStepHeightRange.value);
    
    walkGridWalkers();
  }
</script>
<canvas id = "canvas29" style = "width: 400px; height: 400px"></canvas>
<br><br>
<button onclick = "PixWalker.walk(100000); drawPixels29()">100 Thousand Iterations</button>
<button onclick = "reset29()">Reset</button>
<br><br>
<div><b><u>Pixel Hue:</u></b> <span id = "pixelHueTxt">0</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "15" value = "0" id = "pixelHueRange" oninput = "updateSettings29()">
<div class = "desc"><b><i>(8/6/2021)</i></b> Random walker shading a plane, from <a href = "http://paulbourke.net/fractals/randomwalk" target = "_blank">http://paulbourke.net/fractals/randomwalk</a>.<br><b><i><mark>Actually finished! (8/6/2021)</mark> Moved to <a href = "walker.html" target = "_blank">walker.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx29 = canvas29.getContext("2d");
  canvas29.width = canvas29.height = 500//300;
  
  let pixelIntensity = 3//50000//40000;
  let pixelHue = 0;
  let rainbowPixels = false;
  
  let pixelArray29 = [];
  for (let x = 0; x < canvas29.width; x++) {
    let row = [];
    for (let y = 0; y < canvas29.height; y++) {
      row.push(0);
    }
    pixelArray29.push(row);
  }
  
  let PixWalker = {};
  PixWalker.x = Math.floor(canvas29.width / 2);
  PixWalker.y = Math.floor(canvas29.height / 2);
  PixWalker.iterations = 0;
  PixWalker.walk = function(n) {
    for (let i = 0; i < n; i++) {
      this.iterations++;
      let direction = Math.floor(Math.random() * 8);
      if (direction == 0) this.y = ((this.y - 1) + canvas29.height) % canvas29.height;
      else if (direction == 1) {
        this.x = (this.x + 1) % canvas29.width;
        this.y = ((this.y - 1) + canvas29.height) % canvas29.height;
      }
      else if (direction == 2) this.x = (this.x + 1) % canvas29.width;
      else if (direction == 3) {
        this.x = (this.x + 1) % canvas29.width;
        this.y = (this.y + 1) % canvas29.height;
      }
      else if (direction == 4) this.y = (this.y + 1) % canvas29.height;
      else if (direction == 5) {
        this.x = ((this.x - 1) + canvas29.width) % canvas29.width;
        this.y = (this.y + 1) % canvas29.height;
      }
      else if (direction == 6) this.x = ((this.x - 1) + canvas29.width) % canvas29.width;
      else {
        this.x = ((this.x - 1) + canvas29.width) % canvas29.width;
        this.y = ((this.y - 1) + canvas29.height) % canvas29.height;
      }
      pixelArray29[this.x][this.y]++;
    }
  };
  
  function drawPixels29() {
    ctx29.clearRect(0, 0, canvas29.width, canvas29.height);
    let highestWeight = 0;
    for (let x = 0; x < canvas29.width; x++) {
      for (let y = 0; y < canvas29.height; y++) {
        if (pixelArray29[x][y] > highestWeight) highestWeight = pixelArray29[x][y];
      }
    }
    for (let x = 0; x < canvas29.width; x++) {
      for (let y = 0; y < canvas29.height; y++) {
        let brightness = 100 - /*100 - */((pixelArray29[x][y] / highestWeight) * 100 * pixelIntensity);
        ctx29.fillStyle = `hsl(${rainbowPixels ? pixelHue + ((x / canvas29.width) * 360) : pixelHue}deg, 100%, ${brightness}%)`;//${brightness >= 50 ? 100 : 0}%)`;
        ctx29.fillRect(x, y, 1, 1);
      }
    }
  }
  
  function reset29() {
    ctx29.clearRect(0, 0, canvas29.width, canvas29.height);
    pixelArray29 = [];
    for (let x = 0; x < canvas29.width; x++) {
      let row = [];
      for (let y = 0; y < canvas29.height; y++) {
        row.push(0);
      }
      pixelArray29.push(row);
    }
    PixWalker.x = Math.floor(canvas29.width / 2);
    PixWalker.y = Math.floor(canvas29.height / 2);
    PixWalker.iterations = 0;
  }
  
  function updateSettings29() {
    pixelHue = pixelHueTxt.innerHTML = Number(pixelHueRange.value);
    drawPixels29();
  }
</script>
<canvas id = "canvas28"></canvas>
<br><br>
<button onclick = "addLine(); shadePixels()">Add Line</button>
<br><br>
<div class = "desc"><b><i>(8/5/2021)</i></b> An attempt to replicate the fractal planar design from <a href = "http://paulbourke.net/fractals/noise" target = "_blank">http://paulbourke.net/fractals/noise</a>, which I couldn't get to work properly.</div>
<hr><hr>
<script>
  const ctx28 = canvas28.getContext("2d");
  canvas28.width = canvas28.height = 100;
  
  function Line(slope, yInt) {
    this.slope = slope;
    this.yInt = yInt;
  }
  Line.prototype.calculate = function(x) {
    return (this.slope * x) + this.yInt;
  };
  Line.prototype.draw = function() {
    ctx28.moveTo(-canvas28.width, this.calculate(-canvas28.width));
    ctx28.lineTo(canvas28.width, this.calculate(canvas28.width));
    ctx28.stroke();
  };
  let linesArray = [];
  let pixelsPlane = [];
  for (let x = 0; x < canvas28.width; x++) {
    let row = [];
    for (let y = 0; y < canvas28.height; y++) {
      row.push(0);
    }
    pixelsPlane.push(row);
  }
  
  function addLine() {
    let p1 = {x: Math.random() * canvas28.width, y: Math.random() * canvas28.height};
    let p2 = {x: Math.random() * canvas28.width, y: Math.random() * canvas28.height};
    let slope = (p2.y - p1.y) / (p2.x - p1.x);
    let yInt = -slope * p1.x + p1.y;
    linesArray.push(new Line(slope, yInt));
  }
  
  function shadePixels() {
    ctx28.clearRect(0, 0, canvas28.width, canvas28.height);
    /*for (let i = 0; i < linesArray.length; i++) {
      for (let x = 0; x < canvas28.width; x++) {
        for (let y = 0; y < canvas28.height; y++) {
          if (linesArray.calculate(x) < y) pixelsPlane[x][y]++;
          else pixelsPlane[x][y]--;
        }
      }
    }*/
    for (let x = 0; x < canvas28.width; x++) {
      for (let y = 0; y < canvas28.width; y++) {
        let weight = linesArray.length;
        for (let i = 0; i < linesArray.length; i++) {
          if (linesArray[i].calculate(x) < y) weight += Math.sign(linesArray[i].slope);
          else weight -= Math.sign(linesArray[i].slope);
        }
        ctx28.fillStyle = `hsl(0deg, 0%, ${(weight / (linesArray.length * 2)) * 100}%)`;
        ctx28.fillRect(x, y, 1, 1);
      }
    }
  }
</script>
<canvas id = "canvas27" style = "background-color: black"></canvas>
<button onclick = "startCanvas27()">Start/Stop</button>
<div class = "desc"><b><i>(8/4/2021)</i></b> Spring force simulation, clearly not working.</div>
<hr><hr>
<script>
  const ctx27 = canvas27.getContext("2d");
  canvas27.width = canvas27.height = 300;
  let canvas27Running = false;
  
  let Spring = {
    anchor: {
      x: canvas27.width / 2,
      y: 0
    },
    bob: {
      x: canvas27.width / 2,
      y: 200
    },
    restLength: 150,
    currLength: 200,
    constant: 0.05,
    velocity: {
      x: 0,
      y: 0
    },
    gravity: 1
  };
  
  Spring.render = function() {
    let displacementX = this.bob.x - this.anchor.x - this.restLength;
    let displacementY = this.bob.y - this.anchor.y - this.restLength;
    let angle = Math.atan2(displacementY, displacementX);
    let displacement = Math.hypot(displacementX, displacementY);
    let force = -this.constant * displacement;
    let forceX = force * Math.cos(angle);
    let forceY = force * Math.sin(angle);
    this.velocity.x += forceX;
    this.velocity.y += forceY;
    this.bob.x += this.velocity.x;
    this.bob.y += this.velocity.y;
    ctx27.fillStyle = "lightblue";
    ctx27.lineWidth = 3;
    ctx27.strokeStyle = "white";
    ctx27.beginPath();
    ctx27.moveTo(this.anchor.x, this.anchor.y);
    ctx27.lineTo(this.bob.x, this.bob.y);
    ctx27.stroke();
    ctx27.fillCircle(this.anchor.x, this.anchor.y, 5);
    ctx27.strokeCircle(this.anchor.x, this.anchor.y, 5);
    ctx27.fillCircle(this.bob.x, this.bob.y, 5);
    ctx27.strokeCircle(this.bob.x, this.bob.y, 5);
  };
  
  function frame27() {
    ctx27.clearRect(0, 0, canvas27.width, canvas27.height);
    
    Spring.render();
    
    if (canvas27Running) requestAnimationFrame(frame27);
  }
  frame27();
  
  function startCanvas27() {
    if (canvas27Running) canvas27Running = false;
    else {
      canvas27Running = true;
      frame27();
    }
  }
</script>
<canvas id = "canvas26"></canvas>
<button onclick = "startCanvas26()">Start/Stop</button>
<div><b><u>Number of Metaballs:</u></b> <span id = "metaballCountTxt">10</span></div>
<input type = "range" min = "2" max = "50" step = "1" value = "10" id = "metaballCountRange" oninput = "updateMetaballSettings()">
<br>
<div><b><u>Metaball Hue:</u></b> <span id = "metaballHueTxt">0</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "30" value = "0" id = "metaballHueRange" oninput = "updateMetaballSettings()">
<br>
<div><b><u>Metaball Radius:</u></b> <span id = "metaballRadiusTxt">1000</span></div>
<input type = "range" min = "200" max = "1500" step = "100" value = "1000" id = "metaballRadiusRange" oninput = "updateMetaballSettings()">
<div class = "desc"><b><i>(8/1/2021)</i></b> Metaballs!<br><b><i><mark>Actually finished! (8/2/2021)</mark> Moved to <a href = "metaballs.html" target = "_blank">metaballs.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx26 = canvas26.getContext("2d");
  canvas26.width = canvas26.height = 100;
  let canvas26Running = false;
  let canvas26Ratio = canvas26.width / 300;
  let canvas26Rect = canvas26.getBoundingClientRect();
  
  let metaballHue = 0;
  let metaballCount = 10;
  
  function Metaball(x, y, radius, angle, velocity) {
    this.radius = radius ?? 1000;
    this.x = x ?? Math.random() * canvas26.width;
    this.y = y ?? Math.random() * canvas26.height;
    this.angle = angle ?? Math.random() * 360;
    this.velocity = velocity ?? 3;
  }
  Metaball.prototype.render = function() {
    this.angle += Math.random() * 10 * randSign();
    this.x += this.velocity * Math.cos(toRad(this.angle));
    this.y += this.velocity * Math.sin(toRad(this.angle));
    
    if (this.x >= canvas26.width) {
      this.x = canvas26.width;
      this.angle = (90 - this.angle) * 2;
    }
    if (this.x <= 0) {
      this.x = 0;
      this.angle = (180 - this.angle);
    }
    if (this.y >= canvas26.height) {
      this.y = canvas26.height;
      this.angle = 360 - this.angle;
    }
    if (this.y <= 0) {
      this.y = 0;
      this.angle = 360 - this.angle;
    }
    
    //ctx26.strokeStyle = "black";
    //ctx26.strokeCircle(this.x, this.y, this.radius);
  };
  let metaballArray = [];
  for (let i = 0; i < metaballCount; i++) metaballArray.push(new Metaball());
  
  function metaballColor(x, y) {
    let distToMetaballs = 0;
    for (let i = 0; i < metaballArray.length; i++) {
      distToMetaballs += metaballArray[i].radius / Math.hypot(x - metaballArray[i].x, y - metaballArray[i].y);
    }
    return `hsl(${metaballHue + distToMetaballs.clamp(0, 360)}deg, 100%, 50%)`;
    //return `hsl(0deg, 100%, ${distToMetaballs}%)`;
    //return `hsl(0deg, ${distToMetaballs}%, 50%)`;
  }
  
  function loadMetaballColors() {
    for (let x = 0; x < canvas26.width; x++) {
      for (let y = 0; y < canvas26.height; y++) {
        ctx26.fillStyle = metaballColor(x, y);
        ctx26.fillRect(x, y, 1, 1);
      }
    }
  }
    
  function frame26() {
    //ctx26.clearRect(0, 0, canvas26.width, canvas26.height);
    //ctx26.globalAlpha = 0.3;
    
    loadMetaballColors();
    
    for (let i = 0; i < metaballArray.length; i++) metaballArray[i].render();
    
    if (canvas26Running) requestAnimationFrame(frame26);
  }
  frame26();
  
  function startCanvas26() {
    if (canvas26Running) canvas26Running = false;
    else {
      canvas26Running = true;
      frame26();
    }
  }
  
  function updateMetaballSettings() {
    metaballHueTxt.innerHTML = metaballHue = Number(metaballHueRange.value);
    metaballRadiusTxt.innerHTML = metaballRadiusRange.value;
    metaballCount = metaballCountTxt.innerHTML = Number(metaballCountRange.value);
    while (metaballArray.length < metaballCount) metaballArray.push(new Metaball());
    while (metaballArray.length > metaballCount) metaballArray.pop();
    metaballArray.map(x => x.radius = Number(metaballRadiusRange.value));
    
    if (!canvas26Running) loadMetaballColors();
  }
  
  canvas26.addEventListener("mousedown", e => {
    canvas26Rect = canvas26.getBoundingClientRect();
    for (let i = 0; i < metaballArray.length; i++) {
      metaballArray[i].x = canvas26Ratio * (e.clientX - canvas26Rect.left);
      metaballArray[i].y = canvas26Ratio * (e.clientY - canvas26Rect.top);
      metaballArray[i].angle = (i / metaballArray.length) * 360;
    }
    //metaballArray.push(new Metaball(canvas26Ratio * (e.clientX - canvas26Rect.left), canvas26Ratio * (e.clientY - canvas26Rect.top)));
  });
</script>
<canvas id = "canvas25" style = "background-color: black"></canvas>
<button onclick = "startCanvas25()">Start/Stop</button>
<button onclick = "reset25()">Reset</button>
<div class = "desc"><b><i>(8/1/2021)</i></b> Phyllotaxis spiral generator, mimicing leaf patterns on plants.<br><b><i>(8/22/2021)</i></b> Added different settings and improved the visual to be more like a plant.</div>
<hr><hr>
<script>
  const ctx25 = canvas25.getContext("2d");
  canvas25.width = canvas25.height = 500;
  let canvas25Running = false;
  
  let leaves = 0;
  let leafAngle = 137.5;//306.71
  let leafScale = 6;
  let leafRadius = 6;
  let leafExponent = 0.5;
  let leafSizeRatio = 1 / 50;
  let leafJitter = 3;
  
  function frame25() {
    for (let i = 0; i < 5; i++) {
      ctx25.globalCompositeOperation = "destination-over";
      let a = toRad(leaves * leafAngle);
      let r = Math.pow(leaves, leafExponent) * leafScale;
      if (r >= canvas25.width * 0.5 * Math.SQRT2) break;
      ctx25.fillStyle = `hsl(${randBetween(100, 140)}deg, 100%, ${randBetween(25, 75)}%)`;//`hsl(${leaves / 10}deg, 100%, 50%)`;
      ctx25.strokeStyle = "black";
      ctx25.lineWidth = 3;
      let leafX = Math.cos(a) * r + randBetween(-leafJitter, leafJitter);
      let leafY = Math.sin(a) * r + randBetween(-leafJitter, leafJitter);
      ctx25.fillCircle((canvas25.width / 2) + leafX, (canvas25.height / 2) + leafY, leafRadius * (1 + (leaves * leafSizeRatio)));
      ctx25.strokeCircle((canvas25.width / 2) + leafX, (canvas25.height / 2) + leafY, leafRadius * (1 + (leaves * leafSizeRatio)));
      
      leaves++;
    }
    
    if (canvas25Running) requestAnimationFrame(frame25);
  }
  frame25();
  
  function startCanvas25() {
    if (canvas25Running) canvas25Running = false;
    else {
      canvas25Running = true;
      frame25();
    }
  }
  
  function reset25() {
    ctx25.clearRect(0, 0, canvas25.width, canvas25.height);
    leaves = 0;
    if (!canvas25Running) frame25();
  }
</script>
<canvas id = "canvas24"></canvas>
<button onclick = "startCanvas24()">Start/Stop</button>
<div class = "desc"><b><i>(7/31/2021)</i></b> Reaction diffusion simulation using <a href = "https://www.youtube.com/watch?v=BV9ny785UNc" target = "_blank">this</a> Coding Train video as a reference. For some reason it just completely doesn't work.</div>
<hr><hr>
<script>
  const ctx24 = canvas24.getContext("2d");
  canvas24.width = canvas24.height = 300;
  let canvas24Running = false;
  
  let reactGridWidth = 100;
  let reactGridHeight = 100;
  
  let diffusionA = 1;
  let diffusionB = 0.5;
  let feedRate = 0.055;
  let killRate = 0.062;
  let reactSpeed = 1;
  
  let reactGrid = [];
  let nextReactGrid = [];
  for (let x = 0; x < reactGridWidth; x++) {
    let row = [];
    for (let y = 0; y < reactGridHeight; y++) {
      row.push({a: 1, b: 0});
    }
    reactGrid.push(row);
    nextReactGrid.push(row);
  }
  for (let x = 10; x < 20; x++) {
    for (let y = 10; y < 20; y++) {
      reactGrid[x][y].b = 1;
    }
  }
  
  function diffuseCell(x, y) {
    let totalA = 0;
    totalA += reactGrid[x][y].a * -1;
    totalA += reactGrid[x][y - 1].a * 0.2;
    totalA += reactGrid[x + 1][y].a * 0.2;
    totalA += reactGrid[x][y + 1].a * 0.2;
    totalA += reactGrid[x - 1][y].a * 0.2;
    totalA += reactGrid[x + 1][y - 1].a * 0.05;
    totalA += reactGrid[x + 1][y + 1].a * 0.05;
    totalA += reactGrid[x - 1][y + 1].a * 0.05;
    totalA += reactGrid[x - 1][y - 1].a * 0.05;
    
    let totalB = 0;
    totalB += reactGrid[x][y].b * -1;
    totalB += reactGrid[x][y - 1].b * 0.2;
    totalB += reactGrid[x + 1][y].b * 0.2;
    totalB += reactGrid[x][y + 1].b * 0.2;
    totalB += reactGrid[x - 1][y].b * 0.2;
    totalB += reactGrid[x + 1][y - 1].b * 0.05;
    totalB += reactGrid[x + 1][y + 1].b * 0.05;
    totalB += reactGrid[x - 1][y + 1].b * 0.05;
    totalB += reactGrid[x - 1][y - 1].b * 0.05;
    
    return {a: totalA, b: totalB};
    /*let totalA = 0;
    totalA += reactGrid[x][y].a * -1; // Middle middle
    totalA += reactGrid[x][((y + reactGridHeight) - 1) % reactGridHeight].a * 0.2; // Top middle
    totalA += reactGrid[(x + 1) % reactGridHeight][((y + reactGridHeight) - 1) % reactGridHeight].a * 0.05; // Top right
    totalA += reactGrid[(x + 1) % reactGridHeight][y].a * 0.2; // Middle right
    totalA += reactGrid[(x + 1) % reactGridHeight][(y + 1) % reactGridHeight].a * 0.05; // Bottom right
    totalA += reactGrid[x][(y + 1) % reactGridHeight].a * 0.2; // Bottom middle
    totalA +=  reactGrid[((x + reactGridWidth) - 1) % reactGridWidth][(y + 1) % reactGridHeight].a * 0.05; // Bottom left
    totalA += reactGrid[((x + reactGridWidth) - 1) % reactGridWidth][y].a * 0.2; // Middle left
    totalA = reactGrid[((x + reactGridWidth) - 1) % reactGridWidth][((y + reactGridHeight) - 1) % reactGridHeight].a * 0.05; // Top left
    
    let totalB = 0;
    totalB += reactGrid[x][y].b * -1; // Middle middle
    totalB += reactGrid[x][((y + reactGridHeight) - 1) % reactGridHeight].b * 0.2; // Top middle
    totalB += reactGrid[(x + 1) % reactGridHeight][((y + reactGridHeight) - 1) % reactGridHeight].b * 0.05; // Top right
    totalB += reactGrid[(x + 1) % reactGridHeight][y].b * 0.2; // Middle right
    totalB += reactGrid[(x + 1) % reactGridHeight][(y + 1) % reactGridHeight].b * 0.05; // Bottom right
    totalB += reactGrid[x][(y + 1) % reactGridHeight].b * 0.2; // Bottom middle
    totalB +=  reactGrid[((x + reactGridWidth) - 1) % reactGridWidth][(y + 1) % reactGridHeight].b * 0.05; // Bottom left
    totalB += reactGrid[((x + reactGridWidth) - 1) % reactGridWidth][y].b * 0.2; // Middle left
    totalB = reactGrid[((x + reactGridWidth) - 1) % reactGridWidth][((y + reactGridHeight) - 1) % reactGridHeight].b * 0.05; // Top left
    return {a: totalA, b: totalB};*/
  }
  
  function updateReactGrid() {
    nextReactGrid = reactGrid;
    for (let x = 1; x < reactGridWidth - 1; x++) {
      for (let y = 1; y < reactGridHeight - 1; y++) {
        let a = reactGrid[x][y].a;
        let b = reactGrid[x][y].b;
        let laplace = diffuseCell(x, y);
        nextReactGrid[x][y].a =
          (a + 
          (diffusionA * laplace.a) -
          (a * b * b) +
          (feedRate * (1 - a))) * reactSpeed;
        
        nextReactGrid[x][y].b =
          (b +
          (diffusionB * laplace.b) +
          (a * b * b) -
          (b * (killRate + feedRate))) * reactSpeed;
        
        nextReactGrid[x][y].a = nextReactGrid[x][y].a.clamp(0, 1);
        nextReactGrid[x][y].b = nextReactGrid[x][y].b.clamp(0, 1);
      }
    }
    reactGrid = nextReactGrid;
  }
  
  function drawReactGrid() {
    let scaleX = canvas24.width / reactGridWidth;
    let scaleY = canvas24.height / reactGridHeight;
    for (let x = 0; x < reactGridWidth; x++) {
      for (let y = 0; y < reactGridHeight; y++) {
        ctx24.fillStyle = `rgb(${reactGrid[x][y].a * 255},0,${reactGrid[x][y].b * 255})`;
        ctx24.fillRect(x * scaleX, y * scaleY, scaleX, scaleY);
      }
    }
  }
  
  function frame24() {
    ctx24.clearRect(0, 0, canvas24.width, canvas24.height);
    
    updateReactGrid();
    
    drawReactGrid();
    
    if (canvas24Running) requestAnimationFrame(frame24);
  }
  frame24();
  
  function startCanvas24() {
    if (canvas24Running) canvas24Running = false;
    else {
      canvas24Running = true;
      frame24();
    }
  }
</script>
<canvas id = "canvas23" style = "width: 400px; height: 400px; background-color: black"></canvas>
<button onclick = "startCanvas23()">Start/Stop</button>
<br><br>
<div><b>Mode:</b> <span id = "aggTreeModeTxt">0</span></div>
<input type = "range" min = "0" max = "1" step = "1" value = "0" id = "aggTreeModeRange" oninput = "aggTreeMode = aggTreeModeTxt.innerHTML = Number(this.value); resetAggTree()">
<br><br>
<div class = "desc"><b><i><mark>Actually finished! (7/31/2021)</mark> Moved to <a href = "brownian-tree.html" target = "_blank">brownian-tree.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx23 = canvas23.getContext("2d");
  canvas23.width = canvas23.height = 500;
  let canvas23Running = false;
  
  let aggDotRadius = 5//15;
  let aggTreeMode = 0;
  let aggDotStickiness = 1;
  let aggDotRatio = 1//0.9;
  let startingWalkers = 1//200;
  let walkerIterations = 20000//200;
  let maxAggTreeSize = 500;
  let showWalkers = false;
  
  function walkerResetPos() {
    if (aggTreeMode == 0) {
      let r = Math.floor(Math.random() * 4);
      if (r == 0) return {x: Math.random() * canvas23.width, y: 0};
      if (r == 1) return {x: canvas23.width, y: Math.random() * canvas23.height};
      if (r == 2) return {x: Math.random() * canvas23.width, y: canvas23.height};
      return {x: 0, y: Math.random() * canvas23.height};
    }
    else if (aggTreeMode == 1) {
      return {x: Math.random() * canvas23.width, y: 0};
    }
  }
  function resetAggTree() {
    randWalkerArray = [];
    for (let i = 0; i < startingWalkers; i++) randWalkerArray.push(new randWalker());
    aggTree = [];
    if (aggTreeMode == 0) {
      aggTree.push({x: canvas23.width / 2, y: canvas23.height / 2, radius: aggDotRadius});
    }
    else if (aggTreeMode == 1) {
      for (let i = aggDotRadius; i < canvas23.width; i += aggDotRadius * 2) aggTree.push({x: i, y: canvas23.height, radius: aggDotRadius});
    }
  }
  function distSq(x1, y1, x2, y2) {
    return ((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2));
  }
  function randOdds(n) { // 0.1 = 10%, 0.025 = 2.5%
    return Math.floor(Math.random() * (1 / n)) == 0;
  }
  
  let aggTree = [];
  
  function randWalker() {
    let pos = walkerResetPos();
    this.x = pos.x;
    this.y = pos.y;
    this.stuck = false;
    //this.age = 0;
    //this.color = "red";
  }
  randWalker.prototype.render = function() {
    let j = 0;
    while (j < walkerIterations && aggTree.length < maxAggTreeSize) {
      //this.age++;
      //this.color = `hsl(${(this.age / 100000) * 360}deg, 100%, 50%)`;
      let a = Math.random() * Math.PI * 2;
      this.x += Math.cos(a) * aggDotRadius;
      this.y += Math.sin(a) * aggDotRadius;
      this.x = this.x.clamp(0, canvas23.width);
      this.y = this.y.clamp(0, canvas23.height);
      
      this.stuck = false;
      let i = 0;
      while (i < aggTree.length && !this.stuck) {
        if (distSq(this.x, this.y, aggTree[i].x, aggTree[i].y) <= (aggTree[i].radius + (aggTree[i].radius * aggDotRatio)) * (aggTree[i].radius + (aggTree[i].radius * aggDotRatio)) && randOdds(aggDotStickiness)) {
          aggTree.push({x: this.x, y: this.y, radius: aggTree[i].radius * aggDotRatio});
          let pos = walkerResetPos();
          this.x = pos.x;
          this.y = pos.y;
          this.stuck = true;
          this.age = 0;
        }
        i++;
      }
      j++;
    }
    
    if (showWalkers) {
      ctx23.fillStyle = "rgba(0, 0, 255, 0.5)";
      ctx23.fillCircle(this.x, this.y, aggDotRadius);
    }
  };
  let randWalkerArray = [];
  resetAggTree();
  
  function frame23() {
    ctx23.clearRect(0, 0, canvas23.width, canvas23.height);
    
    
    if (aggTree.length < maxAggTreeSize) {
      for (let i = 0; i < randWalkerArray.length; i++) randWalkerArray[i].render();
    }
    
    for (let i = 0; i < aggTree.length; i++) {
      ctx23.fillStyle = `hsl(${i % 360}deg, 100%, 50%)`;
      ctx23.fillCircle(aggTree[i].x, aggTree[i].y, aggTree[i].radius);
      ctx23.strokeStyle = "black";
      ctx23.strokeCircle(aggTree[i].x, aggTree[i].y, aggTree[i].radius);
    }
    
    if (canvas23Running) requestAnimationFrame(frame23);
  }
  frame23();
  
  function startCanvas23() {
    if (canvas23Running) canvas23Running = false;
    else {
      canvas23Running = true;
      frame23();
    }
  }
</script>
<canvas id = "canvas22"></canvas>
<button onclick = "startCanvas22()">Start/Stop</button>
<div class = "desc"><b><i>(7/30/2021)</i></b> An attempt at making smooth turning motions for some sprite movement across the canvas.</div>
<hr><hr>
<script>
  const ctx22 = canvas22.getContext("2d");
  canvas22.width = canvas22.height = 300;
  let canvas22Running = false;
  
  function Cell(x, y, angle, speed, size, color) {
    this.x = x ?? Math.random() * canvas22.width;
    this.y = y ?? Math.random() * canvas22.height;
    this.angle = angle ?? Math.random() * 360;
    this.baseAngle = this.angle;
    this.speed = speed ?? randBetween(0.5, 2);
    this.size = size ?? 10;
    this.color = color ?? (new RGB()).print();
    this.angleInterval = Math.random();
    this.angleIntervalPeriod = Math.round(randBetween(50, 200));
    this.angleIntervalAmplitude = randBetween(30, 90) * randSign();
  }
  Cell.prototype.render = function() {
    this.angleInterval += 1.25 / this.angleIntervalPeriod;
    if (this.angleInterval >= 1.25) {
      this.baseAngle += this.angleIntervalAmplitude;
      this.baseAngle %= 360;
      this.angleInterval = 0;
      this.angleIntervalPeriod = Math.round(randBetween(50, 200));
      this.angleIntervalAmplitude = randBetween(30, 90) * randSign();
    }
    
    this.angle = this.baseAngle + this.angleIntervalAmplitude * Math.sin(this.angleInterval * Math.PI * 2);
    this.x += this.speed * Math.cos(toRad(this.angle));
    this.y += this.speed * Math.sin(toRad(this.angle));
    
    if (this.x >= canvas22.width) {
      this.x = canvas22.width;
      this.baseAngle = (90 - this.baseAngle) * 2;
    }
    if (this.x <= 0) {
      this.x = 0;
      this.baseAngle = (180 - this.baseAngle);
    }
    if (this.y >= canvas22.height) {
      this.y = canvas22.height;
      this.baseAngle = 360 - this.baseAngle;
    }
    if (this.y <= 0) {
      this.y = 0;
      this.baseAngle = 360 - this.baseAngle;
    }
    
    ctx22.fillStyle = this.color;
    ctx22.fillRotatedRectFromCenter(this.x, this.y, this.size * 2, this.size, this.angle);
    ctx22.fillStyle = "white";
    ctx22.fillCircle(this.x + (this.size * Math.cos(toRad(this.angle))), this.y + (this.size * Math.sin(toRad(this.angle))), this.size / 4);
  };
  let cellsArray = [];
  for (let i = 0; i < 10; i++) cellsArray.push(new Cell());
  
  function frame22() {
    ctx22.clearRect(0, 0, canvas22.width, canvas22.height);
    
    for (let i = 0; i < cellsArray.length; i++) cellsArray[i].render();
    
    if (canvas22Running) requestAnimationFrame(frame22);
  }
  frame22();
  
  function startCanvas22() {
    if (canvas22Running) canvas22Running = false;
    else {
      canvas22Running = true;
      frame22();
    }
  }
</script>
<canvas id = "canvas21" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas21()">Start/Stop</button>
<br><br>
<button onclick = "cellArray.forEach(x => x.burst())">Burst All Cells</button>
<button onclick = "cellArray.filter(x => !x.isFood && !x.isVirus).forEach(x => x.dead = true)">Kill All Cells</button>
<button onclick = "addRandomCells(100 - cellArray.filter(x => !x.isFood && !x.isVirus).length)">Add Up To 100 Cells</button>
<button onclick = "addFoodCells(50)">Add 50 Food</button>
<div id = "liveCellsTxt"></div>
<div class = "desc"><b><i>(7/29/2021)</i></b> Agar.io-like game where colored cells move around and if they collide, the bigger cell (or a random one if they're the same size) takes up the mass of the other.</div>
<hr><hr>
<script>
  const ctx21 = canvas21.getContext("2d");
  canvas21.width = canvas21.height = 500;
  let canvas21Running = false;
  
  ctx21.lineWidth = 3;
  
  class Color {
    constructor(type, a, b, c) {
      this.type = type;
      if (this.type == "rgb") {
        this.r = a ?? Math.round(Math.random() * 255);
        this.g = b ?? Math.round(Math.random() * 255);
        this.b = c ?? Math.round(Math.random() * 255);
      }
      else if (this.type == "hsl") {
        this.h = a ?? Math.round(Math.random() * 360);
        this.s = b ?? Math.round(Math.random() * 100);
        this.l = c ?? Math.round(Math.random() * 100);
      }
    }
    
    get print() {
      if (this.type == "rgb") return `rgb(${this.r},${this.g},${this.b})`;
      else if (this.type == "hsl") return `hsl(${this.h}deg,${this.s}%,${this.l}%)`;
    }
    
    randomize() {
      if (this.type == "rgb") {
        this.r = Math.round(Math.random() * 255);
        this.g = Math.round(Math.random() * 255);
        this.b = Math.round(Math.random() * 255);
      }
      else if (this.type == "hsl") {
        this.h = Math.round(Math.random() * 360);
        this.s = Math.round(Math.random() * 100);
        this.l = Math.round(Math.random() * 100);
      }
    }
  }
  
  CanvasRenderingContext2D.prototype.strokePointedStar = function(x, y, innerRadius, outerRadius, points) {
    this.beginPath();
    this.moveTo(x + outerRadius, y);
    for (let i = 0; i < points + 1; i++) {
      let a = i * ((Math.PI * 2) / points);
      let a2 = (i + 0.5) * ((Math.PI * 2) / points);
      this.lineTo(x + (outerRadius * Math.cos(a)), y + (outerRadius * Math.sin(a)));
      this.lineTo(x + (innerRadius * Math.cos(a2)), y + (innerRadius * Math.sin(a2)));
    }
    this.stroke();
  };
  CanvasRenderingContext2D.prototype.fillPointedStar = function(x, y, innerRadius, outerRadius, points) {
    this.beginPath();
    this.moveTo(x + outerRadius, y);
    for (let i = 0; i < points + 1; i++) {
      let a = i * ((Math.PI * 2) / points);
      let a2 = (i + 0.5) * ((Math.PI * 2) / points);
      this.lineTo(x + (outerRadius * Math.cos(a)), y + (outerRadius * Math.sin(a)));
      this.lineTo(x + (innerRadius * Math.cos(a2)), y + (innerRadius * Math.sin(a2)));
    }
    this.fill();
  };
  
  function Cell(x, y, angle, velocity, radius, fillColor, strokeColor, immunity, isFood, isVirus) {
    this.x = x ?? Math.random() * canvas21.width;
    this.y = y ?? Math.random() * canvas21.height;
    this.vx = 0;
    this.vy = 0;
    this.angle = angle ?? Math.random() * 360;
    this.velocity = velocity ?? randBetween(2, 10);
    this.radius = radius ?? 5;
    this.fillColor = fillColor ?? (new HSL(undefined, undefined, randBetween(15, 85))).print();//(new HSL(undefined, 100, randBetween(15, 85))).print();
    this.strokeColor = strokeColor ?? "black";
    this.dead = false;
    this.immunity = immunity ?? 0;
    this.isFood = isFood ?? false;
    this.isVirus = isVirus ?? false;
  }
  Cell.prototype.update = function() {
    if (this.dead || this.isFood) return;
    if (this.immunity > 0) this.immunity--;
    this.angle += Math.random() * 15 * randSign();
    this.vx = this.velocity * Math.cos(toRad(this.angle));
    this.vy = this.velocity * Math.sin(toRad(this.angle));
    this.x += this.vx / (1 + (Math.sqrt(this.radius) / 2));
    this.y += this.vy / (1 + (Math.sqrt(this.radius) / 2));
    
    if (this.x >= canvas21.width) {
      this.x = canvas21.width;
      this.angle = (90 - this.angle) * 2;
    }
    if (this.x <= 0) {
      this.x = 0;
      this.angle = (180 - this.angle);
    }
    if (this.y >= canvas21.height) {
      this.y = canvas21.height;
      this.angle = 360 - this.angle;
    }
    if (this.y <= 0) {
      this.y = 0;
      this.angle = 360 - this.angle;
    }
    
    for (let i = 0; i < cellArray.length; i++) {
      if (i != cellArray.indexOf(this) && !cellArray[i].dead && cellArray[i].immunity <= 0) {
        let distToCellSq = distSq(this.x, this.y, cellArray[i].x, cellArray[i].y)//Math.hypot(this.x - cellArray[i].x, this.y - cellArray[i].y);
        if (distToCellSq <= (this.radius + cellArray[i].radius) * (this.radius + cellArray[i].radius)) {
          if (cellArray[i].isVirus && !this.isVirus) {
            if (this.immunity <= 0) {
              this.burst();
              return;
            }
          }
          if (cellArray[i].isFood) {
            cellArray[i].dead = true;
            if (!this.isVirus) this.radius += 0.5;
          }
          if (!cellArray[i].isFood && !cellArray[i].isVirus && !this.isFood && !this.isVirus) {
            if (this.radius == cellArray[i].radius) {
              if (Math.random() >= 0.5) {
                this.dead = true;
                cellArray[i].radius += getNewRadius(this.radius);
                return;
              }
              else {
                cellArray[i].dead = true;
                this.radius += getNewRadius(cellArray[i].radius);
              }
            }
            else if (this.radius > cellArray[i].radius) {
              cellArray[i].dead = true;
              this.radius += getNewRadius(cellArray[i].radius);
            }
            else {
              this.dead = true;
              cellArray[i].radius += getNewRadius(this.radius);
              return;
            }
          }
        }
      }
    }
  };
  Cell.prototype.draw = function() {
    if (this.isFood) {
      ctx21.fillStyle = "orange";
      ctx21.fillCircle(this.x, this.y, this.radius);
    }
    else if (this.isVirus) {
      ctx21.fillStyle = "#77ff77";
      ctx21.fillPointedStar(this.x, this.y, this.radius - 6, this.radius, 12);
      ctx21.strokeStyle = "lime";
      ctx21.strokePointedStar(this.x, this.y, this.radius - 6, this.radius, 12);
      
    }
    else {
      ctx21.fillStyle = this.fillColor;
      ctx21.fillCircle(this.x, this.y, this.radius);
      ctx21.strokeStyle = this.strokeColor;
      ctx21.strokeCircle(this.x, this.y, this.radius);
    }
  };
  Cell.prototype.burst = function() {
    if (this.radius <= 3 || this.isFood || this.isVirus) return;
    totalCellDeathsFromViruses++;
    this.dead = true;
    let newCells = Math.round(Math.max(getNewRadius(this.radius), randBetween(2, 5)));
    let a = 0;
    for (let i = 0; i < newCells; i++) {
      a = Math.random() * Math.PI * 2;
      cellArray.push(new Cell(
        this.x + (Math.random() * this.radius * Math.cos(a)), // x
        this.y + (Math.random() * this.radius * Math.sin(a)), // y
        toDeg(a), // angle
        undefined, // velocity
        Math.max(this.radius / (newCells / 2), 3), // radius
        this.fillColor, // fillColor
        this.strokeColor, // strokeColor
        100 // immunity
      ));
    }
  };
  let cellArray = [];
  function getNewRadius(radius) {
    return Math.min(Math.sqrt(radius), radius / 2);
  }
  function addRandomCells(n) {
    for (let i = 0; i < n; i++) cellArray.push(new Cell());
  }
  function addFoodCells(n) {
    for (let i = 0; i < n; i++) cellArray.push(new Cell(undefined, undefined, 0, 0, 3, undefined, undefined, 0, true));
  }
  function addVirusCells(n) {
    for (let i = 0; i < n; i++) cellArray.push(new Cell(undefined, undefined, 0, 0, 20, undefined, undefined, 0, false, true));
  }
  addRandomCells(50);
  addFoodCells(100);
  addVirusCells(4);
  
  let currFrameCount = 1;
  let totalCellDeaths = 0;
  let totalCellDeathsFromViruses = 0;
  
  function frame21() {
    ctx21.clearRect(0, 0, canvas21.width, canvas21.height);
    
    if (currFrameCount % 10 == 0) addFoodCells(3);
    if (currFrameCount % 50 == 0) addRandomCells(1);
    
    for (let i = 0; i < cellArray.length; i++) {
      cellArray[i].update();
      cellArray[i].draw();
      if (cellArray[i].dead) {
        if (!cellArray[i].isFood && !cellArray[i].isVirus) totalCellDeaths++;
        cellArray.splice(i, 1);
        i--;
      }
    }
    
    let liveCells = cellArray.filter(x => !x.isFood && !x.isVirus);
    liveCellsTxt.innerHTML = `
      <b>Largest Cell Mass:</b> ${Math.round(liveCells.reduce((a, b) => Math.max(a, b.radius), 0))}<br>
      <b>Live Cells:</b> ${liveCells.length}<br>
      <b>Total Cell Deaths:</b> ${totalCellDeaths}<br>
      <b>Cell Deaths From Viruses:</b> ${totalCellDeathsFromViruses}<br>
      <b>Cell Deaths From Cells:</b> ${totalCellDeaths - totalCellDeathsFromViruses}<br>
      <b>Total Cell Mass:</b> ${Math.round(liveCells.reduce((a, b) => a + b.radius, 0))}
    `;
    
    
    currFrameCount++;
    currFrameCount %= 50;
    
    if (canvas21Running) requestAnimationFrame(frame21);
  }
  frame21();
  
  function startCanvas21() {
    if (canvas21Running) canvas21Running = false;
    else {
      canvas21Running = true;
      frame21();
    }
  }
</script>
<canvas id = "canvas20" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas20()">Start/Stop</button>
<div class = "desc"><b><i>(7/29/2021)</i></b> Chaos Game, using <a href = "https://www.youtube.com/watch?v=A0NHGTggoOQ" target = "_blank">https://www.youtube.com/watch?v=A0NHGTggoOQ</a> as a reference.</div>
<hr><hr>
<script>
  const ctx20 = canvas20.getContext("2d");
  canvas20.width = canvas20.height = 2000;
  let canvas20Running = false;
  
  let Points = [];
  let totalPoints = 5;
  for (let i = 0; i < totalPoints; i++) {
    let angle = (i * Math.PI * 2) / totalPoints;
    Points.push({
      x: (canvas20.width / 2) + ((canvas20.width / 2) * Math.cos(angle)),
      y: (canvas20.height / 2) + ((canvas20.height / 2) * Math.sin(angle)),
      color: `hsla(${(i / totalPoints) * 360}deg, 100%, 50%, 0.25)`
    });
  }
  let currPoint = {x: Math.random() * canvas20.width, y: Math.random() * canvas20.height};
  let currPointList = [];
  let targetPointFactor = 0.5;
  let pointsPerFrame = 200;
  
  function reset20() {
    Points = [];
    for (let i = 0; i < totalPoints; i++) {
      let angle = (i * Math.PI * 2) / totalPoints;
      Points.push({
        x: (canvas20.width / 2) + ((canvas20.width / 2) * Math.cos(angle)),
        y: (canvas20.height / 2) + ((canvas20.height / 2) * Math.sin(angle)),
        color: `hsla(${(i / totalPoints) * 360}deg, 100%, 50%, 0.25)`
      });
    }
    currPoint = {x: Math.random() * canvas20.width, y: Math.random() * canvas20.height};
  }
  
  let lastTargetPoint;
  
  let chaosRules = [
    (c, l) => c == l,
    (c, l) => c == (l + 1) % totalPoints,
    (c, l) => c == ((l - 1) + totalPoints) % totalPoints,
    (c, l) => c == (l + 2) % totalPoints
    //(c, l) => c == (l * l) % totalPoints
  ];
  let chosenChaosRules = [true, true, true, true];
  
  function  testFunction(curr, last) {
    return curr == last || curr == ((last * last) + 1) % totalPoints//|| curr == (last + 1) % totalPoints || curr == ((last - 1) + totalPoints) % totalPoints;
  }
  
  // Idea: Have a set of rules (like "curr == last" and "curr == (last + 1) % totalPoints") that you can turn on and off, all separated by OR
  
  function frame20() {
    //ctx20.clearRect(0, 0, canvas20.width, canvas20.height);
    
    for (let j = 0; j < pointsPerFrame; j++) {
      ctx20.fillStyle = "white";
      for (let i = 0; i < Points.length; i++) ctx20.fillCircle(Points[i].x, Points[i].y, 10);
      let targetPoint;
      let rechoose = false;
      do {
        targetPoint = Math.floor(Math.random() * Points.length);
        rechoose = false;
        for (let i = 0; i < chaosRules.length; i++) {
          if (chosenChaosRules[i]) {
            if (chaosRules[i](targetPoint, lastTargetPoint)) rechoose = true;
          }
        }
      }
      while (targetPoint == lastTargetPoint);//(rechoose);
      lastTargetPoint = targetPoint;
      currPoint.x = ((1 - targetPointFactor) * currPoint.x) + (targetPointFactor * Points[targetPoint].x);
      currPoint.y = ((1 - targetPointFactor) * currPoint.y) + (targetPointFactor * Points[targetPoint].y);
      ctx20.fillStyle = ctx20.strokeStyle = Points[targetPoint].color//"rgba(255, 0, 255, 0.5)";
      ctx20.fillCircle(currPoint.x, currPoint.y, 2);
      let slope = (currPoint.x - Points[targetPoint].x) / (currPoint.y - Points[targetPoint].y);
      let yInt = (-slope * Points[targetPoint].x) + Points[targetPoint].y;
      ctx20.beginPath();
      ctx20.moveTo(-canvas20.width, (slope * -canvas20.width) + yInt);
      ctx20.lineTo(canvas20.width, (slope * canvas20.width) + yInt);
      ctx20.globalAlpha = 0.05;
      ctx20.stroke();
      ctx20.globalAlpha = 1;
    }
    
    
    if (canvas20Running) requestAnimationFrame(frame20);
  }
  frame20();
  
  function startCanvas20() {
    if (canvas20Running) canvas20Running = false;
    else {
      canvas20Running = true;
      frame20();
    }
  }
</script>
<canvas id = "canvas19"></canvas>
<button onclick = "startCanvas19()">Start/Stop</button>
<div class = "desc">Supposed to mimic the Sandpile Fractal from <a href = "https://www.youtube.com/watch?v=1MtEUErz7Gg" target = "_blank">this</a> Numberphile video, but I can't get it to render evenly for some reason and I just completely gave up now. <b><i>Update 7/29/2021:</i></b> I <s>copied</s> borrowed some code and now it works. <b><i>Last Updated: 7/29/2021</i></b></div>
<hr><hr>
<script>
  const ctx19 = canvas19.getContext("2d");
  canvas19.width = canvas19.height = 300;
  let canvas19Running = false;
  
  let sandColors = ["black", "red", "yellow", "green", "blue"];
  
  let gridSize = 101;
  let pxSize = canvas19.width / gridSize;
  let midCell = (gridSize - 1) / 2;
  
  let grid = new Array(gridSize).fill(0).map(x => new Array(gridSize).fill(0));
  let tempGrid = new Array(gridSize).fill(0).map(x => new Array(gridSize).fill(0));
  
  grid[midCell][midCell] = Infinity;
  
  function frame19() {
    for (let j = 0; j < 40; j++) {
      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          tempGrid[x][y] = grid[x][y];
        }
      }
      
      let n;
      
      for (let x = 1; x < gridSize - 1; x++) {
        for (let y = 1; y < gridSize - 1; y++) {
          n = tempGrid[x][y];
          if (n > 3) {
            grid[x][y] -= 4;
            grid[x][y - 1]++;
            grid[x + 1][y]++;
            grid[x][y + 1]++;
            grid[x - 1][y]++;
          }
        }
      }
    }
    
    ctx19.fillStyle = "black";
    ctx19.fillRect(0, 0, canvas19.width, canvas19.height);
    for (let x = 1; x < gridSize - 1; x++) {
      for (let y = 1; y < gridSize - 1; y++) {
        ctx19.fillStyle = sandColors[grid[x][y]];
        if (grid[x][y] >= 4) ctx19.fillStyle = sandColors[4];
        ctx19.fillRect(x * pxSize, y * pxSize, pxSize, pxSize);
      }
    }
    
    if (canvas19Running) requestAnimationFrame(frame19);
  }
  frame19();
  
  function startCanvas19() {
    if (canvas19Running) canvas19Running = false;
    else {
      canvas19Running = true;
      frame19();
    }
  }
</script>
<canvas id = "canvas18"></canvas>
<button onclick = "startCanvas18()">Start/Stop</button>
<div class = "desc">Not finished, but moved to <a href = "fractal-spirograph.html" target = "_blank">fractal-spirograph.html</a>. <b><i>Last Updated: 7/28/2021</i></b></div>
<hr><hr>
<script>
  const ctx18 = canvas18.getContext("2d");
  canvas18.width = canvas18.height = 300;
  let canvas18Running = false;
  
  let interval = 0;
  let intervalPeriod = 500;
  let pathPoints = [];
  let showArrows = true;
  
  function Arrow(magnitude, speed) {
    this.magnitude = magnitude;
    this.speed = speed;
    this.endX = 0;
    this.endY = 0;
  }
  Arrow.prototype.render = function(x, y, angle) {
    ctx18.lineWidth = 1;
    if (showArrows) ctx18.strokeCircle(x, y, this.magnitude);
    this.endX = x + (Math.cos(((interval * Math.PI * 2) + angle) * this.speed) * this.magnitude);
    this.endY = y + (Math.sin(((interval * Math.PI * 2) + angle) * this.speed) * this.magnitude);
    ctx18.lineWidth = 2;
    ctx18.beginPath();
    ctx18.moveTo(x, y);
    ctx18.lineTo(this.endX, this.endY);
    if (showArrows) {
      ctx18.stroke();
      ctx18.fillCircle(this.endX, this.endY, 2);
    }
  };
  let arrowArray = [];
  arrowArray.push(new Arrow(50, -1));
  arrowArray.push(new Arrow(40, 2));
  arrowArray.push(new Arrow(30, -3));
  arrowArray.push(new Arrow(20, -2));
  arrowArray.push(new Arrow(10, 1));
  
  function frame18() {
    ctx18.clearRect(0, 0, canvas18.width, canvas18.height);
    
    let currX = canvas18.width / 2;
    let currY = canvas18.height / 2;
    let currAngle = 0;
    for (let i = 0; i < arrowArray.length; i++) {
      arrowArray[i].render(currX, currY, currAngle);
      currX = arrowArray[i].endX;
      currY = arrowArray[i].endY;
      currAngle += interval * Math.PI * 2;
    }
    pathPoints.push({x: currX, y: currY});
    
    ctx18.beginPath();
    ctx18.moveTo(pathPoints[0].x, pathPoints[0].y);
    for (let i = 0; i < pathPoints.length; i++) {
      ctx18.lineTo(pathPoints[i].x, pathPoints[i].y);
    }
    ctx18.stroke();
    
    if (pathPoints.length > intervalPeriod) pathPoints.shift();
    
    interval += 1 / intervalPeriod;
    while (interval >= 1) interval--;
    while (interval < 0) interval++;
    
    if (canvas18Running) requestAnimationFrame(frame18);
  }
  frame18();
  
  function startCanvas18() {
    if (canvas18Running) canvas18Running = false;
    else {
      canvas18Running = true;
      frame18();
    }
  }
</script>
<canvas id = "canvas17" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas17()">Start/Stop</button>
<div class = "desc">Here we go...I'm finally doing it, I'm gonna try to implement the Fourier Series in pure JavaScript. Tutorial: <a href = "https://www.youtube.com/watch?v=Mm2eYfj0SgA" target = "_blank">https://www.youtube.com/watch?v=Mm2eYfj0SgA</a>. <b><i>Last Updated: 7/27/2021</i></b><br><b><i>(9/25/2021)</i></b> Started working on it again, redid the whole code, and now it doesn't work at all.</div>
<hr><hr>
<script>
  const ctx17 = canvas17.getContext("2d");
  canvas17.width = canvas17.height = 1000;
  let canvas17Running = false;
  
  function discreteFourierTransform(input) {
    let output = [];
    
    let N = input.length;
    
    for (let k = 0; k < N; k++) {
      let real = 0;
      let imaginary = 0;
      for (let n = 0; n < N; n++) {
        let angle = (Math.PI * 2 * k * n) / N;
        real += input[k] * Math.cos(angle);
        imaginary -= input[k] * Math.sin(angle);
      }
      real /= N;
      imaginary /= N;
      
      let frequency = k;
      let amplitude = Math.sqrt((real * real) + (imaginary * imaginary));
      let phase = Math.atan2(imaginary, real);
      
      output.push({
        position: {
          real: real,
          imaginary: imaginary
        },
        frequency: frequency,
        amplitude: amplitude,
        phase: phase
      });
    }
    return output;
  }
  
  let fourierArray = discreteFourierTransform([50, 75, -25, 35, 45, -55, -55, 75, 85, -95, -100, 100, 20]);
  let points17 = [];
  let time17 = 0;
  
  function frame17() {
    ctx17.clearRect(0, 0, canvas17.width, canvas17.height);
    
    let currX = canvas17.width / 4;
    let currY = canvas17.height / 2;
    
    ctx17.lineWidth = 2;
    
    for (let i = 0; i < fourierArray.length; i++) {
      let lastX = currX;
      let lastY = currY;
      let angle = (fourierArray[i].frequency * time17 * Math.PI * 2) + fourierArray[i].phase + (Math.PI / 2);
      currX += fourierArray[i].position.real + (fourierArray[i].amplitude * Math.cos(angle));
      currY += fourierArray[i].position.imaginary + (fourierArray[i].amplitude * Math.sin(angle));
      ctx17.beginPath();
      ctx17.moveTo(lastX, lastY);
      ctx17.lineTo(currX, currY);
      ctx17.stroke();
      ctx17.strokeCircle(currX, currY, fourierArray[i].amplitude);
    }
    
    /*points17.unshift(currY);
    if (points17.length > 600) points17.pop();
    
    ctx17.beginPath();
    ctx17.moveTo(currX, currY);
    for (let i = 0; i < points17.length; i++) {
      ctx17.lineTo(i + 500, points17[i]);
    }
    ctx17.stroke();*/
    
    /*ctx17.lineWidth = 2;
    ctx17.strokeCircle(x, y, 200);
    ctx17.beginPath();
    ctx17.moveTo(x, y);
    x += 200 * Math.cos(time17 * Math.PI * 2);
    y += 200 * Math.sin(time17 * Math.PI * 2);
    ctx17.lineTo(x, y);
    ctx17.stroke();
    
    points17.unshift(y);
    if (points17.length > 600) points17.pop();
    
    ctx17.beginPath();
    ctx17.moveTo(x, y);
    for (let i = 0; i < points17.length; i++) {
      ctx17.lineTo(i + 500, points17[i]);
    }
    ctx17.stroke();*/
    
    time17 += (Math.PI * 2) / fourierArray.length;
    
    if (canvas17Running) requestAnimationFrame(frame17);
  }
  frame17();
  
  function startCanvas17() {
    if (canvas17Running) canvas17Running = false;
    else {
      canvas17Running = true;
      frame17();
    }
  }
  /*const ctx17 = canvas17.getContext("2d");
  canvas17.width = 1000;
  canvas17.height = 500;
  let canvas17Running = false;
  
  let timePassed = 0;
  let timeSpeed = 1 / 200;
  let circleRadius = 100;
  let wave = [];
  
  ctx17.translate(canvas17.width / 2, canvas17.height / 2);
  ctx17.lineWidth = 2;
  
  function frame17() {
    ctx17.clearRect(-canvas17.width / 2, -canvas17.height / 2, canvas17.width, canvas17.height);
    
    let currX = Math.cos(Math.PI * 2 * timePassed) * circleRadius;
    let currY = Math.sin(Math.PI * 2 * timePassed) * circleRadius;
    wave.unshift(currY);
    
    ctx17.strokeCircle(0, 0, circleRadius);
    
    ctx17.beginPath();
    ctx17.moveTo(0, 0);
    ctx17.lineTo(currX, currY);
    ctx17.stroke();
    
    ctx17.fillCircle(currX, currY, 5);
    
    ctx17.beginPath();
    ctx17.moveTo(currX, currY);
    for (let i = 0; i < wave.length; i++) {
      ctx17.lineTo(i + 200, wave[i], 1);
    }
    ctx17.stroke();
    
    timePassed += timeSpeed;
    while (timePassed >= 1) timePassed--;
    while (timePassed < 0) timePassed++;
    
    if (wave.length > 500) wave.pop();
    
    if (canvas17Running) requestAnimationFrame(frame17);
  }
  frame17();
  
  function startCanvas17() {
    if (canvas17Running) canvas17Running = false;
    else {
      canvas17Running = true;
      frame17();
    }
  }*/
</script>
<canvas id = "canvas16"></canvas>
<button onclick = "startCanvas16()">Start/Stop</button>
<div><b><u>Servo Angle:</u></b> <span id = "currTimeTxt">0</span>&deg;</div>
<input type = "range" id = "currTimeRange" min = "0" max = "360" step = "1" value = "0" oninput = "resetArms()" style = "width: 200px">
<br><br>
<div><b><u>Speed:</u></b> <span id = "currTimeSpeedTxt">1</span>x</div>
<input type = "range" id = "currTimeSpeedRange" min = "0.25" max = "5" step = "0.25" value = "1" oninput = "resetArms()">
<br><br>
<div><b><u>Reverse:</u></b></div>
<input type = "checkbox" id = "reverseCheckbox" oninput = "resetArms()">
<hr>
<div><b><u>Joint Offset Factor:</u></b> <span id = "jointOffsetFactorTxt">1</span>x</div>
<input type = "range" id = "jointOffsetFactorRange" min = "-2" max = "2" step = "0.1" value = "1" oninput = "resetArms()">
<hr>
<div><b><u>Number of Arms:</u></b> <span id = "armCountTxt">6</span></div>
<input type = "range" id = "armCountRange" min = "1" max = "20" step = "1" value = "6" oninput = "resetArms()">
<hr>
<div><b><u>Arm Joints:</u></b> <span id = "armJointsTxt">3</span></div>
<input type = "range" id = "armJointsRange" min = "0" max = "10" step = "1" value = "3" oninput = "resetArms()">
<hr>
<div><b><u>Alternate Joint Direction:</u></b></div>
<input type = "checkbox" id = "alternateJointDirectionCheckbox" oninput = "resetArms()" CHECKED>
<hr>
<div><b><u>Show Joints:</u></b></div>
<input type = "checkbox" id = "showJointsCheckbox" oninput = "resetArms()" CHECKED>
<hr>
<div><b><u>Show Arms:</u></b></div>
<input type = "checkbox" id = "showArmsCheckbox" oninput = "resetArms()" CHECKED>
<hr>
<div><b><u>Arm Length:</u></b> <span id = "armLengthTxt">300</span>px</div>
<input type = "range" id = "armLengthRange" min = "50" max = "400" step = "25" value = "300" oninput = "resetArms()">
<div class = "desc"><b><i><mark>Actually finished! (7/26/2021)</mark> Moved to <a href = "servo.html" target = "_blank">servo.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx16 = canvas16.getContext("2d");
  canvas16.width = canvas16.height = 800;
  let canvas16Running = false;
  
  let currTime = 0;
  let currTimeSpeed = 1;
  let armLength = 300;
  let armCount = 6;
  let armJoints = 3;
  let alternateJointDirection = true;
  let jointOffsetFactor = 1;
  let showJoints = true;
  let showArms = true;
  let showShadows = false;
  let rainbowJoints = false;
  let rainbowArms = false;
  let rainbowShadows = true;
  
  ctx16.lineWidth = 2;
  
  function Arm(angle) {
    this.angle = angle;
    this.pointsArray = [];
  }
  Arm.prototype.render = function() {
    ctx16.beginPath();
    ctx16.moveTo(canvas16.width / 2, canvas16.height / 2);
    let currLength = armLength / (armJoints + 1);
    let currX = (canvas16.width / 2) + (Math.cos(toRad(this.angle + currTime)) * currLength);
    let currY = (canvas16.height / 2) + (Math.sin(toRad(this.angle + currTime)) * currLength);
    let currSign = alternateJointDirection ? 1 : -1;
    this.pointsArray = [];
    ctx16.lineTo(currX, currY);
    this.pointsArray.push({x: currX, y: currY});
    for (let i = 1; i <= armJoints; i++) {
      if (alternateJointDirection) currSign *= -1;
      currX += Math.cos(toRad((this.angle * jointOffsetFactor) + (currTime * i * currSign))) * currLength;
      currY += Math.sin(toRad((this.angle * jointOffsetFactor) + (currTime * i * currSign))) * currLength;
      ctx16.lineTo(currX, currY);
      this.pointsArray.push({x: currX, y: currY});
    }
    if (showShadows) {
      ctx16.fillStyle = rainbowShadows ? `hsla(${this.angle + currTime}deg, 100%, 50%, 0.25)` : "rgba(0, 0, 0, 0.25)";
      ctx16.fill();
    }
    if (showArms) {
      ctx16.strokeStyle = rainbowArms ? `hsl(${this.angle + currTime}deg, 100%, 50%)` : "black";
      ctx16.stroke();
    }
    if (showJoints) {
      ctx16.fillStyle = rainbowJoints ? `hsl(${this.angle + currTime}deg, 100%, 50%)` : "black";
      for (let i = 0; i < this.pointsArray.length; i++) ctx16.fillCircle(this.pointsArray[i].x, this.pointsArray[i].y, 3);
    }
  };
  let armArray = [];
  
  function frame16() {
    ctx16.clearRect(0, 0, canvas16.width, canvas16.height);
    //ctx16.fillStyle = "rgba(255, 255, 255, 0.1)";
    //ctx16.fillRect(0, 0, canvas16.width, canvas16.height);
    
    if (canvas16Running) currTime += currTimeSpeed;
    while (currTime >= 360) currTime -= 360;
    while (currTime < 0) currTime += 360;
    currTimeRange.value = currTimeTxt.innerHTML = currTime;
    
    for (let i = 0; i < armArray.length; i++) {
      armArray[i].render();
    }
    
    if (canvas16Running) requestAnimationFrame(frame16);
  }
  
  function startCanvas16() {
    if (canvas16Running) canvas16Running = false;
    else {
      canvas16Running = true;
      frame16();
    }
  }
  
  function resetArms() {
    armArray = [];
    
    currTimeSpeed = Number(currTimeSpeedRange.value);
    currTimeSpeedTxt.innerHTML = currTimeSpeed;
    if (reverseCheckbox.checked) currTimeSpeed *= -1;
    armLength = Number(armLengthRange.value);
    armLengthTxt.innerHTML = armLength;
    armCount = Number(armCountRange.value);
    armCountTxt.innerHTML = armCount;
    armJoints = Number(armJointsRange.value);
    armJointsTxt.innerHTML = armJoints;
    alternateJointDirection = alternateJointDirectionCheckbox.checked;
    currTime = Number(currTimeRange.value);
    currTimeTxt.innerHTML = currTime;
    jointOffsetFactor = Number(jointOffsetFactorRange.value);
    jointOffsetFactorTxt.innerHTML = jointOffsetFactor;
    showJoints = showJointsCheckbox.checked;
    showArms = showArmsCheckbox.checked;
    
    for (let i = 0; i < armCount; i++) {
      armArray.push(new Arm((i / armCount) * 360));
    }
    
    if (!canvas16Running) frame16();
  }
  resetArms();
  frame16();
</script>
<canvas id = "canvas15" style = "background-color: black"></canvas>
<button onclick = "startCanvas15()">Start/Stop</button>
<div class = "desc">Supposed to mimic the circle music from this old Flash game website, where each time two circles touch, they each change diretion and make a noise, but I never got the collisions working properly or any music to be made at all.</div>
<hr><hr>
<script>
  const ctx15 = canvas15.getContext("2d");
  canvas15.width = canvas15.height = 300;
  let canvas15Running = false;
  
  let ringGrowSpeed = 1;
  
  ctx15.lineWidth = 2;
  ctx15.strokeStyle = "orange";
  ctx15.fillStyle = "white";
  
  function Ring(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.radiusSign = 1;
  }
  Ring.prototype.render = function() {
    this.radius += ringGrowSpeed * this.radiusSign;
    if (this.radius <= 0) {
      this.radius = 0;
      this.radiusSign = 1;
    }
    if (this.radius >= 100) this.radiusSign = -1;
    
    for (let i = 0; i < ringsArray.length; i++) {
      if (i != ringsArray.indexOf(this)) {
        let dist = Math.hypot(this.x - ringsArray[i].x, this.y - ringsArray[i].y);
        //let distToEdge = (ringsArray[i].radius - this.radius) - dist;
        if (dist >= (this.radius + ringsArray[i].radius) - 1 && dist <= this.radius + ringsArray[i].radius + 1) this.radiusSign = -1;
        //if (distToEdge <= 0) this.radiusSign *= -1;
      }
    }
    
    ctx15.strokeCircle(this.x, this.y, this.radius);
    ctx15.fillCircle(this.x, this.y, 2);
  };
  let ringsArray = [];
  
  function frame15() {
    ctx15.clearRect(0, 0, canvas15.width, canvas15.height);
    
    for (let i = 0; i < ringsArray.length; i++) {
      ringsArray[i].render();
    }
    
    if (canvas15Running) requestAnimationFrame(frame15);
  }
  frame15();
  
  function startCanvas15() {
    if (canvas15Running) canvas15Running = false;
    else {
      canvas15Running = true;
      frame15();
    }
  }
  
  canvas15.addEventListener("mousedown", e => {
    let canvas15Rect = canvas15.getBoundingClientRect();
    ringsArray.push(new Ring(e.clientX - canvas15Rect.left, e.clientY - canvas15Rect.top));
  });
</script>
<canvas id = "canvas14"></canvas>
<button onclick = "startCanvas14()">Start/Stop</button>
<div class = "desc">Tried a variation on dots.html where a circle moves around a rectangular path based on the current angle, but it ended up being pretty complicated and I decided not to try to turn it into a full thing. <b><i>Last Updated: 7/25/2021</i></b></div>
<hr><hr>
<script>
  const ctx14 = canvas14.getContext("2d");
  canvas14.width = canvas14.height = 300;
  let canvas14Running = false;
  
  let time = 270;
  let width = 200;
  let height = 100;
  let r1 = [-toDeg(Math.atan2(height, width)), toDeg(Math.atan2(height, width))];
  let r2 = [toDeg(Math.atan2(height, width)), toDeg(Math.PI - Math.atan2(height, width))];
  let r3 = [toDeg(Math.PI - Math.atan2(height, width)), toDeg(Math.PI + Math.atan2(height, width))];
  let r4 = [toDeg(Math.PI + Math.atan2(height, width)), -toDeg(Math.atan2(height, width))];
  
  let dotX = 0;
  let dotY = 0;
  
  ctx14.lineWidth = 2;
  
  function frame14() {
    ctx14.clearRect(0, 0, canvas14.width, canvas14.height);
    
    //ctx14.strokeRectFromCenter(canvas14.width / 2, canvas14.height / 2, width, height);
    
    if ((time > r1[0] && time <= r1[1]) || (time > r1[0] + 360 && time <= r1[1] + 360)) {
      dotX = (canvas14.width / 2) + (width / 2);
      dotY = (canvas14.height / 2) + ((width / 2) * Math.tan(toRad(time)));
    }
    if (time > r2[0] && time <= r2[1]) {
      dotX = (canvas14.width / 2) + (height / ((Math.tan(toRad(time)) * 2)));
      dotY = (canvas14.height / 2) + (height / 2);
    }
    if (time > r3[0] && time <= r3[1]) {
      dotX = (canvas14.width / 2) - width / 2;
      dotY = (canvas14.height / 2) - ((width / 2) * Math.tan(toRad(time)));
    }
    if ((time > r4[0] && time <= r4[1]) || (time > r4[0] && time <= r4[1] + 360)) {
      dotX = (canvas14.width / 2) - (height / ((Math.tan(toRad(time)) * 2)));
      dotY = (canvas14.height / 2) - (height / 2);
    }
    
    ctx14.beginPath();
    ctx14.moveTo(canvas14.width / 2, canvas14.height / 2);
    ctx14.lineTo((canvas14.width / 2) + (112 * Math.cos(toRad(time))), (canvas14.height / 2) + (112 * Math.sin(toRad(time))));
    ctx14.stroke();
    ctx14.fillCircle(dotX, dotY, 4);
    
    time += 2;
    while (time >= 360) time -= 360;
    
    if (canvas14Running) requestAnimationFrame(frame14);
  }
  frame14();
  
  function startCanvas14() {
    if (canvas14Running) canvas14Running = false;
    else {
      canvas14Running = true;
      frame14();
    }
  }
</script>
<canvas id = "canvas13"></canvas>
<button onclick = "startCanvas13()">Start/Stop</button>
<div class = "desc">Gravity simulation. <b><i>Last Updated: 7/25/2021</i></b></div>
<hr><hr>
<script>
  const ctx13 = canvas13.getContext("2d");
  canvas13.width = canvas13.height = 300;
  let canvas13Running = false;
  
  const gravConstant = 5;
  
  ctx13.lineWidth = 2;
  
  function Obj(x, y, angle, power, mass, color) {
    this.x = x ?? Math.random() * canvas13.width;
    this.y = y ?? Math.random() * canvas13.height;
    this.vx = Math.cos(toRad(angle)) * power;
    this.vy = Math.sin(toRad(angle)) * power;
    this.mass = mass;
    this.color = color;
  }
  Obj.prototype.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    
    for (let i = 0; i < objArray.length; i++) {
      if (i != objArray.indexOf(this)) {
        let distX = objArray[i].x - this.x;
        if (Math.abs(distX) < 10) distX = 10 * Math.sign(distX);
        let distY = objArray[i].y - this.y;
        if (Math.abs(distY) < 10) distY = 10 * Math.sign(distY);
        let dist = Math.hypot(distX, distY);
        let force = (gravConstant * this.mass * objArray[i].mass) / (dist * dist);
        let angle = Math.atan2(distY, distX);
        this.vx += (Math.cos(angle) * force) / this.mass;
        this.vy += (Math.sin(angle) * force) / this.mass;
      }
    }
    
    if (this.x > canvas13.width) {
     this.x = canvas13.width;
     this.vx *= -1;
    }
    if (this.x < 0) {
      this.x = 0;
      this.vx *= -1;
    }
    if (this.y > canvas13.height) {
     this.y = canvas13.height;
     this.vy *= -1;
    }
    if (this.y < 0) {
      this.y = 0;
      this.vy *= -1;
    }
    
    ctx13.fillStyle = this.color;
    ctx13.fillCircle(this.x, this.y, this.mass / 2);
    ctx13.strokeCircle(this.x, this.y, this.mass / 2);
  };
  let objArray = [];
  
  function frame13() {
    ctx13.clearRect(0, 0, canvas13.width, canvas13.height);
    
    for (let i = 0; i < objArray.length; i++) {
      objArray[i].render();
    }
    
    if (canvas13Running) requestAnimationFrame(frame13);
  }
  for (let i = 0; i < 5; i++) {
    objArray.push(new Obj(undefined, undefined, Math.random() * 360, randBetween(-2, 2), randBetween(10, 20), (new HSL(undefined, 100, 50)).print()));
  }
  //objArray.push(new Obj(undefined, undefined, Math.random() * 360, randBetween(-2, 2), 60, "rgba(0, 0, 0, 0.25)"));
  frame13();
  
  function startCanvas13() {
    if (canvas13Running) canvas13Running = false;
    else {
      canvas13Running = true;
      frame13();
    }
  }
</script>
<canvas id = "canvas12"></canvas>
<button onclick = "startCanvas12()">Start/Stop</button>
<div class = "desc">Experiment where circles find the closest neighbor and then set their size equal to that distance, so no two circles overlap.<br><b><i>(8/21/2021)</i></b> Made the circles direction based on velocity and angle, so that its angle can change and have more interesting movement.</div>
<hr><hr>
<script>
  const ctx12 = canvas12.getContext("2d");
  canvas12.width = canvas12.height = 300;
  let canvas12Running = false;
  
  function Circle(x, y, vx, vy, color) {
    this.x = x ?? Math.random() * canvas12.width;
    this.y = y ?? Math.random() * canvas12.height;
    this.angle = Math.random() * 360;
    this.velocity = randBetween(1, 2);
    //this.vx = vx ?? 1 * randSign()//randBetween(0.25, 1) * randSign();
    //this.vy = vy ??  1 * randSign()//randBetween(0.25, 1) * randSign();
    this.color = color ?? (new RGB(255)).print();
  }
  Circle.prototype.render = function() {
    this.x += this.velocity * Math.cos(toRad(this.angle));//this.vx;
    this.y += this.velocity * Math.sin(toRad(this.angle));//this.vy;
    this.angle += Math.random() * 10 * randSign();
    if (this.x < 0) {
      this.x = 0;
      //this.vx *= -1;
      this.angle = (180 - this.angle);
    }
    if (this.x > canvas12.width) {
      this.x = canvas12.width;
      //this.vx *= -1;
      this.angle = (90 - this.angle) * 2;
    }
    if (this.y < 0) {
      this.y = 0;
      //this.vy *= -1;
      this.angle = 360 - this.angle;
    }
    if (this.y > canvas12.height) {
      this.y = canvas12.height;
      //this.vy *= -1;
      this.angle = 360 - this.angle;
    }
    
    ctx12.fillStyle = this.color;
    ctx12.lineWidth = 3;
    ctx12.strokeStyle = "black";
    let minDist = Infinity;
    let nodeIndex = 0;
    for (let i = 0; i < circleArray.length; i++) {
      if (i != circleArray.indexOf(this)) {
        let dist = Math.hypot(this.x - circleArray[i].x, this.y - circleArray[i].y);
        if (dist <= minDist) {
          minDist = dist;
          nodeIndex = i;
        }
      }
    }
    ctx12.fillCircle(this.x, this.y, minDist / 2);
    ctx12.strokeCircle(this.x, this.y, minDist / 2);
  };
  let circleArray = [];
  for (let i = 0; i < 20; i++) circleArray.push(new Circle());
  
  function frame12() {
    ctx12.clearRect(0, 0, canvas12.width, canvas12.height);
    
    for (let i = 0; i < circleArray.length; i++) {
      circleArray[i].render();
    }
    
    if (canvas12Running) requestAnimationFrame(frame12);
  }
  frame12();
  
  function startCanvas12() {
    if (canvas12Running) canvas12Running = false;
    else {
      canvas12Running = true;
      frame12();
    }
  }
</script>
<canvas id = "canvas11" style = "background-color: black"></canvas>
<button onclick = "startCanvas11()">Start/Stop</button>
<br>
<div><b><u>Tracing Mode:</u></b></div>
<input type = "radio" name = "tracingModeRadio" id = "tracingMode0Radio" oninput = "updateSettings()" CHECKED>
<label for = "tracingMode0Radio">No tracing</label>
<br>
<input type = "radio" name = "tracingModeRadio" id = "tracingMode1Radio" oninput = "updateSettings()">
<label for = "tracingMode1Radio">Trailing</label>
<br>
<input type = "radio" name = "tracingModeRadio" id = "tracingMode2Radio" oninput = "updateSettings()">
<label for = "tracingMode2Radio">Full tracing</label>
<br><br>
<div><b><u>Show Paths:</u></b></div>
<input type = "checkbox" id = "showPathsCheckbox" oninput = "updateSettings()">
<br><br>
<div><b><u>Speed:</u></b> <span id = "animTimeSpeedTxt">2</span>x</div>
<input type = "range" id = "animTimeSpeedRange" min = "0.1" max = "10" step = "0.1" value = "2" oninput = "updateSettings()">
<br>
<div><b><u>Counterclockwise:</u></b></div>
<input type = "checkbox" id = "counterCheckbox" oninput = "updateSettings()">
<br><br>
<div><b><u>Dot Offset Factor:</u></b> <span id = "ellipseOffsetFactorTxt">0.3</span>x</div>
<input type = "range" id = "ellipseOffsetFactorRange" min = "-10" max = "10" step = "0.1" value = "0.3" oninput = "updateSettings()">
<br><br>
<div><b><u>Number of Dots:</u></b> <span id = "ellipseCountTxt">24</span></div>
<input type = "range" id = "ellipseCountRange" min = "1" max = "100" step = "1" value = "24" oninput = "updateSettings()">
<br><br>
<div><b><u>Dot Size:</u></b> <span id = "ellipseDotSizeTxt">10</span>px</div>
<input type = "range" id = "ellipseDotSizeRange" min = "1" max = "20" step = "1" value = "10" oninput = "updateSettings()">
<br><br>
<div><b><u>Path Width:</u></b> <span id = "ellipseWidthTxt">20</span>px</div>
<input type = "range" id = "ellipseWidthRange" min = "0" max = "300" step = "5" value = "20" oninput = "updateSettings()">
<br><br>
<div><b><u>Path Height:</u></b> <span id = "ellipseHeightTxt">100</span>px</div>
<input type = "range" id = "ellipseHeightRange" min = "0" max = "300" step = "5" value = "100" oninput = "updateSettings()">
<div class = "desc"><b><i><mark>Actually finished! (7/24/2021)</mark> Moved to <a href = "dots.html" target = "_blank">dots.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx11 = canvas11.getContext("2d");
  canvas11.width = canvas11.height = 300;
  let canvas11Running = false;
  
  let animTime = 0;
  let animTimeSpeed = 2;
  let ellipseOffsetFactor = 0.3;
  let ellipseCount = 24;
  let ellipseWidth = 20;
  let ellipseHeight = 100;
  let tracingMode = 0;
  // 0: No tracing | 1: Trailing | 2: Full tracing
  let ellipseDotSize = 10;
  let showPaths = false;
  
  function Ellipse(x, y, angle, width, height, hue, dotSize) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.width = width;
    this.height = height;
    this.lastDotX = Math.cos(toRad(animTime + (this.angle * ellipseOffsetFactor))) * this.width;
    this.lastDotY = Math.sin(toRad(animTime + (this.angle * ellipseOffsetFactor))) * this.height;
    this.hue = 0//hue;
    this.dotSize = dotSize;
  }
  Ellipse.prototype.render = function() {
    ctx11.strokeStyle = `hsl(${this.hue}deg, 100%, 50%)`;
    this.hue = this.angle + (animTime / 2);
    ctx11.lineWidth = this.dotSize;
    ctx11.lineCap = "round";
    ctx11.save();
    ctx11.translate(this.x, this.y);
    ctx11.rotate(toRad(this.angle));
    ctx11.beginPath();
    ctx11.moveTo(this.lastDotX, this.lastDotY);
    ctx11.lineTo(Math.cos(toRad(animTime + (this.angle * ellipseOffsetFactor))) * this.width, Math.sin(toRad(animTime + (this.angle * ellipseOffsetFactor))) * this.height);
    ctx11.stroke();
    this.lastDotX = Math.cos(toRad(animTime + (this.angle * ellipseOffsetFactor))) * this.width;
    this.lastDotY = Math.sin(toRad(animTime + (this.angle * ellipseOffsetFactor))) * this.height;
    if (showPaths) {
      ctx11.strokeStyle = "dimgray";
      ctx11.lineWidth = 1;
      ctx11.beginPath();
      ctx11.ellipse(0, 0, this.width, this.height, 0, 0, 2 * Math.PI);
      ctx11.stroke();
    }
    ctx11.restore();
  };
  let ellipseArray = [];
  
  function frame11() {
    if (tracingMode != 0) {
      ctx11.globalAlpha = tracingMode == 1 ? 0.1 : 0;
      ctx11.fillStyle = "black";
      ctx11.fillRect(0, 0, canvas11.width, canvas11.height);
      ctx11.globalAlpha = 1;
    }
    else ctx11.clearRect(0, 0, canvas11.width, canvas11.height);
    
    animTime += animTimeSpeed;
    while (animTime >= 720) animTime -= 720;
    while (animTime <= 0) animTime += 720;
    
    for (let i = 0; i < ellipseArray.length; i++) ellipseArray[i].render();
    
    if (canvas11Running) requestAnimationFrame(frame11);
  }
  
  function startCanvas11() {
    if (canvas11Running) canvas11Running = false;
    else {
      canvas11Running = true;
      frame11();
    }
  }
  
  function updateSettings() {
    animTimeSpeed = Number(animTimeSpeedRange.value);
    animTimeSpeedTxt.innerHTML = animTimeSpeed;
    if (counterCheckbox.checked) animTimeSpeed *= -1;
    ellipseOffsetFactor = Number(ellipseOffsetFactorRange.value);
    ellipseOffsetFactorTxt.innerHTML = ellipseOffsetFactor;
    ellipseCount = Number(ellipseCountRange.value);
    ellipseCountTxt.innerHTML = ellipseCount;
    ellipseDotSize = Number(ellipseDotSizeRange.value);
    ellipseDotSizeTxt.innerHTML = ellipseDotSize;
    ellipseWidth = Number(ellipseWidthRange.value);
    ellipseWidthTxt.innerHTML = ellipseWidth;
    ellipseHeight = Number(ellipseHeightRange.value);
    ellipseHeightTxt.innerHTML = ellipseHeight;
    if (tracingMode0Radio.checked) tracingMode = 0;
    if (tracingMode1Radio.checked) tracingMode = 1;
    if (tracingMode2Radio.checked) tracingMode = 2;
    showPaths = showPathsCheckbox.checked;
    
    ellipseArray = [];
    for (let i = 0; i < ellipseCount; i++) {
      ellipseArray.push(new Ellipse(canvas11.width / 2, canvas11.height / 2, (i / ellipseCount) * 360, ellipseWidth, ellipseHeight, (i / ellipseCount) * 360, ellipseDotSize));
    }
  }
  updateSettings();
  frame11();
  frame11();
</script>
<canvas id = "canvas10"></canvas>
<br>
<button onclick = "generatePerson()">Generate</button>
<br>
<div><b><u>Name:</u></b></div>
<input type = "text" value = "Eddie" id = "seed-txt-2">
<button onclick = "randomizeSeed2()">Randomize Name</button>
<div class = "desc">Random person generator. Their characteristics - like hair, skin color, height, body type, etc. - are determined by a seeded random number generator using their name as the seed. <b><i>Last Updated: 7/16/2021</i></b></div>
<hr><hr>
<script src = "scripts/seedrandom.js"></script>
<script>
  const ctx10 = canvas10.getContext("2d");
  canvas10.width = canvas10.height = 300;
  
  let seedTxt2 = document.getElementById("seed-txt-2");
  
  let skinColorsArray = ["#ffd6c5", "#e7c1b2", "#e4bdad", "#ffe2c9", "#e8b894", "#e7b38d", "#d8905f", "#c28155", "#be794a", "#88513a", "#7b4934", "#733e26"];
  let hairColorsArray = ["#f0e2b6", "#23120b", "#3d2314", "#5a3825", "#cc9966", "#2c1608", "#7c0a02", "#5d1916", "#121212", "#310306", "#59260b"];
  
  function randomizeSeed2() {
    let seed = "";
    let a = "abcdefghijklmnopqrstuvwxyz";
    for (let i = 0; i < 20; i++) {
      seed += a[Math.floor(Math.random() * a.length)];
    }
    seedTxt2.value = seed;
  }
  //randomizeSeed2();
  generatePerson();
  
  function generatePerson() {
    ctx10.clearRect(0, 0, canvas10.width, canvas10.height);
    
    seedTxt2.value = seedTxt2.value.replace(/\W/g, "");
    seedTxt2.value = seedTxt2.value.substring(0, 20);
    if (seedTxt2.value == "") seedTxt2.value = "Eddie";
    
    let mRandom = Math.random;
    Math.seedrandom(seedTxt2.value);
    let srand = Math.random;
    Math.random = mRandom;
    
    let srandBetween = (min, max) => (srand() * (max - min)) + min;
    
    let skinColor = skinColorsArray[Math.floor(srand() * skinColorsArray.length)];
    ctx10.fillStyle = skinColor;
    
    let personX = (canvas10.width / 2) + srandBetween(-25, 25);
    let personY = (canvas10.height / 2) + srandBetween(-25, 25);
    let personHeight = srandBetween(150, 200);
    
    let headY = personY - 50;
    let headRadius = srandBetween(23, 27);
    ctx10.fillCircle(personX, headY, headRadius);
    
    let hairColor = hairColorsArray[Math.floor(srand() * hairColorsArray.length)];
    ctx10.fillStyle = hairColor;
    let hairFluffiness = Math.floor(srandBetween(10, 20));
    let hairY = headY - headRadius + srandBetween(2, 5);
    let hairWidth = (headRadius * 2) + srandBetween(2, 5);
    ctx10.beginPath();
    ctx10.lineWidth = 2;
    let hairStyle = Math.floor(srand() * 2);
    if (hairStyle == 0) { // Curly
      for (let i = 0; i <= hairFluffiness; i++) {
        let a = ((i / hairFluffiness) * 360) + srandBetween(-5, 5);
        let a2 = ((i / hairFluffiness) * 360) + srandBetween(-2.5, 2.5);
        let l = srandBetween(25, 30);
        let l2 = l + srandBetween(5, 20);
        if (i == 0) ctx10.moveTo(Math.cos(toRad(a)) * l + personX, Math.sin(toRad(a)) * l * 0.5 + hairY);
        else ctx10.quadraticCurveTo(Math.cos(toRad(a2)) * l2 + personX, Math.sin(toRad(a2)) * l2 * 0.5 + hairY, Math.cos(toRad(a)) * l + personX, Math.sin(toRad(a)) * l * 0.5 + hairY);
      }
    }
    else if (hairStyle == 1) { // Pointy
      for (let i = 0; i <= hairFluffiness; i++) {
        let a = ((i / hairFluffiness) * 360) + srandBetween(-5, 5);
        let a2 = ((i / hairFluffiness) * 360) + srandBetween(-2.5, 2.5);
        let l = srandBetween(25, 30);
        let l2 = l + srandBetween(5, 15);
        if (i == 0) ctx10.moveTo(Math.cos(toRad(a)) * l + personX, Math.sin(toRad(a)) * l * 0.5 + hairY);
        else {
          ctx10.lineTo(Math.cos(toRad(a2)) * l2 + personX, Math.sin(toRad(a2)) * l2 * 0.5 + hairY);
          ctx10.lineTo(Math.cos(toRad(a)) * l + personX, Math.sin(toRad(a)) * l * 0.5 + hairY);
        }
      }
    }
    ctx10.fill();
    /*for (let i = 0; i < hairFluffiness; i++) {
      let x = personX + srandBetween(-5, 5);
      let y = hairY + srandBetween(-3, 3);
      ctx10.moveTo(x, y);
      let a = srand() * Math.PI * 2;
      let l = srandBetween(25, 30);
      ctx10.lineTo((Math.cos(a) * l) + x, (Math.sin(a) * l * 0.5) + y);
    }*/
    ctx10.stroke();
    
    
    /*for (let x = 0; x < canvas10.width; x += 10) {
      for (let y = 0; y < canvas10.height; y += 10) {
        ctx10.fillStyle = `rgb(${rand() * 255}, ${rand() * 255}, ${rand() * 255})`;
        //ctx10.fillStyle = `hsl(${(rand() * 360).toMultipleOf(120)}deg, 100%, 50%)`;
        //ctx10.fillStyle = `hsl(0deg, 0%, ${rand() * 100}%)`;
        ctx10.fillRect(x, y, 10, 10);
      }
    }
    for (let i = 0; i < 100; i++) {
      ctx10.strokeStyle = "black";
      ctx10.lineWidth = 2;
      ctx10.strokeCircle(rand() * canvas10.width, rand() * canvas10.height, (rand() * 10) + 5);
    }*/
  }
</script>
<canvas id = "canvas9"></canvas>
<br>
<button onclick = "generateTerrain()">Generate</button>
<br>
<div><b><u>World Seed:</u></b></div>
<input type = "text" value = "e4494s" id = "seed-txt">
<button onclick = "randomizeSeed()">Randomize Seed</button>
<div class = "desc">Biome scene generator. I want it to create a grassy landscape with flowers and trees and clouds, with the option to generate different biomes, using a set seed. <b><i>Last Updated: 7/10/2021</i></b></div>
<hr><hr>
<script>
  const ctx9 = canvas9.getContext("2d");
  canvas9.width = canvas9.height = 300;
  
  let seedTxt = document.getElementById("seed-txt");
  let alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVQXYZ_";
  
  String.prototype.reverse = function() {
    return this.split("").reverse().join("");
  }
  
  function seedRandom(string) {
    let seed = "";
    for (let i = 0; i < string.length; i++) {
      seed += String(alphabet.indexOf(string[i]));
    }
    seed = Number("0." + seed);
    if (seed == 0) seed = 0.1;
    let n = 0;
    return function() {
      seed *= (Math.abs(Math.sin(n++)) + 1) * 1.5 * (seed + 1);
      seed -= Math.floor(seed);
      return seed;
    };
  }
  
  function randomizeSeed() {
    let seed = "";
    for (let i = 0; i < 10; i++) {
      seed += alphabet[Math.floor(Math.random() * alphabet.length)];
    }
    seedTxt.value = seed;
  }
  //randomizeSeed();
  generateTerrain();
  
  function generateTerrain() {
    ctx9.clearRect(0, 0, canvas9.width, canvas9.height);
    
    seedTxt.value = seedTxt.value.replace(/\W/g, "");
    seedTxt.value = seedTxt.value.substring(0, 10);
    
    let rand = seedRandom(seedTxt.value);
    //for (let i = 0; i < 4; i++) rand();
    
    ctx9.fillStyle = `hsl(200deg, 75%, ${(rand() * 50) + 25}%)`; // Sky
    ctx9.fillRect(0, 0, canvas9.width, canvas9.height);
    
    let grassLayers = Math.floor(rand() * 4) + 1;
    for (let i = 0; i < grassLayers; i++) {
      let grassY = canvas9.height - (rand() * 150) - 25;//canvas9.height - (((rand() * 0.3) + 0.1) * canvas9.height);
      ctx9.fillStyle = `hsl(80deg, ${(rand() * 50) + 50}%, ${(rand() * 20) + 20}%)`;
      ctx9.beginPath();
      ctx9.moveTo(0, grassY);
      let grassBumps = Math.floor((rand() * 5) + 2);
      let currX = 0;
      for (let j = 0; j < grassBumps; j++) {
        let nextX = currX + (rand() * (canvas9.width / grassBumps));
        ctx9.lineTo(nextX, (rand() * 20) + (grassY - 10));
        currX = nextX;
      }
      //console.log(grassLayers);
      ctx9.lineTo(canvas9.width, grassY);
      ctx9.lineTo(canvas9.width, canvas9.height);
      ctx9.lineTo(0, canvas9.height);
      ctx9.fill();
    }
    
    /*for (let i = 0; i < 30; i++) {
      ctx9.fillStyle = "black";
      ctx9.fillCircle(rand() * canvas9.width, rand() * canvas9.height, (rand() * 10) + 5);
    }*/
    /*for (let x = 0; x < canvas9.width; x += 10) {
      for (let y = 0; y < canvas9.height; y += 10) {
        ctx9.fillStyle = `rgb(${rand() * 255}, ${rand() * 255}, ${rand() * 255})`;
        ctx9.fillStyle = `hsl(${(rand() * 360).toMultipleOf(120)}deg, 100%, 50%)`;
        ctx9.fillStyle = `hsl(0deg, 0%, ${rand() * 100}%)`;
        ctx9.fillRect(x, y, 10, 10);
      }
    }*/
  }
</script>
<canvas id = "canvas8" style = "background-color: black"></canvas>
<button onclick = "startCanvas8()">Start/Stop</button>
<div class = "desc">Bouncing block simulator. I want it to squish against the floor and walls when it hits and bounce back some, with customiseable squishiness, bounciness, gravity, etc. <b><i>Last Updated: 7/1/2021</i></b></div>
<hr><hr>
<script>
  const ctx8 = canvas8.getContext("2d");
  canvas8.width = canvas8.height = 300;
  let canvas8Running = false;
  
  const Settings = {
    gravity: 0.15,
    bounciness: 1
  };
  
  const Box = {
    color: `hsl(${Math.floor(Math.random() * 360)}deg, ${Math.floor(randBetween(80, 90))}%, ${Math.floor(randBetween(50, 60))}%)`,
    width: 50,
    height: 50,
    x: canvas8.width / 2,
    y: canvas8.height / 2,
    vx: randBetween(0.5, 2) * randSign(),
    vy: randBetween(-1, -4)
  };
  ctx8.shadowColor = Box.color;
  
  Box.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += Settings.gravity;
    
    if (this.x + (this.width / 2) >= canvas8.width) {
      this.x = canvas8.width - (this.width / 2);
      this.vx *= -Settings.bounciness;
    }
    if (this.x - (this.width / 2) <= 0) {
      this.x = this.width / 2;
      this.vx *= -Settings.bounciness;
    }
    if (this.y + (this.height / 2) >= canvas8.height) {
      this.y = canvas8.height - (this.height / 2);
      this.vy *= -Settings.bounciness;
    }
    if (this.y - (this.height / 2) <= 0) {
      this.y = this.height / 2;
      this.vy *= -Settings.bounciness;
    }
    
    ctx8.fillStyle = this.color;
    ctx8.fillRectFromCenter(this.x, this.y, this.width, this.height);
  };
  
  function frame8() {
    //ctx8.clearRect(0, 0, canvas8.width, canvas8.height);
    ctx8.globalAlpha = 0.2;
    ctx8.shadowBlur = 0;
    ctx8.fillStyle = "black";
    ctx8.fillRect(0, 0, canvas8.width, canvas8.height);
    ctx8.globalAlpha = 1;
    ctx8.shadowBlur = 10;
    
    Box.render();
    
    if (canvas8Running) requestAnimationFrame(frame8);
  }
  frame8();
  
  function startCanvas8() {
    if (canvas8Running) canvas8Running = false;
    else {
      canvas8Running = true;
      frame8();
    }
  }
</script>
<canvas id = "canvas7"></canvas>
<button onclick = "startCanvas7()">Start/Stop</button>
<div class = "desc">Bubble simulator, ideally the bubbles will connect to each other like (][) as they float around. Never got it working properly, the bubbles don't float convincingly like real bubbles and I never even tried to figure out how to make them stick together. <b><i>Last Updated: 7/1/2021</i></b></div>
<hr><hr>
<script>
  const ctx7 = canvas7.getContext("2d");
  canvas7.width = canvas7.height = 300;
  let canvas7Running = false;
  
  let gravity = 0;
  let airResistance = 0.025;
  let randomWind = 0.25;
  
  function Bubble(x, y, vx, vy, radius) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.radius = radius;
  }
  Bubble.prototype.render = function() {
    this.x += this.vx;
    this.y += this.vy;
    
    this.vy += gravity;
    
    this.vx *= 1 - airResistance;
    this.vy *= 1 - airResistance;
    
    this.vx += Math.random() * randomWind * randSign();
    this.vy += Math.random() * randomWind * randSign();
    
    this.vx *= randBetween(1, 1.04);
    this.vy *= randBetween(1, 1.04);
    
    if (this.x > canvas7.width + this.radius) this.x = -this.radius;
    if (this.x < -this.radius) this.x = canvas7.width + this.radius;
    if (this.y > canvas7.height + this.radius) this.y = -this.radius;
    if (this.y < -this.radius) this.y = canvas7.height + this.radius;
    
    ctx7.strokeCircle(this.x, this.y, this.radius);
  };
  let bubbleArray = [];
  function addBubble(x, y, vx, vy, radius) {
    bubbleArray.push(new Bubble(x, y, vx, vy, radius));
  }
  function addRandomBubbles(n) {
    for (let i = 0; i < n; i++) {
      let angle = Math.random() * 360;
      let velocity = randBetween(1.5, 3.5);
      addBubble(Math.random() * canvas7.width, Math.random() * canvas7.height, Math.cos(toRad(angle)) * velocity, Math.sin(toRad(angle)) * velocity, randBetween(2, 15));
    }
  }
  addRandomBubbles(20);
  
  function frame7() {
    ctx7.clearRect(0, 0, canvas7.width, canvas7.height);
    
    for (let i = 0; i < bubbleArray.length; i++) {
      bubbleArray[i].render();
    }
    
    if (canvas7Running) requestAnimationFrame(frame7);
  }
  frame7();
  
  function startCanvas7() {
    if (canvas7Running) canvas7Running = false;
    else {
      canvas7Running = true;
      frame7();
    }
  }
</script>
<canvas id = "canvas6"></canvas>
<button onclick = "startCanvas6()">Start/Stop</button>
<div class = "desc">Supposed to be some sort of Risk of Rain-style game with abilities and cooldowns (WASD/arrows to move, click to shoot). I never managed to figure out why the shooting is so completely off, and I never got the cooldowns or separate abilities working. I want to have randomly spawning enemies shoot at or attack the player. <b><i>Last Updated: 6/30/2021</i></b></div>
<hr><hr>
<script>
  const ctx6 = canvas6.getContext("2d");
  canvas6.width = canvas6.height = 500;
  let canvas6Running = false;
  let canvasRect = canvas6.getBoundingClientRect();
  
  let upDown = false;
  let rightDown = false;
  let downDown = false;
  let leftDown = false;
  
  function Bullet(x, y, size, angle, velocity) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.angle = angle
    this.velocity = velocity;
    this.sprite = new Image();
    this.sprite.src = "images/levelportal.png";
  }
  Bullet.prototype.render = function() {
    this.x += Math.cos(toRad(this.angle)) * this.velocity;
    this.y += Math.sin(toRad(this.angle)) * this.velocity;
    ctx6.drawImageFromCenter(this.sprite, this.x, this.y, this.size, this.size);
  };
  let bulletArray = [];
  function shootBulletTowards(startX, startY, pointX, pointY, size, velocity) {
    bulletArray.push(new Bullet(
      startX,
      startY,
      size,
      toDeg(Math.atan((pointY - startY) / (pointX - startX))),
      velocity
    ));
  }
  
  const Hero = {
    width: 25,
    height: 35,
    x: 0,
    y: 0,
    speed: 1.5
  };
  Hero.sprite = new Image();
  Hero.sprite.src = "images/watermelon.png";
  Hero.render = function() {
    if (upDown) Hero.y -= Hero.speed;
    if (rightDown) Hero.x += Hero.speed;
    if (downDown) Hero.y += Hero.speed;
    if (leftDown) Hero.x -= Hero.speed;
    ctx6.drawImageFromCenter(this.sprite, this.x, this.y, this.width, this.height);
  };
  
  function reset() {
    Hero.x = canvas6.width / 2;
    Hero.y = canvas6.height / 2;
  }
  
  function frame6() {
    ctx6.clearRect(0, 0, canvas6.width, canvas6.height);
    
    Hero.render();
    
    for (let i = 0; i < bulletArray.length; i++) {
      bulletArray[i].render();
    }
    
    if (canvas6Running) requestAnimationFrame(frame6);
  }
  reset();
  frame6();
  
  function startCanvas6() {
    if (canvas6Running) canvas6Running = false;
    else {
      canvas6Running = true;
      frame6();
    }
  }
  
  function keyDownHandler(e) {
    if (e.code == "KeyW" || e.code == "ArrowUp") upDown = true;
    if (e.code == "KeyD" || e.code == "ArrowRight") rightDown = true;
    if (e.code == "KeyS" || e.code == "ArrowDown") downDown = true;
    if (e.code == "KeyA" || e.code == "ArrowLeft") leftDown = true;
  }
  function keyUpHandler(e) {
    if (e.code == "KeyW" || e.code == "ArrowUp") upDown = false;
    if (e.code == "KeyD" || e.code == "ArrowRight") rightDown = false;
    if (e.code == "KeyS" || e.code == "ArrowDown") downDown = false;
    if (e.code == "KeyA" || e.code == "ArrowLeft") leftDown = false;
  }
  addEventListener("keydown", keyDownHandler);
  addEventListener("keyup", keyUpHandler);
  
  function mouseDownHandler(e) {
    mouseDown = true;
    let eX = e.clientX - canvasRect.left;
    let eY = e.clientY - canvasRect.top;
    shootBulletTowards(Hero.x, Hero.y, eX, eY, 15, 5);
  }
  function mouseUpHandler(e) {
    mouseDown = false;
  }
  addEventListener("mousedown", mouseDownHandler);
  addEventListener("mouseup", mouseUpHandler);
  
</script>
<canvas id = "canvas5"></canvas>
<button onclick = "startCanvas5()">Start/Stop</button>
<div class = "desc">Supposed to mimic the "windmill problem" from the International Math Olympiad, the line rotates from a pivot point and every time it touches another point, that point becomes the new pivot point. For some reason, the line simply ignores some points and I never figured out why. <b><i>Last Updated: 6/30/2021</i></b></div>
<hr><hr>
<script>
  const ctx5 = canvas5.getContext("2d");
  canvas5.width = canvas5.height = 300;
  let canvas5Running = false;
  
  let line = {};
  line.pivot = {x: 0, y: 0};
  line.angle = 0;
  line.turnSpeed = 0.5;
  
  let points = [];
  
  function reset() {
    points = [];
    let numPoints = Math.floor(randBetween(7, 15));
    for (let i = 0; i < numPoints; i++) {
      points.push({x: Math.floor(Math.random()  * canvas5.width), y: Math.floor(Math.random() * canvas5.height)});
    }
    line.pivot.x = points[0].x;
    line.pivot.y = points[0].y;
  }
  
  function frame5() {
    ctx5.clearRect(0, 0, canvas5.width, canvas5.height);
    
    ctx5.strokeStyle = "black";
    ctx5.lineWidth = 2;
    ctx5.beginPath();
    ctx5.moveTo(-canvas5.width + line.pivot.x, -canvas5.width * Math.tan((line.angle * Math.PI) / 180) + line.pivot.y);
    ctx5.lineTo(canvas5.width + line.pivot.x, canvas5.width * Math.tan((line.angle * Math.PI) / 180) + line.pivot.y);
    ctx5.stroke();
    line.angle += line.turnSpeed;
    
    for (let i = 0; i < points.length; i++) {
      ctx5.fillStyle = "red";
      ctx5.fillCircle(points[i].x, points[i].y, 3);
      let yCord = (Math.tan((line.angle * Math.PI) / 180) * (points[i].x - line.pivot.x)) + line.pivot.y;
      if (yCord <= points[i].y + 3 && yCord >= points[i].y - 3) {
        line.pivot.x = points[i].x;
        line.pivot.y = points[i].y;
      }
    }
    ctx5.fillStyle = "green";
    ctx5.fillCircle(line.pivot.x, line.pivot.y, 4);
    //setTimeout(() => requestAnimationFrame(frame5), 100);
    if (canvas5Running) requestAnimationFrame(frame5);
  }
  reset();
  frame5();
  
  function startCanvas5() {
    if (canvas5Running) canvas5Running = false;
    else {
      canvas5Running = true;
      frame5();
    }
  }
</script>
<canvas id = "canvas4"></canvas>
<div class = "desc">I don't really know what this is</div>
<hr><hr>
<canvas id = "canvas3"></canvas>
<button onclick = "startCanvas3()">Start/Stop</button>
<div class = "desc">If finished, the corners of the two squares will connect as it turns, making a cool design/loading icon.<br><b><i>Update 7/1/2021:</i></b> Got the lines connecting properly, now all the corners connect as it rotates. I want to add the ability for it to work with any positioning and sizes of the squares, as well as different pivot points, for more interesting animations.</div>
<hr><hr>
<canvas id = "canvas2"></canvas>
<button onclick = "randomPixels()">Go</button>
<div>Random Pixel Mode: <span id = "randPxModeTxt">0 (Random RGB)</span></div>
<input type = "range" min = "0" max = "10" step = "1" value = "0" id = "randPxModeRange" oninput = "updateRandPxSettings()">
<div>
  <b><i>0:</i></b> Random RGB
  <br>
  <b><i>1:</i></b> Random HSL
  <br>
  <b><i>2:</i></b> Random RGB or Random HSL
  <br>
  <b><i>3:</i></b> Random RGB with R = 255
  <br>
  <b><i>4:</i></b> Random RGB with G = 255
  <br>
  <b><i>5:</i></b> Random RGB with B = 255
  <br>
</div>
<script>
  const ctx2 = canvas2.getContext("2d");
  canvas2.width = canvas2.height = 150;
  let size = 1;
  
  let randPxMode = 0;
  let randPxModeDesc = ["(Random RGB)", "(Random HSL)", "(Random RGB or Random HSL)", "(Random RGB with R = 255)", "(Random RGB with G = 255)", "(Random RGB with B = 255)"];
  
  function updateRandPxSettings() {
    randPxMode = Number(randPxModeRange.value);
    randPxModeTxt.innerHTML = randPxMode + " " + randPxModeDesc[randPxMode];
  }
  
  function randPxColor() {
    if (randPxMode == 0) return (new RGB()).print();
    else if (randPxMode == 1) return (new HSL()).print();
    else if (randPxMode == 2) return Math.random() >= 0.5 ? (new RGB()).print() : (new HSL()).print();
    else if (randPxMode == 3) return (new RGB(255)).print();
    else if (randPxMode == 4) return (new RGB(undefined, 255)).print();
    else if (randPxMode == 5) return (new RGB(undefined, undefined, 255)).print();
    else if (randPxMode == 6) return (new RGB(128, 128)).print();
  }
  
  function randomPixels() {
    for (let x = 0; x < canvas2.width; x += size) {
      for (let y = 0; y < canvas2.height; y += size) {
        ctx2.fillStyle = randPxColor();//Math.round(Math.random()) == 0 ? (new RGB()).print() : (new HSL()).print()//`hsl(${(Math.random() * 360).toMultipleOf(120)}deg, 100%, 50%)`;
        //ctx2.fillStyle = (new HSL(undefined, undefined, 50)).print();
        ctx2.fillRect(x, y, size, size);
      }
    }
  }
</script>
<hr><hr>
<canvas id = "canvas1"></canvas>
<div><b><u>Sides / Points:</u></b> <span id = "sidesTxt">5</span></div>
<input type = "range" id = "sidesRange" min = "3" max = "12" step = "1" value = "5" oninput = "frame1()">
<br><br>
<script>
  const ctx1 = canvas1.getContext("2d");
  canvas1.width = canvas1.height = 300;
  
  ctx1.lineWidth = 6;
  
  CanvasRenderingContext2D.prototype.strokePolygon = function(x, y, radius, sides) {
    this.beginPath();
    this.moveTo(x, y - radius);
    for (let i = 0; i <= sides + 1; i++) {
      let angle = ((i / sides) * Math.PI * 2) - (Math.PI / 2);
      this.lineTo(x + (Math.cos(angle) * radius), y + (Math.sin(angle) * radius));
    }
    this.stroke();
  };
  CanvasRenderingContext2D.prototype.fillPolygon = function(x, y, radius, sides) {
    this.beginPath();
    this.moveTo(x, y - radius);
    for (let i = 0; i <= sides; i++) {
      let angle = ((i / sides) * Math.PI * 2) - (Math.PI / 2);
      this.lineTo(x + (Math.cos(angle) * radius), y + (Math.sin(angle) * radius));
    }
    this.fill();
  };
  CanvasRenderingContext2D.prototype.strokePointedStar = function(x, y, innerRadius, outerRadius, points) {
    this.beginPath();
    this.moveTo(x, y - outerRadius);
    for (let i = 0; i < points + 1; i++) {
      let a = (i * ((Math.PI * 2) / points)) - (Math.PI / 2);
      let a2 = ((i + 0.5) * ((Math.PI * 2) / points)) - (Math.PI / 2);
      this.lineTo(x + (outerRadius * Math.cos(a)), y + (outerRadius * Math.sin(a)));
      this.lineTo(x + (innerRadius * Math.cos(a2)), y + (innerRadius * Math.sin(a2)));
    }
    this.stroke();
  };
  CanvasRenderingContext2D.prototype.fillPointedStar = function(x, y, innerRadius, outerRadius, points) {
    this.beginPath();
    this.moveTo(x, y - outerRadius);
    for (let i = 0; i < points + 1; i++) {
      let a = (i * ((Math.PI * 2) / points)) - (Math.PI / 2);
      let a2 = ((i + 0.5) * ((Math.PI * 2) / points)) - (Math.PI / 2);
      this.lineTo(x + (outerRadius * Math.cos(a)), y + (outerRadius * Math.sin(a)));
      this.lineTo(x + (innerRadius * Math.cos(a2)), y + (innerRadius * Math.sin(a2)));
    }
    this.fill();
  };
  
  function frame1() {
    ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
    
    sidesTxt.innerHTML = sidesRange.value;
    
    ctx1.strokeStyle = (new HSL(undefined, randBetween(50, 100), randBetween(0, 30))).print();
    ctx1.fillStyle = (new HSL(undefined, randBetween(50, 100), randBetween(50, 80))).print();
    
    ctx1.strokePolygon(canvas1.width * 0.25, canvas1.height / 2, 50, Number(sidesRange.value));
    ctx1.fillPolygon(canvas1.width * 0.25, canvas1.height / 2, 50, Number(sidesRange.value));
    
    ctx1.strokePointedStar(canvas1.width * 0.75, canvas1.height / 2, 20, 50, Number(sidesRange.value));
    ctx1.fillPointedStar(canvas1.width * 0.75, canvas1.height / 2, 20, 50, Number(sidesRange.value));
  }
  frame1();
</script>
<br>
<script>
  function calculatePI() {
    let time = Date.now();
    let iterations = 100000;
    let sum = 0;
    let denominator = 1;
    for (let i = 0; i < iterations; i++) {
      if (i % 2 == 0) sum += 4 / denominator;
      else sum -= 4 / denominator;
      denominator += 2;
    }
    return `Estimated value of Pi: ${sum}\nDigits calculated: ${String(sum).replace("3.", "").length}\nTime elapsed: ${Date.now() - time}ms`;
  }
</script>
<script>
  const ctx4 = canvas4.getContext("2d");
  canvas4.width = canvas4.height = 300;
  
  const e4494s = {};
  e4494s.rand = {};
  e4494s.rand.row = [];
  e4494s.rand.rowLength = 200;
  for (let i = 0; i < e4494s.rand.rowLength; i++) e4494s.rand.row.push("0");
  e4494s.rand.row[0] = "1";
  e4494s.random = function() {
    let nextRow = [];
    for (let i = 0; i < e4494s.rand.rowLength; i++) {
      let pattern = e4494s.rand.row[(i - 1 + e4494s.rand.rowLength) % e4494s.rand.rowLength] + e4494s.rand.row[i] + e4494s.rand.row[(i + 1) % e4494s.rand.rowLength];
      switch (pattern) {
        case "111":
        case "110":
        case "101":
        case "000":
        nextRow[i] = "0";
        break;
        default: nextRow[i] = "1";
      }
    }
    e4494s.rand.row = nextRow;
    return Number(e4494s.rand.row[0]);
  };
  
  
  let t = 0;
  for (let i = 0; i < 100; i++) t += e4494s.random();
  //console.log(t);
</script>
<script>
  const ctx3 = canvas3.getContext("2d");
  canvas3.width = canvas3.height = 300;
  let canvas3Running = false;
  
  ctx3.shadowBlur = 5;
  ctx3.lineWidth = 2;
  
  /*let angle = 0;
  let angleSpeed = 1;*/
  
  // pivotType
  // 0: center | 1: top left | 2: top right | 3: bottom right | 4: bottom left
  
  function Box_(x, y, angle, turnSpeed, width, height, pivotType) {
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.turnSpeed = turnSpeed;
    this.width = width;
    this.height = height;
    this.pivotType = pivotType;
  }
  Box_.prototype.getCorners = function() {
    let corners = {};
    if (this.pivotType == 0) {
      let cosHalfWidth = ((this.width / 2) * Math.cos(toRad(this.angle)));
      let sinHalfHeight = ((this.height / 2) * Math.sin(toRad(this.angle)));
      let sinHalfWidth = ((this.width / 2) * Math.sin(toRad(this.angle)));
      let cosHalfHeight = ((this.height / 2) * Math.cos(toRad(this.angle)));
      corners.tl = {
        x: this.x - cosHalfWidth + sinHalfHeight,
        y: this.y - sinHalfWidth - cosHalfHeight
      };
      corners.tr = {
        x: this.x + cosHalfWidth + sinHalfHeight,
        y: this.y + sinHalfWidth - cosHalfHeight
      };
      corners.br = {
        x: this.x + cosHalfWidth - sinHalfHeight,
        y: this.y + sinHalfWidth + cosHalfHeight
      };
      corners.bl = {
        x: this.x - cosHalfWidth - sinHalfHeight,
        y: this.y - sinHalfWidth + cosHalfHeight
      };
    }
    return corners;
  };
  
  const Box1 = new Box_(canvas3.width / 2, canvas3.height / 2, 0, 1, 100, 100, 0);
  const Box2 = new Box_(canvas3.width / 2, canvas3.height / 2, 0, -1, 100, 100, 0);
  
  function frame3() {
    ctx3.clearRect(0, 0, canvas3.width, canvas3.height);
    
    ctx3.shadowBlur = 5;
    ctx3.fillStyle = "rgba(255, 0, 0, 0.2)";
    ctx3.shadowColor = "rgba(255, 0, 0, 0.75)";
    
    ctx3.strokeRotatedRectFromCenter(Box1.x, Box1.y, Box1.width, Box1.height, Box1.angle);
    ctx3.fillRotatedRectFromCenter(Box1.x, Box1.y, Box1.width, Box1.height, Box1.angle);
    let c1 = Box1.getCorners();
    Box1.angle += Box1.turnSpeed;
    
    ctx3.strokeRotatedRectFromCenter(Box2.x, Box2.y, Box2.width, Box2.height, Box2.angle);
    ctx3.fillRotatedRectFromCenter(Box2.x, Box2.y, Box2.width, Box2.height, Box2.angle);
    let c2 = Box2.getCorners();
    Box2.angle += Box2.turnSpeed;
    
    
    /*if (Box1.angle >= 360) {
      Box1.angle = 360;
      Box1.turnSpeed = Box2.turnSpeed = -2;
    }
    if (Box1.angle <= 0) {
      Box1.angle = 0;
      Box1.turnSpeed = 1;
      Box2.turnSpeed = -1;
    }*/
    
    ctx3.shadowColor = "white";
    ctx3.shadowBlur = 3;
    ctx3.beginPath();
    ctx3.moveTo(c1.tl.x, c1.tl.y);
    ctx3.lineTo(c2.tl.x, c2.tl.y);
    ctx3.moveTo(c1.tr.x, c1.tr.y);
    ctx3.lineTo(c2.tr.x, c2.tr.y);
    ctx3.moveTo(c1.br.x, c1.br.y);
    ctx3.lineTo(c2.br.x, c2.br.y);
    ctx3.moveTo(c1.bl.x, c1.bl.y);
    ctx3.lineTo(c2.bl.x, c2.bl.y);
    ctx3.stroke();
    
    /*ctx3.fillStyle = "black";
    ctx3.fillCircle(c1.tl.x, c1.tl.y, 3);
    ctx3.fillCircle(c1.tr.x, c1.tr.y, 3);
    ctx3.fillCircle(c1.br.x, c1.br.y, 3);
    ctx3.fillCircle(c1.bl.x, c1.bl.y, 3);
    ctx3.fillCircle(c2.tl.x, c2.tl.y, 3);
    ctx3.fillCircle(c2.tr.x, c2.tr.y, 3);
    ctx3.fillCircle(c2.br.x, c2.br.y, 3);
    ctx3.fillCircle(c2.bl.x, c2.bl.y, 3);*/
    
    if (canvas3Running) requestAnimationFrame(frame3);
  }
  frame3();
  
  function startCanvas3() {
    if (canvas3Running) canvas3Running = false;
    else {
      canvas3Running = true;
      frame3();
    }
  }
</script>
<script>
  Math.factorial = function(number) {
    number = Math.floor(number);
    let result = 1;
    for (let i = number; i > 0; i--) result *= i;
    return result;
  };
  let factorials = [];
  for (let i = 0; i < 25; i++) factorials.push(Math.factorial((i * 2) + 1));
  Math.testSin = function(number) {
    let result = 0;
    for (let i = 0; i < 25; i++) {
      let s = i % 2 ? -1 : 1;
      result += s * Math.pow(number, (i * 2) + 1) / factorials[i];//Math.factorial((i * 2) + 1);
    }
    return result;
  };
  
  function testingSines() {
    let iterations = 100000000;
    let now = Date.now();
    for (let i = 0; i < iterations; i++) Math.sin(1);
    let passed = new Date(Date.now() - now);
    console.log("Math.sin() performance of 100,000,000 iterations: " + passed.getSeconds() + "s:" + passed.getMilliseconds() + "ms");
    now = Date.now();
    for (let i = 0; i < iterations; i++) Math.testSin(1);
    passed = new Date(Date.now() - now);
    console.log("Math.testSin() performance of 100,000,000 iterations: " + passed.getSeconds() + "s:" + passed.getMilliseconds() + "ms");
  }
  
  function testingSqrts() {
    console.log("Testing the efficiency of various methods of calculating if a distance is less than a set amount.");
    let before = Date.now();
    for (let i = 0; i < 50000000; i++) {
      let dx = 30 - 20;
      let dy = 40 - 25;
      let dist = Math.sqrt((dx * dx) + (dy * dy));
      dist <= 20;
    }
    let after = Date.now();
    console.log("50,000,000 iterations of Math.sqrt: " + (after - before) + "ms");
    
    before = Date.now();
    for (let i = 0; i < 50000000; i++) {
      let minDist = 20;
      let dx = 30 - 20;
      let dy = 40 - 25;
      let dist = Math.hypot(dx, dy);
      dist <= minDist;
    }
    after = Date.now();
    console.log("50,000,000 iterations of Math.hypot: " + (after - before) + "ms");
    
    before = Date.now();
    for (let i = 0; i < 50000000; i++) {
      let minDist = 20;
      let dx = 30 - 20;
      let dy = 40 - 25;
      let dist = Math.atan2Sqrt(dy, dx);
      dist <= minDist;
    }
    after = Date.now();
    console.log("50,000,000 iterations of Math.atan2Sqrt: " + (after - before) + "ms");
    
    before = Date.now();
    for (let i = 0; i < 50000000; i++) {
      let minDist = 20;
      let dx = 30 - 20;
      let dy = 40 - 25;
      let distSq = (dx * dx) + (dy * dy);
      distSq <= minDist * minDist;
    }
    after = Date.now();
    console.log("50,000,000 iterations of comparing the distance squared with the compared distance squared: " + (after - before) + "ms");
  }
  Math.atan2Sqrt = function(y, x) {
    return y / Math.sin(Math.atan2(y, x));
  };
</script>
<input type = "color" oninput = "document.getElementById('color-value').innerHTML = this.value">
<div id = "color-value"></div>
<hr><hr>
<script>
  function numberOverItselfMinusOne(n) { // x / ((x - 1) / (x - 2))
    let equation = n + "/";
    for (let i = 1; i < n; i++) {
      if (i != n - 1) equation += "(" + (n - i) + "/";
      else equation += "(" + (n - i) + ")".repeat(n - 1);
    }
    return eval(equation);
  }
</script>
</body>
</html>














