<!DOCTYPE html>
<html>
<head>
  <link rel = "icon"  href = "images/favicon.png" type = "image/png">
  <link rel = "stylesheet" href = "stylesheets/main.css">
  <title>Test Bed 2 ~ e4494s</title>
  <style>
    canvas {
      width: 300px;
      height: 300px;
      border: 2px solid black;
    }
    
    hr {
      border: 1px solid black;
    }
    
    .desc {
      background-color: silver;
      margin: 5px;
      padding: 5px;
      border-radius: 5px;
    }
    .desc mark {
      background-color: #ffff4d;
    }
  </style>
</head>
<body>
<script src = "scripts/main.js"></script>
<h1>The Second Island of Misfit Code</h1>
<div style = "font-size: 16px; background-color: rgb(255, 150, 150); padding: 8px; margin-top: 25px; margin-bottom: 25px; border-radius: 10px"><b><i>Moved to from <a href = "testbed.html" target = "_blank">testbed.html</a> on 10/17/2021.</i></b></div>
<!--
<canvas id = "canvas0"></canvas>
<button onclick = "startCanvas0()">Start/Stop</button>
<div class = "desc"></div>
<hr><hr>
<script>
  const ctx0 = canvas0.getContext("2d");
  canvas0.width = canvas0.height = 300;
  let canvas0Running = false;
  
  function frame0() {
    ctx0.clearRect(0, 0, canvas0.width, canvas0.height);
    
    if (canvas0Running) requestAnimationFrame(frame0);
  }
  frame0();
  
  function startCanvas0() {
    if (canvas0Running) canvas0Running = false;
    else {
      canvas0Running = true;
      frame0();
    }
  }
</script>
-->
<canvas id = "canvas85"></canvas>
<button onclick = "draw85()">Redraw</button>
<div class = "desc"><b><i>(5/25/2022)</i></b> Generative art that is similar to <a href = "tiles.html" target = "_blank">tiles.html</a>, except that every single tile is guaranteed to connect to adjacent tiles, to create an intricate and solid structure. Today I added the first 14 tiles, I plan to have a total of 20+.<br><b><i>(5/26/2022)</i></b> Finally added the final tiles, now I have a full 20, and everything connects exactly like I imagined it would.<br><b><i><mark>Actually finished! (5/27/2022)</mark> Moved to <a href = "connectivity.html" target = "_blank">connectivity.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx85 = canvas85.getContext("2d");
  canvas85.width = canvas85.height = 1000;
  
  function XOR85(a, b) {
    return a != b;
  }
  function XNOR85(a, b) {
    return a == b;
  }
  
  // Industrial (Wheel, Block, Joint) (Gray tile color, black background color)
  
  let selectedTiles85 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
  let numTiles85 = 20;
  let gridSize85 = 10;
  /*
  1: Ramp    |  2: Notch   |  3: Stripe   |  4: Dots     |  5: Quills
  6: Arc     |  7: Gear    |  8: Bars     |  9: Paw      |  10: Sun
  11: Slice  |  12: Wheel  |  13: Layers  |  14: Face    |  15: Bumps
  16: Stair  |  17: Block  |  18: Joint   |  19: Hammer  |  20: Spikes
  */
  
  let colors85 = ["black", "white"]; // Tile, background
  
  function getAngles85(direction, i) {
    if (!direction && i === 0) return {start: toRad(0), end: toRad(90)};
    if (!direction && i === 1) return {start: toRad(180), end: toRad(270)};
    if (direction && i === 0) return {start: toRad(90), end: toRad(180)};
    if (direction && i === 1) return {start: toRad(270), end: toRad(0)};
  }
  
  function drawTile85(_x, _y, size, direction, parity, type) {
    /* Direction: (0 = false, 1 = true)
    0-----1
    |     |
    |     |
    1-----0
    */
    
    /*
    Parity
    False = Color outside
    True = Color inside
    */
    
    let xSign, ySign, x1, y1, x2, y2;
    if (!direction) {
      xSign = 1;
      ySign = 1;
      x1 = _x;
      y1 = _y;
      x2 = _x + size;
      y2 = _y + size;
    }
    else {
      xSign = -1;
      ySign = 1;
      x1 = _x + size;
      y1 = _y;
      x2 = _x;
      y2 = _y + size;
    }
    
    let p = parity ? 1 : 0;
    ctx85.fillStyle = colors85[1 - p]; // Background color
    ctx85.fillRect(_x, _y, size, size);
    ctx85.fillStyle = ctx85.strokeStyle = colors85[p]; // Tile color
    
    if (type === 1) { // Ramp
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 2) { // Notch
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let cx = x;
        let cy = y;
        ctx85.moveTo(cx, cy);
        cx += size * 0.5 * xSign;
        ctx85.lineTo(cx, cy);
        cx -= size * 0.1875 * xSign;
        cy += size * 0.1875 * ySign;
        ctx85.lineTo(cx, cy);
        cx += size * 0.125 * xSign;
        cy += size * 0.125 * ySign;
        ctx85.lineTo(cx, cy);
        cx -= size * 0.125 * xSign;
        cy += size * 0.125 * ySign;
        ctx85.lineTo(cx, cy);
        cx -= size * 0.125 * xSign;
        cy -= size * 0.125 * ySign;
        ctx85.lineTo(cx, cy);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 3) { // Stripe
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        ctx85.lineWidth = size * 0.075;
        ctx85.lineCap = ctx85.lineJoin = "round";
        ctx85.beginPath();
        ctx85.moveTo(x + (size * 0.625 * xSign), y + (size * 0.125 * ySign));
        ctx85.lineTo(x + (size * 0.125 * xSign), y + (size * 0.625 * ySign));
        ctx85.stroke();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 4) { // Dots
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        let radius = size * 0.05;
        
        ctx85.fillCircle(x + (size * 0.625 * xSign), y + (size * 0.125 * ySign), radius);
        ctx85.fillCircle(x + (size * 0.375 * xSign), y + (size * 0.375 * ySign), radius);
        ctx85.fillCircle(x + (size * 0.125 * xSign), y + (size * 0.625 * ySign), radius);
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 5) { // Quills
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        ctx85.lineCap = ctx85.lineJoin = "round";
        ctx85.lineWidth = size * 0.05;
        let cx = x + (size * 0.5 * xSign);
        let cy = y + (size * (1 / 18) * ySign);
        for (let i = 0; i < 5; i++) {
          ctx85.beginPath();
          ctx85.moveTo(cx + (size * 0.05 * xSign), cy + (size * 0.05 * ySign));
          ctx85.lineTo(cx + (size * (1 / 6) * xSign), cy + (size * (1 / 6) * ySign));
          ctx85.stroke();
          cx -= size * (1 / 9) * xSign;
          cy += size * (1 / 9) * ySign;
        }
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 6) { // Arc
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let angles = getAngles85(direction, i);
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.arc(x, y, size * 0.5, angles.start, angles.end);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 7) { // Gear
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let angles = getAngles85(direction, i);
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.arc(x, y, size * 0.5, angles.start, angles.end);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        let len = size * 0.125 * Math.SQRT2;
        for (let j = 0; j < 2; j++) {
          ctx85.beginPath();
          let ca = j === 0 ? 22.5 : 67.5;
          let cx = x + (size * 0.4 * Math.cos(toRad(ca)) * xSign);
          let cy = y + (size * 0.4 * Math.sin(toRad(ca)) * ySign);
          ctx85.moveTo(cx, cy);
          ca -= 90;
          cx += len * 0.5 * Math.cos(toRad(ca)) * xSign;
          cy += len * 0.5 * Math.sin(toRad(ca)) * ySign;
          ctx85.lineTo(cx, cy);
          ca += 90;
          cx += (len + (size * 0.1)) * Math.cos(toRad(ca)) * xSign;
          cy += (len + (size * 0.1)) * Math.sin(toRad(ca)) * ySign;
          ctx85.lineTo(cx, cy);
          ca += 90;
          cx += len * Math.cos(toRad(ca)) * xSign;
          cy += len * Math.sin(toRad(ca)) * ySign;
          ctx85.lineTo(cx, cy);
          ca += 90;
          cx += (len + (size * 0.1)) * Math.cos(toRad(ca)) * xSign;
          cy += (len + (size * 0.1)) * Math.sin(toRad(ca)) * ySign;
          ctx85.lineTo(cx, cy);
          ca += 90;
          cx += len * 0.5 * Math.cos(toRad(ca)) * xSign;
          cy += len * 0.5 * Math.sin(toRad(ca)) * ySign;
          ctx85.lineTo(cx, cy);
          ctx85.fill();
        }
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 8) { // Bars
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let angles = getAngles85(direction, i);
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.arc(x, y, size * 0.5, angles.start, angles.end);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        ctx85.lineWidth = size * 0.075;
        ctx85.lineCap = ctx85.lineJoin = "round";
        ctx85.beginPath();
        ctx85.arc(x, y, size * 0.625, angles.start + (toRad(8)), angles.end - toRad(45 + 8));
        ctx85.stroke();
        ctx85.beginPath();
        ctx85.arc(x, y, size * 0.625, angles.start + toRad(45 + 8), angles.end - toRad(8));
        ctx85.stroke();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 9) { // Paw
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let angles = getAngles85(direction, i);
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.arc(x, y, size * 0.5, angles.start, angles.end);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        let spacing = size * 0.625;
        let radius = size * 0.05;
        let angleSpacing = 22.5;
        for (let i = 0; i < 4; i++) {
          let a = (i * angleSpacing) + ((90 - (angleSpacing * 3)) / 2);
          ctx85.fillCircle(x + (spacing * Math.cos(toRad(a)) * xSign), y + (spacing * Math.sin(toRad(a)) * ySign), radius);
        }
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 10) { // Sun
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let angles = getAngles85(direction, i);
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.arc(x, y, size * 0.5, angles.start, angles.end);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        ctx85.lineCap = ctx85.lineJoin = "round";
        ctx85.lineWidth = size * 0.05;
        let spacing = size * 0.56;
        let dist = size * 0.1;
        for (let j = 0; j < 5; j++) {
          let ca = 18 * (j + 0.5);
          let cx = x + (spacing * Math.cos(toRad(ca)) * xSign);
          let cy = y + (spacing * Math.sin(toRad(ca)) * ySign);
          
          ctx85.beginPath();
          ctx85.moveTo(cx, cy);
          ctx85.lineTo(cx + (dist * Math.cos(toRad(ca)) * xSign), cy + (dist * Math.sin(toRad(ca)) * ySign));
          ctx85.stroke();
        }
        
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 11) { // Slice
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let angles = getAngles85(direction, i);
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.arc(x, y, size * 0.5, angles.start, angles.end);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        ctx85.fillStyle = colors85[1 - p];
        ctx85.beginPath();
        let a = angles.start + toRad(45);
        let spacing = size * 0.2;
        ctx85.moveTo(x + (spacing * Math.cos(a)), y + (spacing * Math.sin(a)));
        ctx85.arc(x, y, size * 0.55, a - toRad(15), a + toRad(15));
        ctx85.fill();
        
        ctx85.fillStyle = colors85[p];
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 12) { // Wheel
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let angles = getAngles85(direction, i);
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.arc(x, y, size * 0.5, angles.start, angles.end);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        ctx85.fillStyle = colors85[1 - p];
        for (let j = 0; j < 3; j++) {
          let ca = (j * 30) + 15 + toDeg(angles.start);
          ctx85.beginPath();
          ctx85.moveTo(x + (size * 0.1 * Math.cos(toRad(ca))), y + (size * 0.1 * Math.sin(toRad(ca))));
          ctx85.arc(x, y, size * 0.45, toRad(ca - 10), toRad(ca + 10));
          ctx85.fill();
        }
        ctx85.fillStyle = colors85[p];
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 13) { // Layers
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let angles = getAngles85(direction, i);
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.arc(x, y, size * 0.5, angles.start, angles.end);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        let dist = size * 0.5 * (1 / 7);
        ctx85.fillStyle = colors85[1 - p];
        ctx85.beginPath();
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        ctx85.arc(x, y, dist * 2, angles.end, angles.start, true);
        ctx85.fill();
        ctx85.beginPath();
        ctx85.arc(x, y, dist * 3, angles.start, angles.end);
        ctx85.arc(x, y, dist * 4, angles.end, angles.start, true);
        ctx85.fill();
        ctx85.beginPath();
        ctx85.arc(x, y, dist * 5, angles.start, angles.end);
        ctx85.arc(x, y, dist * 6, angles.end, angles.start, true);
        ctx85.fill();
        
        ctx85.fillStyle = colors85[p];
        let thickness = 0.25 * (1 / 7);
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.45 * xSign), y);
        ctx85.lineTo(x + (size * 0.45 * xSign), y + (size * thickness * ySign));
        ctx85.lineTo(x + (size * thickness * xSign), y + (size * thickness * ySign));
        ctx85.lineTo(x + (size * thickness * xSign), y + (size * 0.45 * ySign));
        ctx85.lineTo(x, y + (size * 0.45 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 14) { // Face
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        let angles = getAngles85(direction, i);
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.arc(x, y, size * 0.5, angles.start, angles.end);
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        ctx85.fillStyle = colors85[1 - p];
        let eyeSize = size * 0.05;
        let eyeDist = size * 0.38;
        let a = angles.start + toRad(25);
        let mouthDist = size * 0.22;
        let mouthSize = size * 0.1;
        ctx85.fillCircle(x + (eyeDist * Math.cos(a)), y + (eyeDist * Math.sin(a)), eyeSize);
        a = angles.start + toRad(65);
        ctx85.fillCircle(x + (eyeDist * Math.cos(a)), y + (eyeDist * Math.sin(a)), eyeSize);
        
        a = angles.start + toRad(45);
        ctx85.beginPath();
        ctx85.arc(x + (mouthDist * Math.cos(a)), y + (mouthDist * Math.sin(a)), mouthSize, angles.start - toRad(45), angles.end + toRad(45), true);
        ctx85.fill();
        
        ctx85.fillStyle = colors85[p];
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 15) { // Bumps
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        let angles = getAngles85(direction, i);
        
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        let cx = x + (size * 0.5 * xSign);
        let cy = y;
        ctx85.lineTo(cx, cy);
        for (let j = 0; j < 3; j++) {
          cx -= size * (1 / 6) * xSign;
          cy += size * (1 / 6) * ySign;
          let controlX = cx + (size * (1 / 6) * 0.5 * xSign) + (size * 0.3 * Math.cos(angles.start + toRad(45)));
          let controlY = cy - (size * (1 / 6) * 0.5 * ySign) + (size * 0.3 * Math.sin(angles.start + toRad(45)));
          ctx85.quadraticCurveTo(controlX, controlY, cx, cy);
        }
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 16) { // Stair
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        let cx = x + (size * 0.5 * xSign);
        let cy = y;
        ctx85.lineTo(cx, cy);
        cy += size * 0.25 * ySign;
        ctx85.lineTo(cx, cy);
        cx -= size * 0.25 * xSign;
        ctx85.lineTo(cx, cy);
        cy += size * 0.25 * ySign;
        ctx85.lineTo(cx, cy);
        cx -= size * 0.25 * xSign;
        ctx85.lineTo(cx, cy);
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 17) { // Block
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.lineTo(x + (size * (5 / 8) * xSign), y + (size * (1 / 8) * ySign));
        ctx85.lineTo(x + (size * (1 / 8) * xSign), y + (size * (5 / 8) * ySign));
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 18) { // Joint
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        let thickness = 0.075;
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y + (size * thickness * ySign));
        ctx85.lineTo(x + (size * thickness * xSign), y + (size * thickness * ySign));
        ctx85.lineTo(x + (size * thickness * xSign), y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        ctx85.beginPath();
        ctx85.moveTo(x + (size * (0.4 + (thickness * Math.SQRT1_2)) * xSign), y);
        ctx85.lineTo(x, y + (size * (0.4 + (thickness * Math.SQRT1_2)) * ySign));
        ctx85.lineTo(x, y + (size * (0.4 - (thickness * Math.SQRT1_2)) * ySign));
        ctx85.lineTo(x + (size * (0.4 - (thickness * Math.SQRT1_2)) * xSign), y);
        ctx85.fill();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 19) { // Hammer
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        let angles = getAngles85(direction, i);
        
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y);
        ctx85.lineTo(x + (size * 0.5 * xSign), y + (size * 0.35 * ySign));
        ctx85.lineTo(x + (size * 0.35 * xSign), y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        let len = size * 0.13;
        let ratio = 0.075 + 0.04;
        ctx85.beginPath();
        ctx85.fillStyle = colors85[1 - p];
        let ca = toDeg(angles.start) + 135;
        let cx = x + (size * (0.425 + 0.05) * xSign);
        let cy = y + (size * (0.425 + 0.05) * ySign);
        ctx85.moveTo(cx, cy);
        cx += len * 0.5 * Math.cos(toRad(ca));
        cy += len * 0.5 * Math.sin(toRad(ca));
        ctx85.lineTo(cx, cy);
        ca += 90;
        cx += (len + (size * ratio)) * Math.cos(toRad(ca));
        cy += (len + (size * ratio)) * Math.sin(toRad(ca));
        ctx85.lineTo(cx, cy);
        ca -= 90;
        cx += len * Math.cos(toRad(ca));
        cy += len * Math.sin(toRad(ca));
        ctx85.lineTo(cx, cy);
        ca += 90;
        cx += len * Math.cos(toRad(ca));
        cy += len * Math.sin(toRad(ca));
        ctx85.lineTo(cx, cy);
        ca += 90;
        cx += len * 3 * Math.cos(toRad(ca));
        cy += len * 3 * Math.sin(toRad(ca));
        ctx85.lineTo(cx, cy);
        ca += 90;
        cx += len * Math.cos(toRad(ca));
        cy += len * Math.sin(toRad(ca));
        ctx85.lineTo(cx, cy);
        ca += 90;
        cx += len * Math.cos(toRad(ca));
        cy += len * Math.sin(toRad(ca));
        ctx85.lineTo(cx, cy);
        ca -= 90;
        cx += (len + (size * ratio)) * Math.cos(toRad(ca));
        cy += (len + (size * ratio)) * Math.sin(toRad(ca));
        ctx85.lineTo(cx, cy);
        ctx85.lineTo(x + (size * (0.425 + 0.05) * xSign), y + (size * (0.425 + 0.05) * ySign));
        ctx85.fill();
        
        ctx85.fillStyle = colors85[p];
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
    
    if (type === 20) { // Spikes
      let x = x1;
      let y = y1;
      for (let i = 0; i < 2; i++) {
        let angles = getAngles85(direction, i);
        
        ctx85.beginPath();
        ctx85.moveTo(x, y);
        let cx = x + (size * 0.5 * xSign);
        let cy = y;
        ctx85.lineTo(cx, cy);
        for (let j = 0; j < 4; j++) {
          cx -= size * 0.125 * xSign;
          cy += size * 0.125 * ySign;
          let controlX = cx + (size * 0.125 * 0.5 * xSign) + (size * 0.25 * Math.cos(angles.start + toRad(45)));
          let controlY = cy - (size * 0.125 * 0.5 * ySign) + (size * 0.25 * Math.sin(angles.start + toRad(45)));
          ctx85.lineTo(controlX, controlY);
          ctx85.lineTo(cx, cy);
        }
        ctx85.lineTo(x, y + (size * 0.5 * ySign));
        ctx85.lineTo(x, y);
        ctx85.fill();
        
        x = x2;
        y = y2;
        xSign *= -1;
        ySign *= -1;
      }
      
      return;
    }
  }
  
  function randTile85() {
    return selectedTiles85[Math.floor(Math.random() * selectedTiles85.length)];
  }
  function randBool85() {
    return Math.random() < 0.5;
  }
  
  function draw85() {
    ctx85.clearRect(0, 0, canvas85.width, canvas85.height);
    
    canvas85.width = canvas85.height = gridSize85 * Math.round(1000 / gridSize85);
    
    let tileSize = canvas85.width / gridSize85;
    
    /*ctx85.fillStyle = "red";
    ctx85.fillRect(0, 0, 1000, 1000);
    drawTile85(250, 250, 500, 0, 0, randTile85());
    return;*/
    
    let grid = [];
    for (let x = 0; x < gridSize85; x++) {
      let row = [];
      for (let y = 0; y < gridSize85; y++) {
        row.push({});
      }
      grid.push(row);
    }
    
    for (let x = 0; x < gridSize85; x++) {
      for (let y = 0; y < gridSize85; y++) {
        let lastTile;
        if (x === 0 && y === 0) lastTile = {direction: randBool85(), parity: randBool85()};
        else if (x === 0) lastTile = grid[x][y - 1];
        else lastTile = grid[x - 1][y];
        
        let direction = randBool85();
        
        grid[x][y] = {direction: direction, parity: XOR85(lastTile.direction, XNOR85(lastTile.parity, direction))};
        drawTile85(x * tileSize, y * tileSize, tileSize, grid[x][y].direction, grid[x][y].parity, randTile85());
      }
    }
  }
  draw85();
</script>
<canvas id = "canvas84" style = "width: 400px; height: 400px"></canvas>
<button onclick = "draw84()">New Profiles</button>
<p><b>Possible usernames: <span id = "numUsernames84Txt"></span></b></p>
<div class = "desc"><b><i>(5/16/2022)</i></b> Random profile generator--I have lists of hundreds of adjectives and nouns and each profile gets a random selection of those, connected and capitalized randomly. I also added random profile pictures, using mirrored random pixels. I want to have different kinds of profile pictures, maybe some with random shapes instead of only pixels.<br><b><i>Update: (Later that day)</i></b> I made it so that 5 profiles generate every time to see the variation, and also added a new kind of random profile picture that draws a random polygon or star with a random number of sides/points. I later also added a new profile picture that draws a random dice roll.<br><b><i>Update: (Later that day)</i></b> Added more nouns/adjectives, and also added a new profile picture type that parodies the default silhouette, but with googly eyes.<br><b><i>(5/17/2022)</i></b> Added a failsafe so that no username will be above 30 characters long, so I don't have to worry about going past the screen even if I add longer words.<br><b><i><mark>Actually finished! (5/17/2022)</mark> Moved to <a href = "profile-generator.html" target = "_blank">profile-generator.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx84 = canvas84.getContext("2d");
  canvas84.width = 1000;
  canvas84.height = 1000;
  
  const RATIO84A = Math.sqrt(3) / 3;
  
  let articles84 = ["", "the", "very", "really", "some"];
  let adjectives84 = ["happy", "sad", "ecstatic", "depressed", "lonely", "outgoing", "fuzzy", "fluffy", "shiny", "red", "yellow", "green", "blue", "purple", "indigo", "black", "white", "gray", "cyan", "skinny", "fat", "tall", "short", "beautiful", "adorable", "stunning", "pointy", "sharp", "edible", "incredible", "amazing", "weird", "smart", "fancy", "loud", "quiet", "silent", "soaked", "squishy", "exterior", "interior", "flying", "dead", "undead", "young", "old", "spiky", "cold", "hot", "frozen", "melted", "burnt", "broken", "lost", "brittle", "crazy", "insane", "unstable", "stable", "stealthy", "obvious", "common", "uncommon", "rare", "epic", "legendary", "mythical", "first", "second", "third", "fourth", "fifth", "unbelievable", "ridiculous", "ancient", "modern", "contemporary", "rusty", "rusted", "rotten", "shattered", "dusty", "forgotten", "worn", "smiling", "laughing", "crying", "smirking", "gasping", "scared", "brave", "cowardly", "inventive", "petty", "quick", "speedy", "slow", "unstoppable", "charged", "drained", "jumpy", "clumsy", "massive", "big", "huge", "tiny", "little", "small", "average", "extraordinary", "ordinary", "blossoming", "blooming", "sunny", "cloudy", "dry", "wet", "aquatic", "friendly", "accelerated", "boring", "exciting", "flaming", "icy", "earthen", "muddy", "salty", "sweet", "sour", "bitter", "smooth", "rough", "unexpected", "cool", "awesome", "lame", "blind", "deaf", "mute", "aggressive", "calm", "confident", "overconfident", "insecure", "slippery", "slimy", "sticky", "picky", "bratty", "chilly", "sideways", "clean", "soapy", "boiling", "foreign", "torn", "scratchy", "sparky", "circular", "rectangular", "hexagonal", "pentagonal", "elliptic", "round", "square", "triangular", "spherical", "cubic", "odorless", "connected", "disconnected", "fizzy", "carbonated", "sugary", "caffeinated", "soft", "baby", "elderly", "spinning", "rotating", "revolving", "disposable", "timed", "obscure", "fiery", "flat", "artistic", "famous", "infamous", "invisible", "visible", "stuffed", "sandy", "carpeted", "empty", "abandoned", "derelict", "deserted", "overloaded", "nautical", "alluring", "attractive", "merciful", "gracious", "kind", "loving", "magnificent", "malevolent", "evil", "dark", "despicable", "popular", "unpopular", "distant", "safe", "dangerous", "unknown", "anonymous", "faulty", "operational", "rich", "poor", "wealthy", "clever", "fragile", "sturdy", "funny", "funky", "musical", "strange", "sneaky", "kingly", "royal", "stone", "gold", "silver", "bronze", "metallic", "nostalgic", "sickly", "healthy", "eerie", "mysterious", "electric", "heavy", "light", "disguised", "hidden", "covert", "armed", "deadly", "fatal", "toxic", "poisonous", "venomous", "carnivorous", "pacifist", "furious", "inferior", "superior", "glossy", "savory", "unamused", "immovable", "constant", "comatose", "brainy", "handsome", "scalding", "pretty", "cute", "charming", "rude", "mean", "harsh", "extroverted", "introverted", "charismatic", "hostile", "comfortable", "uncomfortable", "cozy", "snuggly", "drunk", "drunken", "high", "low", "large", "medium", "beloved", "respectable", "respected", "influential", "efficient", "inefficient", "effective", "ineffective", "bothersome", "trashy", "rejected", "desolate", "hopeless", "hopeful", "sarcastic", "ironic", "competent", "incompetent", "sleepy", "sleeping", "unconscious", "lucid", "joyous", "glorious", "exalted", "cyclic", "advanced", "backwards", "honest", "tricky", "lying", "last", "final", "ultimate", "highest", "lowest", "glorified", "stupendous"];
  
  let nouns84 = [];
  let nouns84a = ["chair", "table", "duck", "dog", "cat", "person", "human", "napkin", "donut", "burrito", "taco", "plate", "bone", "pants", "tuxedo", "pizza", "bird", "eagle", "bottle", "cow", "horse", "tree", "bush", "plant", "animal", "grass", "shrub", "star", "galaxy", "planet", "moon", "sun", "curtain", "carpet", "pole", "candy", "lollipop", "chocolate", "butter", "peanut", "almond", "pistachio", "walnut", "cashew", "fruit", "apple", "lemon", "pear", "avocado", "guacamole", "milk", "cereal", "hat", "cowboy", "lawyer", "doctor", "plum", "peach", "asparagus", "pepper", "carrot", "cake", "cupcake", "brownie", "cookie", "bean", "beef", "pork", "meat", "student", "teacher", "flag", "paper", "laptop", "computer", "keyboard", "typewriter", "architect", "engineer", "scientist", "chemist", "biologist", "business", "phone", "bench", "novel", "calzone", "restaurant", "tank", "cannon", "fire", "ice", "water", "wind", "rifle", "sniper", "soldier", "gun", "bullet", "eyeball", "nose", "ear", "arm", "leg", "hand", "finger", "elbow", "shoulder", "knee", "foot", "toe", "door", "window", "doorknob", "thing", "item", "character", "pencil", "pen", "marker", "store", "wallet", "money", "glasses", "hair", "food", "drawer", "bread", "loaf", "juice", "bowl", "floor", "wall", "fence", "principal", "astronaut", "astronomer", "astrologer", "artist", "plumber", "welder", "diver", "swimmer", "fish", "shark", "dolphin", "deer", "buck", "platypus", "bear", "parrot", "dynamite", "bomb", "crown", "king", "queen", "prince", "princess", "assistant", "merchant", "pirate", "ninja", "samurai", "sword", "crossbow", "arrow", "letter", "axe", "mace", "spear", "shield", "fortress", "castle", "house", "building", "kingdom", "catapult", "trebuchet", "loser", "winner", "skeleton", "witch", "skull", "broom", "monster", "alien", "sailor", "boat", "ship", "warrior", "nation", "country", "state", "island", "ocean", "lake", "stream", "river", "pond", "puddle", "storm", "cloud", "lightning", "mountain", "hill", "valley", "dragon", "beast", "key", "fridge", "freezer", "microwave", "oven", "toaster", "shower", "bathtub", "cord", "lamp", "cactus", "flower", "stem", "leaf", "acorn", "seed", "crab", "seashell", "shell", "tail", "car", "truck", "minivan", "scooter", "tricycle", "bicycle", "skateboard", "sandal", "clover", "rug", "cube", "square", "rectangle", "triangle", "pyramid", "sphere", "circle", "hexagon", "pentagon", "dollar", "egg", "chip", "potato", "fry", "kid", "child", "adult", "teen", "teenager", "youngling", "senior", "junior", "sophomore", "freshman", "pea", "couch", "armchair", "board", "plank", "scythe", "sunglasses", "disguise", "pearl", "eyepatch", "jeans", "pillow", "blanket", "quilt", "bonfire", "campfire", "ant", "anteater", "wasp", "bee", "butterfly", "moth", "hornet", "ketchup", "mustard", "mayo", "burger", "scarecrow", "crow", "raven", "poet", "dreamer", "girl", "boy", "guy", "dude", "chick", "man", "woman", "lady", "female", "male", "month", "week", "day", "hour", "minute", "year", "decade", "century", "life", "coffee", "latte", "steam", "beard", "puppy", "kitten", "backpack", "school", "eraser", "caterpillar", "tissue", "towel", "beetle", "fang", "tooth", "brush", "assassin", "killer", "murderer", "staircase", "hero", "savior", "dictator", "president", "politician", "word", "superhero", "villain", "pot", "soup", "toy", "pocket", "dress", "tie", "wig", "pain", "death", "card", "candle", "rock", "stone", "pebble", "boulder", "cliff", "tower", "bridge", "panda", "worm", "snake", "cobra", "harmonica", "piano", "guitar", "violin", "drum", "flute", "kazoo", "brick", "fireplace", "cork", "shard", "slice", "tuba", "trumpet", "saxophone", "disciple", "apostle", "follower", "leader", "chief", "commander", "captain", "colonel", "hunter", "bandit", "thief", "burglar", "robot", "android", "machine", "golem", "bot", "mercenary", "vigilante", "fork"];
  let nouns84b = ["knife", "chopstick", "belt", "band", "mug", "cup", "tea", "bag", "box", "podium", "feather", "claw", "talon", "quill", "blaster", "tiger", "lion", "prodigy", "shelter", "foundation", "corn", "seafood"];
  nouns84 = nouns84a.concat(nouns84b);
  let connectors84 = ["", "-", "_"];
  
  function randArticle84() {
    return articles84[Math.floor(Math.random() * Math.random() * articles84.length)];
  }
  function randAdjective84() {
    return adjectives84[Math.floor(Math.random() * adjectives84.length)];
  }
  function randNoun84() {
    return nouns84[Math.floor(Math.random() * nouns84.length)];
  }
  function randNums84() {
    return String(Math.floor(Math.random() * 10)) + String(Math.floor(Math.random() * 10));
  }
  function randConnector84() {
    return connectors84[Math.floor(Math.random() * connectors84.length)];
  }
  function capitalize84(string, mode) {
    if (mode === 0) return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase(); // Titlecase
    if (mode === 1) return string.toLowerCase(); // lowercase
    if (mode === 2) return string.toUpperCase(); // UPPERCASE
  }
  
  function drawPolygon84(context, x, y, radius, sides) {
    let a = (Math.PI * 2) / sides;
    
    context.beginPath();
    
    context.moveTo(x, y - radius);
    
    for (let i = 0; i <= sides + 1; i++) {
      context.lineTo(x + (radius * Math.cos((a * i) - (Math.PI / 2))), y + (radius * Math.sin((a * i) - (Math.PI / 2))));
    }
  }
  function drawStar84(context, x, y, outRadius, inRadius, points) {
    let a = (Math.PI * 2) / points;
    
    context.beginPath();
    
    context.moveTo(x, y - outRadius);
    context.lineTo(x + (inRadius * Math.cos((a / 2) - (Math.PI / 2))), y + (inRadius * Math.sin((a / 2) - (Math.PI / 2))));
    
    for (let i = 0; i <= points + 2; i++) {
      context.lineTo(x + (outRadius * Math.cos((a * i) - (Math.PI / 2))), y + (outRadius * Math.sin((a * i) - (Math.PI / 2))));
      context.lineTo(x + (inRadius * Math.cos((a * (i + 0.5)) - (Math.PI / 2))), y + (inRadius * Math.sin((a * (i + 0.5)) - (Math.PI / 2))));
    }
  }
  
  function drawRoundedRect84(context, x, y, width, height, cornerRadius) {
    if (typeof cornerRadius === "number") cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
    
    context.beginPath();
    context.moveTo(x + cornerRadius[0], y);
    context.lineTo(x + width - cornerRadius[1], y);
    context.quadraticCurveTo(x + width, y, x + width, y + cornerRadius[1]);
    context.lineTo(x + width, y + height - cornerRadius[2]);
    context.quadraticCurveTo(x + width, y + height, x + width - cornerRadius[2], y + height);
    context.lineTo(x + cornerRadius[3], y + height);
    context.quadraticCurveTo(x, y + height, x, y + height - cornerRadius[3]);
    context.lineTo(x, y + cornerRadius[0]);
    context.quadraticCurveTo(x, y, x + cornerRadius[0], y);
  }
  function drawRoundedRectFromCenter84(context, x, y, width, height, cornerRadius) {
    drawRoundedRect84(context, x - (width / 2), y - (width / 2), width, height, cornerRadius);
  }
  
  function longestUsername84() {
    let longest = 0;
    let article = "";
    for (let i = 0; i < articles84.length; i++) {
      if (articles84[i].length > longest) {
        longest = articles84[i].length;
        article = articles84[i];
      }
    }
    
    longest = 0;
    let adjective = "";
    for (let i = 0; i < adjectives84.length; i++) {
      if (adjectives84[i].length > longest) {
        longest = adjectives84[i].length;
        adjective = adjectives84[i];
      }
    }
    
    longest = 0;
    let noun = "";
    for (let i = 0; i < nouns84.length; i++) {
      if (nouns84[i].length > longest) {
        longest = nouns84[i].length;
        noun = nouns84[i];
      }
    }
    
    return capitalize84(article + "_" + adjective + "_" + noun + "99", 0);
  }
  
  function User84() {
    this.setUsername();
  }
  User84.prototype.setUsername = function() {  
    let textCase = Math.floor(Math.random() * Math.random() * 3);
    
    let connector = randConnector84();
    
    let article = capitalize84(randArticle84(), textCase);
    let start = "";
    if (article !== "") start = article + connector;
    
    let adjective = capitalize84(randAdjective84(), textCase);
    
    let noun = capitalize84(randNoun84(), textCase);
    
    this.username = start + adjective + connector + noun + randNums84();
    if (this.username.length > 30) {
      console.log(this.username + " was too long.");
      this.setUsername();
    }
    //this.username = longestUsername84();
    // Uncomment the above line for an example of longest possible username to make sure nothing ever overflows
  };
  User84.prototype.setProfilePicture = function(size) {
    let _canvas = document.createElement("canvas");
    let _ctx = _canvas.getContext("2d");
    _canvas.width = _canvas.height = size;
    
    let mode = Math.floor(Math.random() * 4);
    if (mode === 3 && Math.random() < 0.5) mode = Math.floor(Math.random() * 4);
    
    let hue1 = Math.random() * 360;
    let color1 = `hsl(${hue1}deg, ${randBetween(50, 100)}%, ${randBetween(30, 70)}%)`;
    let color2 = `hsl(${hue1 + 180 + randBetween(-15, 15)}deg, ${randBetween(80, 100)}%, ${randBetween(30, 70)}%)`;
    
    // Draw background
    
    _ctx.fillStyle = color1;
    _ctx.fillRect(0, 0, _canvas.width, _canvas.height);
    
    if (mode === 0) { // Mirrored random pixels
      _ctx.fillStyle = color2;
      let staticOn = Math.random() < 0.5; // If this is on, then the mirrored pixels will be random colors instead of all the same color
      
      let gridSize = 10;
      let tileSize = _canvas.width / gridSize;
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize / 2; x++) {
          if (staticOn) _ctx.fillStyle = `hsl(${hue1 + 180 + randBetween(-15, 15)}deg, ${randBetween(80, 100)}%, ${randBetween(20, 80)}%)`;
          else _ctx.fillStyle = color2;
          let odds = staticOn ? 1 : 0.5;
          
          if (Math.random() < odds) {
            _ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
            _ctx.fillRect((gridSize - x - 1) * tileSize, y * tileSize, tileSize, tileSize);
          }
        }
      }
    }
    
    else if (mode === 1) { // Random polygon / star
      _ctx.fillStyle = `hsl(${Math.random() * 360}deg, ${randBetween(50, 100)}%, ${randBetween(30, 70)}%)`;
      _ctx.strokeStyle = color2;
      _ctx.lineWidth = _canvas.width * randBetween(0.04, 0.08);
      
      let sides = Math.round(randBetween(3, 8));
      let isPolygon = Math.random() < 0.5;
      
      if (isPolygon) {
        if (sides === 3) drawPolygon84(_ctx, _canvas.width / 2, _canvas.height * RATIO84A, _canvas.width * 0.4, sides);
        else drawPolygon84(_ctx, _canvas.width / 2, _canvas.height / 2, _canvas.width * 0.4, sides);
        _ctx.fill();
        _ctx.stroke();
      }
      else {
        if (sides === 3) drawStar84(_ctx, _canvas.width / 2, _canvas.height * RATIO84A, _canvas.width * 0.4, _canvas.width * 0.1, sides);
        else drawStar84(_ctx, _canvas.width / 2, _canvas.height / 2, _canvas.width * 0.4, _canvas.width * 0.2, sides);
        _ctx.fill();
        _ctx.stroke();
      }
    }
    
    else if (mode === 2) { // Random dice roll
      color2 = `hsl(${Math.random() * 360}deg, ${randBetween(80, 100)}%, ${randBetween(30, 50)}%)`;
      
      _ctx.fillStyle = "white";
      _ctx.strokeStyle = color2;
      _ctx.lineWidth = _canvas.width * 0.05;
      
      let pipSize = _canvas.width * 0.06;
      
      drawRoundedRectFromCenter84(_ctx, _canvas.width / 2, _canvas.height / 2, _canvas.width * 0.8, _canvas.height * 0.8, _canvas.width * 0.15);
      _ctx.fill();
      _ctx.stroke();
      
      _ctx.fillStyle = color2;
      let roll = Math.ceil(Math.random() * 6);
      switch (roll) {
        case 1:
          _ctx.fillCircle(_canvas.width / 2, _canvas.height / 2, pipSize);
        break;
        case 2:
          _ctx.fillCircle(_canvas.width * 0.3, _canvas.height * 0.7, pipSize);
          _ctx.fillCircle(_canvas.width * 0.7, _canvas.height * 0.3, pipSize);
        break;
        case 3:
          _ctx.fillCircle(_canvas.width * 0.3, _canvas.height * 0.7, pipSize);
          _ctx.fillCircle(_canvas.width / 2, _canvas.height / 2, pipSize);
          _ctx.fillCircle(_canvas.width * 0.7, _canvas.height * 0.3, pipSize);
        break;
        case 4:
          _ctx.fillCircle(_canvas.width * 0.3, _canvas.height * 0.7, pipSize);
          _ctx.fillCircle(_canvas.width * 0.7, _canvas.height * 0.3, pipSize);
          _ctx.fillCircle(_canvas.width * 0.3, _canvas.height * 0.3, pipSize);
          _ctx.fillCircle(_canvas.width * 0.7, _canvas.height * 0.7, pipSize);
        break;
        case 5:
          _ctx.fillCircle(_canvas.width * 0.3, _canvas.height * 0.7, pipSize);
          _ctx.fillCircle(_canvas.width * 0.7, _canvas.height * 0.3, pipSize);
          _ctx.fillCircle(_canvas.width / 2, _canvas.height / 2, pipSize);
          _ctx.fillCircle(_canvas.width * 0.3, _canvas.height * 0.3, pipSize);
          _ctx.fillCircle(_canvas.width * 0.7, _canvas.height * 0.7, pipSize);
        break;
        case 6:
          _ctx.fillCircle(_canvas.width * 0.3, _canvas.height * 0.3, pipSize);
          _ctx.fillCircle(_canvas.width * 0.7, _canvas.height * 0.3, pipSize);
          _ctx.fillCircle(_canvas.width * 0.3, _canvas.height / 2, pipSize);
          _ctx.fillCircle(_canvas.width * 0.7, _canvas.height / 2, pipSize);
          _ctx.fillCircle(_canvas.width * 0.3, _canvas.height * 0.7, pipSize);
          _ctx.fillCircle(_canvas.width * 0.7, _canvas.height * 0.7, pipSize);
        break;
      }
    }
    
    else if (mode === 3) { // Silhouette default profile picture
      _ctx.fillStyle = color2;
      _ctx.fillCircle(_canvas.width / 2, _canvas.height, _canvas.width * 0.4);
      _ctx.fillCircle(_canvas.width / 2, _canvas.height * 0.3, _canvas.width * 0.2);
      
      let eyeRadius = _canvas.width * 0.06;
      let eyeY = _canvas.height * 0.3;
      let leftEyeX = _canvas.width * 0.4;
      let rightEyeX = _canvas.width * 0.6;
      
      _ctx.fillStyle = "white";
      _ctx.fillCircle(leftEyeX, eyeY, eyeRadius);
      _ctx.fillCircle(rightEyeX, eyeY, eyeRadius);
      
      let pupilRadius = _canvas.width * 0.04;
      let pupilOffset = eyeRadius - pupilRadius;
      let pupilAngle = Math.random() * Math.PI * 2;
      
      _ctx.fillStyle = "black";
      
      _ctx.fillCircle(leftEyeX + (pupilOffset * Math.cos(pupilAngle)), eyeY + (pupilOffset * Math.sin(pupilAngle)), pupilRadius);
      
      if (Math.random() < 0.25) pupilAngle = Math.random() * Math.PI * 2;
      
      _ctx.fillCircle(rightEyeX + (pupilOffset * Math.cos(pupilAngle)), eyeY + (pupilOffset * Math.sin(pupilAngle)), pupilRadius);
    }
    
    this.profilePicture = _ctx.getImageData(0, 0, _canvas.width, _canvas.height);
  };
  
  function draw84() {
    ctx84.clearRect(0, 0, canvas84.width, canvas84.height);
    
    numUsernames84Txt.innerHTML = (articles84.length * connectors84.length * adjectives84.length * nouns84.length * 300).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    // Possible articles, times possible connectors, times possible adjectives, times possible nouns, times possible capitalization cases (3), times possible numbers at the end (100)
    
    for (let i = 0; i < 5; i++) {
      let iY = i * 200;
      
      let user = new User84();
      user.setProfilePicture(150);
      
      ctx84.putImageData(user.profilePicture, 25, 25 + iY);
      
      ctx84.font = "bold 40px monospace";
      ctx84.textAlign = "left";
      ctx84.textBaseline = "middle";
      ctx84.fillText(user.username, 200, 100 + iY);
    }
  }
  draw84();
  
  function hasDuplicates84(arr) {
    let duplicates = [];
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length; j++) {
        if (i !== j) {
          if (arr[i] === arr[j] && !duplicates.includes(arr[i])) duplicates.push(arr[i]);
        }
      }
    }
    
    return duplicates;
  }
  
  function averageRandTries84(x) {
    // Return the average number of times Math.random() has to be called before it is less than X
    let totalTries = 0;
    for (let i = 0; i < 10000; i++) {
      let tries = 0;
      let curr = Math.random();
      while (curr >= x) {
        tries++;
        curr = Math.random();
      }
      totalTries += tries;
    }
    return Math.round(totalTries / 10000);
  }
</script>
<canvas id = "canvas83"></canvas>
<button onclick = "draw83()">Regenerate</button>
<div class = "desc"><b><i>(5/6/2022)</i></b> A failed attempt to make generative art that resembled tribal beads or bracelets or something like that, I liked the idea of connecting circles with lines to make bead-like shapes but I didn't know how to place them on the canvas or how to set the settings right to make it look like I was wanting, so it looks pretty bad right now. I might go back and fix this at some point but I'm not sure what I want to do with it.</div>
<hr><hr>
<script>
  const ctx83 = canvas83.getContext("2d");
  canvas83.width = canvas83.height = 1000;
  
  function randColor83(hue) {
    return `hsl(${hue + randBetween(-15, 15)}deg, ${randBetween(50, 100)}%, ${randBetween(35, 65)}%)`;
  }
  
  function drawBeads83(x, y, angle, stringLength, numBeads, beadRadius, angleVariation, hue) {
    ctx83.fillStyle = ctx83.strokeStyle = randColor83(hue);
    ctx83.lineWidth = 3;
    ctx83.lineCap = ctx83.lineJoin = "round";
    
    let len = stringLength / (numBeads - 1);
    
    let cx = x;
    let cy = y;
    let ca = angle;
    
    let beads = [];
    
    for (let i = 0; i < numBeads; i++) {
      beads.push({x: cx, y: cy});
      
      cx += len * Math.cos(toRad(ca));
      cy += len * Math.sin(toRad(ca));
      ca += randBetween(-angleVariation, angleVariation);
    }
    
    ctx83.beginPath();
    ctx83.moveTo(x, y);
    for (let i = 0; i < beads.length; i++) {
      ctx83.lineTo(beads[i].x, beads[i].y);
    }
    ctx83.stroke();
    
    for (let i = 0; i < beads.length; i++) {
      ctx83.fillCircle(beads[i].x, beads[i].y, beadRadius);
    }
  }
  
  function draw83() {
    ctx83.fillStyle = "black";
    ctx83.fillRect(0, 0, canvas83.width, canvas83.height);
    
    ctx83.lineWidth = 2;
    ctx83.strokeStyle = "white";
    ctx83.beginPath();
    ctx83.moveTo(0, canvas83.height * 0.3);
    ctx83.lineTo(canvas83.width, canvas83.height * 0.3);
    ctx83.stroke();
    
    let numGroups = 25;
    let stringsPerGroup = 10;
    
    for (let i = 0; i < numGroups; i++) {
      let angle = 90//((i + randBetween(-0.5, 0.5)) / numGroups) * 360;
      let x = Math.random() * canvas83.width//(canvas83.width * 0.5) + (canvas83.width * 0.5 * Math.cos(toRad(angle)));
      let y = canvas83.height * 0.3;
      let stringLength = randBetween(100, 400) / 2;
      let numBeads = Math.round(randBetween(5, 10));
      let beadRadius = randBetween(5, 10) / 2;
      let angleVariation = randBetween(25, 65) / 2;
      let hue = Math.random() * 360;
      
      for (let j = 0; j < stringsPerGroup; j++) {
        drawBeads83(
          x, // x
          y, // y
          angle,// + randBetween(-15, 15), // angle
          stringLength * randBetween(0.9, 1.1), // stringLength
          numBeads + Math.round(randBetween(-2, 2)), // numBeads
          beadRadius * randBetween(0.9, 1.1), // beadRadius
          angleVariation * randBetween(0.75, 1.25), // angleVariation
          hue
        );
      }
    }
    
    /*let numGroups = 25;
    let stringsPerGroup = 10;
    
    for (let i = 0; i < numGroups; i++) {
      let angle = ((i + randBetween(-0.5, 0.5)) / numGroups) * 360;
      let x = (canvas83.width * 0.5) + (canvas83.width * 0.5 * Math.cos(toRad(angle)));
      let y = (canvas83.height * 0.5) + (canvas83.height * 0.5 * Math.sin(toRad(angle)));
      let stringLength = randBetween(100, 400);
      let numBeads = Math.round(randBetween(5, 10)) * 10;
      let beadRadius = 0//randBetween(5, 10);
      let angleVariation = randBetween(25, 65) / 4;
      let hue = Math.random() * 360;
      
      for (let j = 0; j < stringsPerGroup; j++) {
        drawBeads83(
          x, // x
          y, // y
          angle + 180,// + randBetween(-15, 15), // angle
          stringLength * randBetween(0.9, 1.1), // stringLength
          numBeads + Math.round(randBetween(-2, 2)), // numBeads
          beadRadius * randBetween(0.9, 1.1), // beadRadius
          angleVariation * randBetween(0.75, 1.25), // angleVariation
          hue
        );
      }
    }*/
  }
  draw83();
</script>
<canvas id = "canvas82"></canvas>
<button onclick = "draw82()">Regenerate</button>
<div class = "desc"><b><i>(5/5/2022)</i></b> An attempt to do circle packing recursion, but with squares. For some reason, the squares start inside each other and also don't reach towards each other.<br><b><i>Update: (A few minutes later)</i></b> I fixed the bug and now the squares pack correctly. Now I want to add recursion and alternate packing black squares in white squares and vice versa, to create contrasting layers of squares inside squares.<br><b><i>Update: (Later that day)</i></b> I got the recursion working, so now there's 3 layers of packed squares. I'm not sure how much I love the final result, but it looks cool enough.</div>
<hr><hr>
<script>
  const ctx82 = canvas82.getContext("2d");
  canvas82.width = canvas82.height = 1000;
  
  let currFilled82 = false;
  let maxTries82 = 1000;
  let minSizeRatio82 = 0.1;
  let maxSizeRatio82 = 0.2;
  let visualSizeRatio82 = 0.95;
  
  function validatePoint82(testX, testY, boundX, boundY, boundSize, squareArray) {
    let minSize = boundSize * minSizeRatio82;
    
    for (let i = 0; i < squareArray.length; i++) {
      let dx = Math.abs(testX - squareArray[i].x) - (squareArray[i].size / 2);
      let dy = Math.abs(testY - squareArray[i].y) - (squareArray[i].size / 2);
      if (dx < minSize && dy < minSize) return false;
    }
    
    let distToLeft = testX - boundX;
    let distToRight = (boundX + boundSize) - testX;
    let distToTop = testY - boundY;
    let distToBottom = (boundY + boundSize) - testY;
    
    if (distToLeft < minSize) return false;
    if (distToRight < minSize) return false;
    if (distToTop < minSize) return false;
    if (distToBottom < minSize) return false;
    
    return true;
  }
  
  function Square82(boundX, boundY, boundSize, isBlack, squareArray) {
    this.boundX = boundX;
    this.boundY = boundY;
    this.boundSize = boundSize;
    
    this.isBlack = isBlack;
    
    this.squareArray = squareArray;
    
    this.x = 0;
    this.y = 0;
    this.size = 0;
    
    this.init();
  }
  Square82.prototype.init = function() {
    let x = randBetween(this.boundX, this.boundX + this.boundSize);
    let y = randBetween(this.boundY, this.boundY + this.boundSize);
    
    let tries = 0;
    
    while (!validatePoint82(x, y, this.boundX, this.boundY, this.boundSize, this.squareArray)) {
      if (tries > maxTries82) {
        currFilled82 = true;
        return;
      }
      
      x = randBetween(this.boundX, this.boundX + this.boundSize);
      y = randBetween(this.boundY, this.boundY + this.boundSize);
      
      tries++;
    }
    
    this.x = x;
    this.y = y;
    this.size = 0;
    this.grow();
  };
  Square82.prototype.grow = function() {
    let smallestDist = Infinity;
    
    for (let i = 0; i < this.squareArray.length; i++) {
      if (i !== this.squareArray.indexOf(this)) {
        let dx = Math.abs(this.squareArray[i].x - this.x) - (this.squareArray[i].size / 2);
        let dy = Math.abs(this.squareArray[i].y - this.y) - (this.squareArray[i].size / 2);
        
        let dist = Math.max(dx, dy);
        if (dist < smallestDist) smallestDist = dist;
      }
    }
    
    let distToLeft = this.x - this.boundX;
    let distToRight = (this.boundSize + this.boundX) - this.x;
    let distToTop = this.y - this.boundY;
    let distToBottom = (this.boundSize + this.boundY) - this.y;
    
    if (distToLeft < smallestDist) smallestDist = distToLeft;
    if (distToRight < smallestDist) smallestDist = distToRight;
    if (distToTop < smallestDist) smallestDist = distToTop;
    if (distToBottom < smallestDist) smallestDist = distToBottom;
    
    let maxSize = this.boundSize * maxSizeRatio82;
    this.size = Math.min(smallestDist, maxSize) * 2
    
    ctx82.fillStyle = ctx82.strokeStyle = this.isBlack ? "black" : "white";
    ctx82.fillRectFromCenter(this.x, this.y, this.size * visualSizeRatio82, this.size * visualSizeRatio82);
    ctx82.strokeRectFromCenter(this.x, this.y, this.size * visualSizeRatio82, this.size * visualSizeRatio82);
  };
  
  function packSquares82(x, y, size, count, isBlack) {
    //ctx82.fillStyle = "rgba(0, 0, 0, 0.3)";
    //ctx82.fillRect(x, y, size, size);
    
    let _x = x - (size / 2);
    let _y = y - (size / 2);
    
    let squareArray = [];
    currFilled82 = false;
    
    while (squareArray.length < count && !currFilled82) squareArray.push(new Square82(_x, _y, size, isBlack, squareArray));
    
    return squareArray;
  }
  
  function draw82() {
    ctx82.fillStyle = "white";
    ctx82.fillRect(0, 0, canvas82.width, canvas82.height);
    
    let prevRatio = visualSizeRatio82;
    
    let squares1 = packSquares82(canvas82.width / 2, canvas82.height / 2, canvas82.width, 100, true);
    let ratio1 = visualSizeRatio82;
    visualSizeRatio82 *= visualSizeRatio82 * visualSizeRatio82;
    
    let squares2 = [];
    
    for (let i = 0; i < squares1.length; i++) {
      let squares2 = packSquares82(
        squares1[i].x,
        squares1[i].y,
        squares1[i].size * ratio1,
        50,
        false
      );
      
      for (let j = 0; j < squares2.length; j++) {
        packSquares82(
          squares2[j].x,
          squares2[j].y,
          squares2[j].size * visualSizeRatio82,
          25,
          true
        );
      }
    }
    
    visualSizeRatio82 = prevRatio;
  }
  draw82();
</script>
<canvas id = "canvas81"></canvas>
<button onclick = "draw81()">Regenerate</button>
<div class = "desc"><b><i>(5/2/2022)</i></b> More generative reverse-enineering: this time I copied the design from <a href = "https://www.reddit.com/r/generative/comments/ufqh3l/alien_text" target = "_blank">this</a> Reddit post, with a grid of grids of cellular automata. Each rule appears once, randomly, in an 8x8 grid. I also randomized the hue every generation, so that is isn't just green like the post. The initial state of each cell is the same for all cells, but randomized every generation as well.</div>
<hr><hr>
<script>
  const ctx81 = canvas81.getContext("2d");
  canvas81.width = canvas81.height = 1024;
  
  let bigGridSize81 = 16;
  let smallGridSize81 = 8;
  let bigTileSize81 = canvas81.width / bigGridSize81;
  let smallTileSize81 = bigTileSize81 / smallGridSize81;
  let startRow81 = "1";
  let hue81 = 0;
  
  function ruleFromNum81(n) {
    return n.toString(2).padStart(8, "0");
  }
  
  function drawTile81(xOffset, yOffset, rule) {
    ctx81.fillStyle = `hsl(${hue81 + randBetween(-30, 30)}deg, ${randBetween(50, 100)}%, ${randBetween(25, 75)}%)`;
    
    let row = startRow81.padEnd(smallGridSize81, "0");
    for (let y = 0; y < smallGridSize81; y++) {
      let nextRow = "";
      for (let x = 0; x < smallGridSize81; x++) {
        if (row[x] === "1") ctx81.fillRect(xOffset + (x * smallTileSize81), yOffset + (y * smallTileSize81), smallTileSize81, smallTileSize81);
        
        let neighbors = row.charAt((x - 1 + smallGridSize81) % smallGridSize81) + row.charAt(x) + row.charAt((x + 1) % smallGridSize81);
        let nextCell = rule.charAt(7 - parseInt(neighbors, 2));
        nextRow += nextCell;
      }
      row = nextRow;
    }
  }
  
  function draw81() {
    ctx81.fillStyle = "black";
    ctx81.fillRect(0, 0, canvas81.width, canvas81.height);
    
    bigTileSize81 = canvas81.width / bigGridSize81;
    smallTileSize81 = bigTileSize81 / smallGridSize81;
    
    startRow81 = Math.floor(Math.random() * Math.pow(2, smallGridSize81)).toString(2).padStart(smallGridSize81, "0");//ruleFromNum81(Math.floor(Math.random() * 256));
    hue81 = Math.random() * 360;
    
    let ruleArray = [];
    for (let i = 0; i <= 255; i++) ruleArray.push(ruleFromNum81(i));
    
    for (let x = 0; x < bigGridSize81; x++) {
      for (let y = 0; y < bigGridSize81; y++) {
        drawTile81(x * bigTileSize81, y * bigTileSize81, ruleArray.splice(Math.floor(Math.random() * ruleArray.length), 1)[0]);
      }
    }
  }
  draw81();
</script>
<canvas id = "canvas80" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas80(this)" style = "color: red; border-color: red"><b><i>Paused</i></b></button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>[ FPS: <span id = "fps80Txt"></span> ]</b></i></div>
<div class = "desc"><b><i>(4/28/2022)</i></b> I wanted to try to replicate the design from <a href = "https://www.reddit.com/r/generative/comments/udsnf8/filament_sweep_code_included" target = "_blank">this</a> Reddit post, so I have a system of spring particles and pusher particles that move around the screen, pushing points away by the square of the distance between them. It's pretty bland currently and doesn't look like the post.<br><b><i>(4/30/2022)</i></b> I improved some code to improve framerate, and now I can support more points and still be around 50-60 FPS. I gave the points a yellow color and a motion blur, and made the pushers move and choose destinations randomly. This matches the post more, but I still feel like something is missing.</div>
<hr><hr>
<script>
  const ctx80 = canvas80.getContext("2d");
  canvas80.width = canvas80.height = 1000;
  let canvas80Running = false;
  
  let minPointMovement80 = 0.1;
  let minSpringDist80 = 1;
  let clearOpacity80 = 0.1;
  let pusher80MoveSpeed = 5;
  let springiness80 = 0.1;
  let pusher80Power = 20000;
  let numPoints80 = 6000;
  let numPushers80 = 4;
  let point80Color = "yellow";
  
  function Point80(x, y, springiness) {
    this.anchorX = x;
    this.anchorY = y;
    this.x = x;
    this.y = y;
    
    this.springiness = springiness;
  }
  Point80.prototype.update = function() {
    for (let i = 0; i < pusher80Array.length; i++) {
      let dx = pusher80Array[i].x - this.x;
      let dy = pusher80Array[i].y - this.y;
      let distSq = (dx * dx) + (dy * dy);
      let power = pusher80Array[i].power / (distSq + 1);
      if (power >= minPointMovement80) { // If power is too weak, don't bother calculating angle and moving
        let angle = Math.atan2(dy, dx) + Math.PI;
        
        this.x += power * Math.cos(angle);
        this.y += power * Math.sin(angle);
      }
    }
    
    let dx = this.anchorX - this.x;
    let dy = this.anchorY - this.y;
    let distSq = (dx * dx) + (dy * dy);
    
    if (distSq <= minSpringDist80 * minSpringDist80) { // If point is close enough to anchor, don't bother calculating distance and moving
      this.x = this.anchorX;
      this.y = this.anchorY;
    }
    else {
      let angle = Math.atan2(dy, dx);
      let power = Math.sqrt(distSq) * this.springiness;
      
      this.x += power * Math.cos(angle);
      this.y += power * Math.sin(angle);
    }
  };
  Point80.prototype.draw = function() {
    ctx80.strokeStyle = point80Color;
    ctx80.lineWidth = 1;
    ctx80.lineCap = ctx80.lineJoin = "round";
    
    ctx80.beginPath();
    ctx80.moveTo(this.anchorX, this.anchorY);
    ctx80.lineTo(this.x, this.y);
    ctx80.stroke();
  };
  let point80Array = [];
  
  function Pusher80(x, y, power) {
    this.x = x;
    this.y = y;
    this.power = power;
    
    this.destination = {};
    this.resetDestination();
  }
  Pusher80.prototype.update = function() {
    let dx = this.destination.x - this.x;
    let dy = this.destination.y - this.y;
    let distSq = (dx * dx) + (dy * dy);
    
    if (distSq <= (pusher80MoveSpeed + 1) * (pusher80MoveSpeed + 1)) {
      this.resetDestination();
      return;
    }
    
    let angle = Math.atan2(dy, dx);
    
    this.x += pusher80MoveSpeed * Math.cos(angle);
    this.y += pusher80MoveSpeed * Math.sin(angle);
  };
  Pusher80.prototype.resetDestination = function() {
    this.destination.x = Math.random() * canvas80.width;
    this.destination.y = Math.random() * canvas80.height;
  };
  let pusher80Array = [];
  
  let lastFrame80Time = 0;
  let lastFps80DisplayTime = 1000;
  
  function frame80() {
    if (Date.now() - lastFps80DisplayTime >= 500) {
      fps80Txt.innerHTML = (1000 / (Date.now() - lastFrame80Time)).toFixed(1);
      lastFps80DisplayTime = Date.now();
    }
    lastFrame80Time = Date.now();
    
    ctx80.fillStyle = `rgba(0, 0, 0, ${clearOpacity80})`;
    ctx80.fillRect(0, 0, canvas80.width, canvas80.height);
    
    for (let i = 0; i < point80Array.length; i++) {
      point80Array[i].update();
      point80Array[i].draw();
    }
    
    for (let i = 0; i < pusher80Array.length; i++) {
      pusher80Array[i].update();
    }
    
    if (canvas80Running) requestAnimationFrame(frame80);
  }
  
  function reset80() {
    ctx80.fillStyle = "black";
    ctx80.fillRect(0, 0, canvas80.width, canvas80.height);
    
    point80Array = [];
    pusher80Array = [];
    
    for (let i = 0; i < numPoints80; i++) {
      point80Array.push(new Point80(Math.random() * canvas80.width, Math.random() * canvas80.height, springiness80));
    }
    
    for (let i = 0; i < numPushers80; i++) {
      pusher80Array.push(new Pusher80(Math.random() * canvas80.width, Math.random() * canvas80.height, pusher80Power));
    }
    
    if (!canvas80Running) frame80();
  }
  reset80();
  
  function startCanvas80(caller) {
    if (canvas80Running) {
      canvas80Running = false;
      caller.innerHTML = "<b><i>Paused</i></b>";
      caller.style.color = caller.style.borderColor = "red";
    }
    else {
      canvas80Running = true;
      caller.innerHTML = "<b><i>Running</i></b>";
      caller.style.color = caller.style.borderColor = "green";
      frame80();
    }
  }
</script>
<canvas id = "canvas79" style = "width: 500px; height: 500px"></canvas>
<button onclick = "draw79()">Regenerate</button>
<div class = "desc"><b><i>(4/23/2022)</i></b> Recursive circle packing -- a few medium circles are packed randomly within one large circle (the size of the canvas), and each of those medium circles has mini circles packed into it as well.<br><b><i>(4/24/2022)</i></b> Added more medium circles and made th background black instead of white. I want to add another function to pack circles within a rectangle so that the medium circles reach to the edge of the canvas, instead of to the edge of a circle inside the canvas, so they fill the space better and more neatly. I also added a setting for center bias which affects how much the placed circles are biased towards the center, to create more scattered designs (although it fills up the canvas quicker). Negative bias values make the circles tend to the <i>edge</i> of the boundary instead. <i>(Possible idea: Make each mini circle be a random inscribed polygon, withthe same polygon for all mini circles within one medium circle.)</i><br><b><i>(4/25/2022)</i></b> I implemented the random shape idea but I wasn't happy with how it turned out. I'm not really sure where I want to go with this now--I really like the idea of packing circles in circles but it doesn't look super cool how it is right now.<br><b><i>Update: (Later that day)</i></b> I turned off the circle outline and made the visual size ratio be 1.75&times;, which make the medium circles look more like paint splotches or something. I like this more but it's still missing something.<br><b><i>Update: (Slightly more later that day)</i></b> I made the biggest boundary circle bigger than the canvas so the medium circles cover the whole screen, turned the visual size ratio to 5&times;, turned the opacity down to 0.8, and increased medium circles to 100. I think I finally like how this turned out, I'll do some more fiddling but it's starting to actually look like something now.<br><b><i>(4/26/2022)</i></b> Reduced size ratio to make the circles more separated.<br><b><i>(4/27/2022)</i></b> I added settings randomizing every regeneration (like hue variation, center bias, brightness variation, size ratio, etc.) and also added a new setting for the ratio of the inner ring of the circles instead of just always having solid circles. I might polish it up a bit more but I'm finally starting to like how this is turning out now.<br><b><i><mark>Actually finished! (4/28/2022)</mark> Added to <a href = "generative-art-gallery.html" target = "_blank">generative-art-gallery.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx79 = canvas79.getContext("2d");
  canvas79.width = canvas79.height = 1000;
  
  let currFilled79 = false;
  let maxTries79 = 1000;
  let minSizeRatio79 = 0.01;
  let minMediumSizeRatio79 = 0.05;
  let maxSizeRatio79 = 0.25;
  let maxMediumSizeRatio79 = 0.15;
  let numMiniCircles79 = 100;
  let numMediumCircles79 = 100;
  let hueVariation79 = 0;
  let brightnessVariation79 = 0.5;
  let centerBias79 = 0;
  let mediumCenterBias79 = 0;
  let visualSizeRatio79 = 0.9;
  let mediumCircleSizeRatio79 = 1;
  let lineWidth79 = 0;
  let opacity79 = 1;
  let ringRatio79 = 0.5;
  let shadowSize79 = 0;
  
  function randShape79() {
    return 0;
    
    let arr = [0, 4, 5, 6];
    return arr[Math.floor(Math.random() * arr.length)];
  }
  
  function rand79() {
    let r = 1;
    for (let i = 0; i < Math.abs(centerBias79) + 1; i++) {
      r *= Math.random();
    }
    
    if (centerBias79 < 0) r = 1 - r;
    return r;
  }
  
  function drawShape79(x, y, radius, sides) {
    if (sides === 0) {
      ctx79.beginPath();
      ctx79.arc(x, y, radius, 0, Math.PI * 2);
      return;
    }
    
    let a = Math.random() * Math.PI * 2;
    let ca = a;
    let step = (Math.PI * 2) / sides;
    
    ctx79.beginPath();
    ctx79.moveTo(x + (radius * Math.cos(ca)), y + (radius * Math.sin(ca)));
    for (let i = 0; i <= sides; i++) {
      ca += step;
      ctx79.lineTo(x + (radius * Math.cos(ca)), y + (radius * Math.sin(ca)));
    }
  }
  
  function drawRing79(x, y, radius, ringRatio) {
    ctx79.beginPath();
    ctx79.moveTo(x, y);
    ctx79.arc(x, y, radius, 0, Math.PI * 2);
    if (ringRatio !== 0) ctx79.arc(x, y, radius * ringRatio, 0, Math.PI * 2);
  }
  
  function validatePoint79(testX, testY, boundaryX, boundaryY, boundaryRadius, circleArray) {
    let minSize = boundaryRadius * minSizeRatio79;
    
    for (let i = 0; i < circleArray.length; i++) {
      let dx = circleArray[i].x - testX;
      let dy = circleArray[i].y - testY;
      let distSq = (dx * dx) + (dy * dy);
      let r = circleArray[i].radius + minSize;
      if (distSq <= r * r) return false; // Too close to a circle
    }
    
    let maxDist = boundaryRadius - minSize;
    let dx = boundaryX - testX;
    let dy = boundaryY - testY;
    let distToCenterSq = (dx * dx) + (dy * dy);
    if (distToCenterSq >= maxDist * maxDist) return false; // Too close to edge of boundary circle
    
    return true;
  }
  
  function Circle79(boundaryX, boundaryY, boundaryRadius, hue, circleArray, isHidden, sides) {
    this.bx = boundaryX;
    this.by = boundaryY;
    this.br = boundaryRadius;
    this.circleArray = circleArray;
    this.hue = hue + randBetween(-180 * hueVariation79, 180 * hueVariation79);
    this.isHidden = isHidden;
    this.sides = sides;
    
    let r = rand79() * boundaryRadius;
    let theta = Math.random() * Math.PI * 2;
    
    let x = boundaryX + (r * Math.cos(theta));
    let y = boundaryY + (r * Math.sin(theta));
    
    let tries = 0;
    while (!validatePoint79(x, y, boundaryX, boundaryY, boundaryRadius, circleArray)) {
      if (tries > maxTries79) {
        currFilled79 = true;
        //console.log(`Boundary was filled before max circles were reached. Current circles: ${circleArray.length}/${numMiniCircles79}`);
        return;
      }
      
      r = rand79() * boundaryRadius;
      theta = Math.random() * Math.PI * 2;
      
      x = boundaryX + (r * Math.cos(theta));
      y = boundaryY + (r * Math.sin(theta));
      
      tries++;
    }
    
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.grow();
  }
  Circle79.prototype.grow = function() {
    let smallestDist = Infinity;
    let maxSize = this.br * maxSizeRatio79;
    
    for (let i = 0; i < this.circleArray.length; i++) {
      if (i != this.circleArray.indexOf(this)) {
        let dx = this.x - this.circleArray[i].x;
        let dy = this.y - this.circleArray[i].y;
        let distSq = (dx * dx) + (dy * dy);
        let dist = Math.sqrt(distSq) - this.circleArray[i].radius;
        if (dist < smallestDist) smallestDist = dist;
      }
    }
    
    let dx = this.x - this.bx;
    let dy = this.y - this.by;
    let distToCenterSq = (dx * dx) + (dy * dy);
    let distToCenter = Math.sqrt(distToCenterSq);
    let distToEdge = this.br - distToCenter;
    if (distToEdge < smallestDist) smallestDist = distToEdge;
    
    this.radius = Math.min(smallestDist, maxSize);
    
    if (this.isHidden) return;
    
    ctx79.strokeStyle = "black";
    ctx79.lineWidth = lineWidth79;
    ctx79.fillStyle = `hsl(${this.hue}deg, ${randBetween(50, 100)}%, ${50 + randBetween(-50 * brightnessVariation79, 50 * brightnessVariation79)}%)`;
    ctx79.shadowBlur = shadowSize79;
    ctx79.shadowColor = "white";
    ctx79.globalAlpha = opacity79;
    
    drawRing79(this.x, this.y, this.radius * visualSizeRatio79, ringRatio79);
    
    ctx79.fill("evenodd");
    if (lineWidth79 !== 0) ctx79.stroke();
    
    ctx79.shadowBlur = 0;
    ctx79.globalAlpha = 1;
  };
  
  function packCircles79(boundaryX, boundaryY, boundaryRadius, count, hue, isHidden, sides) {
    ctx79.strokeStyle = "black";
    ctx79.lineWidth = 1;
    //ctx79.strokeCircle(boundaryX, boundaryY, boundaryRadius);
    
    let circleArray = [];
    currFilled79 = false;
    
    while (circleArray.length < count && !currFilled79) circleArray.push(new Circle79(boundaryX, boundaryY, boundaryRadius, hue, circleArray, isHidden, sides));
    
    return circleArray;
  }
  
  function draw79() {
    // Clear canvas
    
    ctx79.fillStyle = `hsl(${Math.random() * 360}deg, 40%, 7%)`;
    ctx79.fillRect(0, 0, canvas79.width, canvas79.height);
    
    // Randomize settings
    
    maxSizeRatio79 = randBetween(0.2, 0.4);
    minSizeRatio79 = maxSizeRatio79 * randBetween(0.05, 0.1);
    
    maxMediumSizeRatio79 = randBetween(0.1, 0.2);
    minMediumSizeRatio79 = maxMediumSizeRatio79 * randBetween(0.2, 0.4);
    
    hueVariation79 = Math.random() * Math.random() * 0.5;
    brightnessVariation79 = Math.random() * Math.random();
    
    centerBias79 = Math.round(randBetween(0, 3)) * randSign();
    
    visualSizeRatio79 = Math.round(randBetween(7, 10)) / 10;
    mediumCircleSizeRatio79 = 0.95//Math.random() < 0.5 ? 1 : 0.9;
    
    numMiniCircles79 = Math.round(randBetween(75, 150));
    numMediumCircles79 = Math.round(randBetween(75, 150));
    
    ringRatio79 = Math.random() < 0.33 ? 0 : Math.round(randBetween(2, 9)) / 10;
    
    // Make medium circles
    
    let prevMin = minSizeRatio79;
    let prevMax = maxSizeRatio79;
    let prevBias = centerBias79;
    let prevNum = numMiniCircles79;
    
    minSizeRatio79 = minMediumSizeRatio79;
    maxSizeRatio79 = maxMediumSizeRatio79;
    centerBias79 = mediumCenterBias79;
    numMiniCircles79 = numMediumCircles79;
    
    let mediumCircles = packCircles79(canvas79.width / 2, canvas79.height / 2, canvas79.width, numMiniCircles79, 0, true, 3);
    
    // Draw mini circles
    
    minSizeRatio79 = prevMin;
    maxSizeRatio79 = prevMax;
    centerBias79 = prevBias;
    numMiniCircles79 = prevNum;
    
    for (let i = 0; i < mediumCircles.length; i++) {
      packCircles79(
        mediumCircles[i].x,
        mediumCircles[i].y,
        mediumCircles[i].radius * mediumCircleSizeRatio79,
        numMiniCircles79,
        Math.random() * 360,
        false,
        randShape79()
      );
    }
  }
  draw79();
</script>
<div>Click and drag to zoom. Make sure the animation is running by toggling the <b><i>Paused</i></b> button. The render gets more accurate every swipe.</div>
<canvas id = "canvas78"></canvas>
<button onclick = "startCanvas78(this)" style = "color: red; border-color: red"><b><i>Paused</i></b></button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>[ FPS: <span id = "fps78Txt"></span> ]</b></i></div>
<br><br>
<button onclick = "multScale78(0.5)">Zoom In</button>
<button onclick = "multScale78(2)">Zoom Out</button>
<br><br>
<input type = "checkbox" id = "intenseColoring78Checkbox" oninput = "updateSettings78()" CHECKED>
<label for = "intenseColoring78Checkbox">Intensified Coloring (may get whitewashed at deeper zooms)</label>
<br><br>
<div><b><u>Fractal Hue:</u></b> <span id = "hue78Txt">300</span>&deg;</div>
<input type = "range" min = "0" max = "360" step = "30" value = "300" id = "hue78Range" oninput = "updateSettings78()">
<br><br>
<b>Fractal:</b>
<button onclick = "setFractalMode78(1)" id = "fractalMode78Btn1" class = "fractalMode78Btns" style = "background-color: gray">Mandelbrot</button>
<button onclick = "setFractalMode78(2)" id = "fractalMode78Btn2" class = "fractalMode78Btns">Mindlebrit</button>
<button onclick = "setFractalMode78(3)" id = "fractalMode78Btn3" class = "fractalMode78Btns">Cosine Fractal</button>
<button onclick = "setFractalMode78(4)" id = "fractalMode78Btn4" class = "fractalMode78Btns">Two-Cosine Fractal</button>
<p>
The <b>Mindlebrit Fractal</b> is a fractal that is generated the exact same as the Mandelbrot--except z_0 = i, instead of 0.
<br><br>
The <b>Cosine Fractal</b> is generated similar to the Mandelbrot, except instead of squaring z_n and adding c every iteration, you take the cosine of z_n and add c (and color based on escape iterations similarly).
<br><br>
The <b>Two-Cosine Fractal</b> is the same as the Cosine Fractal, but with 2 times cosine each step.
</p>
<div class = "desc"><b><i>(3/30/2022)</i></b> I tried making a faster Mandelbrot set visualizer than the <a href = "https://e4494s.neocities.org/mandelbrot.html">old one</a> I had, but it's not much faster. I did add dragging and zooming though, which was really difficult to get working properly. It still loses a lot of detail at higher zoom levels, but I'm not sure how to fix that without waiting like 30 seconds for it to render. I also made it where the escape iterations for each point also affect the hue, not just the brightness, which creates a really interesting effect.<br><b><i>(3/31/2022)</i></b> Added buttons for different fractal modes.<br><b><i>(3/31/2022)</i></b> I significantly improved runtime and performance by adding an update frame function instead of just rendering the fractal all at once, one time. It instead now passes down the screen, rendering as it goes. Each time it reaches the bottom of the screen, it does another pass with higher iterations. (Deeper zooms will take longer to render as they have a higher iteration escape period).<br><b><i>Update: (Later that day)</i></b> I made the rendering passes happen twice at once, moving from the center of the screen, and also added a setting to intensify the coloring, which means the intensity is multiplied based on the maximum iterations (as the higher the max iterations are, the less intense the colors typically are). I added it as an optional setting since sometimes it looks whitewashed with intense colors on.</div>
<hr><hr>
<script>
  const ctx78 = canvas78.getContext("2d");
  canvas78.width = canvas78.height = 500;
  let canvas78Running = false;
  let canvas78Rect = canvas78.getBoundingClientRect();
  let canvas78Ratio = canvas78.width / 300;
  
  const Complex78 = {};
  Complex78.number = function(a, b) { // a + bi
    this.re = a;
    this.im = b;
  };
  Complex78.string = function(z) {
  	return `${z.re} ${Math.sign(z.im) === -1 ? "-" : "+"} ${Math.abs(z.im)}i`;
  };
  
  Complex78.iSquared = new Complex78.number(-1, 0); // i^2 = -1
  
  Complex78.add = function(x, y) {
    if (typeof x === "number") x = new Complex78.number(x, 0);
    if (typeof y === "number") y = new Complex78.number(y, 0); 
    
    return new Complex78.number(x.re + y.re, x.im + y.im);
  };
  Complex78.subtract = function(x, y) {
    if (typeof x === "number") x = new Complex78.number(x, 0);
    if (typeof y === "number") y = new Complex78.number(y, 0); 
    
    return new Complex78.number(x.re - y.re, x.im - y.im);
  };
  Complex78.multiply = function(x, y) {
    if (typeof x === "number") x = new Complex78.number(x, 0);
    if (typeof y === "number") y = new Complex78.number(y, 0); 
    
    let iSq = new Complex78.number(Complex78.iSquared.re * x.im * y.im, Complex78.iSquared.im * x.im * y.im);
    
    let real = (x.re * y.re) + iSq.re;
    let imaginary = (x.re * y.im) + (x.im * y.re) + iSq.im;
    
    return new Complex78.number(real, imaginary);
  };
  Complex78.power = function(x, n) {
  	let result = new Complex78.number(1, 0);
    for (let i = 0; i < n; i++) {
    	result = Complex78.multiply(result, x);
    }
    return result;
  }
  
  Complex78.inMandelbrot = function(c) {
  	let z = new Complex78.number(0, 0);
    
  	for (let i = 0; i < maxIterations78; i++) {
    	z = Complex78.add(Complex78.power(z, 2), c);
      if (z.re * z.im > 5) return i / maxIterations78;
    }
    
    return 0;
  };
  function inMandelbrot78(re, im) {
  	let a = 0;
    let b = fractalMode78 === 2 ? 1 : 0;
    
    if ((a + a) * (b + b) > 4) return 1;
    
    for (let i = 0; i < maxIterations78; i++) {
    	let _a = (a * a) - (b * b);
      let _b = 2 * a * b;
      a = _a + re;
      b = _b + im;
      
      if ((a * a) + (b * b) > 4) return i / maxIterations78;
    }
    
    return 0;
  }
  function inCosFractal78(re, im) { // z_n+1 = cos(z_n) + c
  	let a = re;
    let b = im;
    
    for (let i = 0; i < maxIterations78; i++) {
    	let eB = Math.exp(b); // e^b
      let eNegB = 1 / eB; // e^-b
      let c = Math.cos(a);
      let s = Math.sin(a);
      
      let _a = (c * (eB + eNegB)) / (fractalMode78 === 4 ? 1 : 2);
      let _b = (s * (eNegB - eB)) / (fractalMode78 === 4 ? 1 : 2);
      a = _a + re;
      b = _b + im;
      
      if (a * b > 5) return i / maxIterations78;
    }
    
    return 0;
  }
  
  let pan78X = -0.23;
  let pan78Y = 0;
  let hue78 = 300;
  let scale78 = 2;
  let fractalMode78 = 1;
  let intenseColoring78 = true;
  
  /*
    1: Mandelbrot
    2: Mandelbrot with z_0 = i
    3: Cosine Fractal
    4: Two-Cosine Fractal
  */
  
  let scale78Array = [
  	2, // Mandelbrot
    1, // Mindlebrit
    4, // Cosine Fractal
    1 // Two-Cosine Fractal
  ];
  let pan78XArray = [
  	-0.23, // Mandelbrot
    0, // Mindlebrit
    0.39, // Cosine Fractal
    -0.5 // Two-Cosine Fractal
  ];
  let pan78YArray = [
  	0, // Mandelbrot
    -0.5, // Mindlebrit
    0, // Cosine Fractal
    0 // Two-Cosine Fractal
  ];
  
  function plotPoint78(x, y) {
  	let _x = x - (canvas78.width / 2);
    let _y = y - (canvas78.height / 2);
    _x /= canvas78.width;
    _y /= canvas78.height;
    _x += pan78X;
    _y += pan78Y;
    _x *= scale78;
    _y *= scale78;
    
  	let escape = 0;
    if (fractalMode78 === 1 || fractalMode78 === 2) escape = inMandelbrot78(_x, _y);
    else if (fractalMode78 === 3 || fractalMode78 === 4) escape = inCosFractal78(_x, _y);
    if (intenseColoring78) escape *= (maxIterations78 / iterationsPerPass78);
    let brightness = escape * 100;
    let hue = hue78 + (180 * escape);
    
    ctx78.fillStyle = `hsl(${hue}deg, 100%, ${brightness}%)`;
    ctx78.fillRect(x, y, 1, 1);
  }
  
  function plotFractal78() {
  	ctx78.fillStyle = "white";
  	ctx78.fillRect(0, 0, canvas78.width, canvas78.height);
    
    for (let x = 0; x < canvas78.width; x++) {
    	for (let y = 0; y < canvas78.height; y++) {
      	plotPoint78(x, y);
      }
    }
  }
  //plotFractal78();
  
  let currPixel78 = 0;
  let numPasses78 = 0;
  let maxIterations78 = 200;
  let iterationsPerPass78 = 200;
  let maxPasses78 = 5;
  let stepsPerFrame78 = 4000;
  
  let lastFrame78Time = 0;
  let lastFps78DisplayTime = 1000;
  function frame78() {
    if (Date.now() - lastFps78DisplayTime >= 500) {
      fps78Txt.innerHTML = (1000 / (Date.now() - lastFrame78Time)).toFixed(1);
      lastFps78DisplayTime = Date.now();
    }
    lastFrame78Time = Date.now();
    
    for (let i = 0; i < stepsPerFrame78; i++) {
    	if (numPasses78 < maxPasses78) {
    		let x = Math.floor(currPixel78 / 2) % canvas78.width;
      	let y = Math.floor(Math.floor(currPixel78 / 2) / canvas78.width);
      	if (currPixel78 % 2 === 0) {
        	y += canvas78.height / 2;
      	}
      	else {
      		y = (canvas78.height / 2) - y;
        	y--;
      	}
      	
    		plotPoint78(x, y);
      	
      	currPixel78++;
      	
      	if (currPixel78 > canvas78.width * canvas78.height) {
      		currPixel78 = 0;
        	numPasses78++;
        	maxIterations78 = (numPasses78 + 1) * iterationsPerPass78;
      	}
      }
    }
    
    if (canvas78Running) requestAnimationFrame(frame78);
  }
  
  function startCanvas78(caller) {
    if (canvas78Running) {
      canvas78Running = false;
      caller.innerHTML = "<b><i>Paused</i></b>";
      caller.style.color = caller.style.borderColor = "red";
    }
    else {
      canvas78Running = true;
      caller.innerHTML = "<b><i>Running</i></b>";
      caller.style.color = caller.style.borderColor = "green";
      frame78();
    }
  }
  
  function resetDrawing78() {
  	ctx78.fillStyle = "black";
    ctx78.fillRect(0, 0, canvas78.width, canvas78.height);
    
    currPixel78 = 0;
    numPasses78 = 0;
    maxIterations78 = iterationsPerPass78;
  }
  function redrawLastPass78() {
  	currPixel78 = 0;
  	numPasses78--;
   	numPasses78 = Math.max(0, numPasses78);
    maxIterations78 = (numPasses78 + 1) * iterationsPerPass78;
  }
  
  function updateSettings78() {
  	intenseColoring78 = intenseColoring78Checkbox.checked;
    hue78 = hue78Txt.innerHTML = Number(hue78Range.value);
    
    redrawLastPass78();
  }
  
  function resetFractal78() {
  	scale78 = scale78Array[fractalMode78 - 1];
  	pan78X = pan78XArray[fractalMode78 - 1];
  	pan78Y = pan78YArray[fractalMode78 - 1];
    
    resetDrawing78();
  }
  //plotFractal78();
  
  function multScale78(factor) {
  	scale78 *= factor;
    
    pan78X /= factor;
    pan78Y /= factor;
    
    resetDrawing78();
  }
  function setFractalMode78(n) {
  	fractalMode78 = n;
    let btns = document.getElementsByClassName("fractalMode78Btns");
    for (let i = 0; i < btns.length; i++) btns[i].style.backgroundColor = "white";
    
    document.getElementById("fractalMode78Btn" + n).style.backgroundColor = "gray";
    
    resetFractal78();
  }
  
  function drawPanIcon78(x, y) {
  	return;
  	let size = 30;
    let s3 = size / 3;
    
    ctx78.fillStyle = "white";
    ctx78.strokeStyle = "black";
    ctx78.lineWidth = 2;
    
    let cx = x - (s3 / 2);
    let cy = y - (s3 * 1.5);
    
    ctx78.beginPath();
    ctx78.moveTo(cx, cy);
    cx += s3;
    ctx78.lineTo(cx, cy);
    cy += s3;
    ctx78.lineTo(cx, cy);
    cx += s3;
    ctx78.lineTo(cx, cy);
    cy += s3;
    ctx78.lineTo(cx, cy);
    cx -= s3;
    ctx78.lineTo(cx, cy);
    cy += s3;
    ctx78.lineTo(cx, cy);
    cx -= s3;
    ctx78.lineTo(cx, cy);
    cy -= s3;
    ctx78.lineTo(cx, cy);
    cx -= s3;
    ctx78.lineTo(cx, cy);
    cy -= s3;
    ctx78.lineTo(cx, cy);
    cx += s3;
    ctx78.lineTo(cx, cy);
    cy -= s3;
    ctx78.lineTo(cx, cy);
    
    ctx78.fill();
    ctx78.stroke();
  }
  
  let Mouse78 = {
  	down: false,
    downX: 0,
    downY: 0,
    willRedraw: false
  };
  
  canvas78.addEventListener("mousedown", e => {
 		canvas78Rect = canvas78.getBoundingClientRect();
    
  	e.preventDefault();
    
    Mouse78.down = true;
    Mouse78.downX = (e.clientX - canvas78Rect.left) * canvas78Ratio;
    Mouse78.downY = (e.clientY - canvas78Rect.top) * canvas78Ratio;
    
    drawPanIcon78(Mouse78.downX, Mouse78.downY);
  });
  window.addEventListener("mouseup", e => {
  	Mouse78.down = false;
    if (Mouse78.willRedraw) {
    	canvas78Rect = canvas78.getBoundingClientRect();
      
      let mX = (e.clientX - canvas78Rect.left) * canvas78Ratio;
    	let mY = (e.clientY - canvas78Rect.top) * canvas78Ratio;
  		
    	pan78X -= (mX - Mouse78.downX) / canvas78.width;
    	pan78Y -= (mY - Mouse78.downY) / canvas78.height;
      
      resetDrawing78();
    }
    Mouse78.willRedraw = false;
  });
  window.addEventListener("mousemove", e => {
  	if (!Mouse78.down) return;
    
    Mouse78.willRedraw = true;
    
  	e.preventDefault();
  });
</script>
<!--Idea?: Triangle grid with random tile size, rounded to multiple of 0.25 so they connect better-->
<canvas id = "canvas77"></canvas>
<button onclick = "startCanvas77(this)" style = "color: red; border-color: red"><b><i>Paused</i></b></button>
<button onclick = "reset77()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>[ FPS: <span id = "fps77Txt"></span> ]</b></i></div>
<div class = "desc"><b><i>(3/10/2022)</i></b> I decided to go with an animated design with a triangle grid this time. Each triangle slowly fades in and out with size and brightness, but the offset it has increases the further it is from the center, which makes a really cool rippling or breaking away effect.</div>
<hr><hr>
<script>
  const ctx77 = canvas77.getContext("2d");
  canvas77.width = canvas77.height = 1000;
  let canvas77Running = false;
  
  const ratio77 = Math.sqrt(3) / 2;
  let gridSize77 = 7;
  let t77 = 0;
  let period77 = 250;
  let hue77 = 0;
  let clearOpacity77 = 1;
  let flatness77 = 1.7;
  
  function smooth77(t) {
    return Math.min((1 - Math.cos(t * Math.PI * 2)) / flatness77, 1);
  }
  
  function drawTriangle77(x, y, sideLength, flip) { //    >: Normal    <: flipped
    let cx = x;
    let cy = y;
    let ca = -Math.PI / 2;
    
    ctx77.lineWidth = 1;
    ctx77.lineCap = ctx77.lineJoin = "round";
    
    ctx77.beginPath();
    ctx77.moveTo(cx, cy);
    for (let i = 0; i < 3; i++) {
      cx += sideLength * Math.cos(ca);
      cy += sideLength * Math.sin(ca);
      ca += ((2 * Math.PI) / 3) * (flip ? -1 : 1);
      ctx77.lineTo(cx, cy);
    }
    
    ctx77.fill();
    ctx77.stroke();
  }
  
  function drawTriangle77FromCenter(x, y, sideLength, flip) { //    >: Normal    <: flipped
    if (!flip) drawTriangle77(x - (sideLength * 0.25 * (1 / ratio77)), y + (sideLength * 0.5), sideLength, flip);
    if (flip) drawTriangle77(x + (sideLength * 0.25 * (1 / ratio77)), y + (sideLength * 0.5), sideLength, flip);
  }
  
  function Triangle77(x, y, normSize, flip) { //    >: Normal    <: flipped
    this.x = x + (normSize * ratio77 * (flip ? -1 : 1));
    if (!flip) this.x += normSize * 0.5 * (1 / ratio77);
    this.y = y - (normSize / 2);
    
    let dx = Math.abs((canvas77.width / 2) - this.x);
    let dy = Math.abs((canvas77.height / 2) - this.y);
    let dist = Math.sqrt((dx * dx) + (dy * dy));
    let distRatio = dist / canvas77.width;
    
    this.normSize = normSize;
    this.currSize = normSize;
    
    this.flip = flip;
    
    this.hue = (distRatio * 360) + hue77;
    this.saturation = 100;
    this.brightess = 0;
    
    this.tOffset = distRatio;
  }
  Triangle77.prototype.update = function() {
    let t = smooth77((t77 + this.tOffset) % 1);
    this.currSize = this.normSize * t;
    this.brightness = ((1 - t) * 60) + 40;
  };
  Triangle77.prototype.draw = function() {
    ctx77.fillStyle = ctx77.strokeStyle = `hsl(${this.hue}deg, ${this.saturation}%, ${this.brightness}%)`;
    drawTriangle77FromCenter(this.x, this.y, this.currSize, this.flip);
  };
  let triangle77Array = [];
  
  let lastFrame77Time = 0;
  let lastFps77DisplayTime = 1000;
  function frame77() {
    if (Date.now() - lastFps77DisplayTime >= 500) {
      fps77Txt.innerHTML = (1000 / (Date.now() - lastFrame77Time)).toFixed(1);
      lastFps77DisplayTime = Date.now();
    }
    lastFrame77Time = Date.now();
    
    ctx77.fillStyle = `hsla(0deg, 0%, 0%, ${clearOpacity77})`;
    ctx77.fillRect(0, 0, canvas77.width, canvas77.height);
    
    t77 += 1 / period77;
    t77 %= 1;
    
    for (let i = 0; i < triangle77Array.length; i++) {
      triangle77Array[i].update();
      triangle77Array[i].draw();
    }
    
    if (canvas77Running) requestAnimationFrame(frame77);
  }
  
  function reset77() {
    ctx77.fillStyle = "black";
    ctx77.fillRect(0, 0, canvas77.width, canvas77.height);
    
    t77 = Math.random();
    hue77 = Math.random() * 360;
    
    triangle77Array = [];
    
    let tileSize = canvas77.width / gridSize77;
    let numX = Math.ceil(gridSize77 / ratio77) + 2;
    let numY = gridSize77 + 2;
    let xOffset = tileSize * 0.22 * (1 / ratio77);
    
    for (let x = -2; x < numX; x++) {
      for (let y = -1; y < numY; y++) {
        let _x = x * tileSize * ratio77;
        let _y = x % 2 === 0 ? y : y - 0.5;
        _y *= tileSize;
        
        triangle77Array.push(new Triangle77(_x - xOffset, _y, tileSize, true));
        triangle77Array.push(new Triangle77(_x - xOffset, _y, tileSize, false));
      }
    }
    
    if (!canvas77Running) frame77();
  }
  reset77();
  
  function startCanvas77(caller) {
    if (canvas77Running) {
      canvas77Running = false;
      caller.innerHTML = "<b><i>Paused</i></b>";
      caller.style.color = caller.style.borderColor = "red";
    }
    else {
      canvas77Running = true;
      caller.innerHTML = "<b><i>Running</i></b>";
      caller.style.color = caller.style.borderColor = "green";
      frame77();
    }
  }
</script>
<canvas id = "canvas76"></canvas>
<button onclick = "draw76()">Redraw</button>
<div class = "desc"><b><i>(3/7/2022)</i></b> I tried to use something I implemented in the previous project, by connecting lines with random quadratic curves, but the result is pretty underwhelming.</div>
<hr><hr>
<script>
  const ctx76 = canvas76.getContext("2d");
  canvas76.width = canvas76.height = 1000;
  
  let points76 = [];
  let numPoints76 = 200;
  let connectDist76 = 150;
  let lineWidth76 = 2;
  let lineBend76 = 100;
  let shadow76 = 5;
  
  function resetPoints76() {
    points76 = [];
    for (let i = 0; i < numPoints76; i++) {
      points76.push({
        x: Math.random() * canvas76.width,
        y: Math.random() * canvas76.height
      });
    }
  }
  
  function connectPoints76() {
    for (let i = 0; i < points76.length; i++) {
      let connections = [];
      for (let j = 0; j < points76.length; j++) {
        if (i !== j) {
          let dx = points76[i].x - points76[j].x;
          let dy = points76[i].y - points76[j].y;
          let distSq = (dx * dx) + (dy * dy);
          if (distSq <= connectDist76 * connectDist76) connections.push(points76[j]);
        }
      }
      for (let k = 0; k < connections.length; k++) {
        ctx76.lineWidth = (lineWidth76 / connections.length) + 0.1;
        ctx76.lineCap = ctx76.lineJoin = "round";
        ctx76.strokeStyle = `hsl(${Math.random() * 360}deg, 80%, 40%)`;
        ctx76.shadowBlur = shadow76;
        ctx76.shadowColor = "white";
        
        let mX = (points76[i].x + connections[k].x) / 2;
        let mY = (points76[i].y + connections[k].y) / 2;
        let a = Math.random() * Math.PI * 2;
        let bend = Math.random() * lineBend76;
        let cx = mX + (bend * Math.cos(a));
        let cy = mY + (bend * Math.sin(a));
        
        ctx76.beginPath();
        ctx76.moveTo(points76[i].x, points76[i].y);
        ctx76.quadraticCurveTo(cx, cy, connections[k].x, connections[k].y);
        ctx76.stroke();
        
        ctx76.shadowBlur = 0;
      }
    }
  }
  
  function draw76() {
    ctx76.fillStyle = "black";
    ctx76.fillRect(0, 0, canvas76.width, canvas76.height);
    
    resetPoints76();
    connectPoints76();
  }
  draw76();
</script>
<canvas id = "canvas75" style = "width: 500px; height: 500px"></canvas>
<button onclick = "draw75()">Redraw</button>
<div class = "desc"><b><i>(3/5/2022)</i></b> Experimenting with point networks. At first I just made a phyllotaxis spiral and connected the nearest points but it looked pretty bland. Then I added randomness to how offset each point is, and then finally changed the golden angle from &approx;137.5078&deg; to 2-4&deg; and made the connections get lighter and thinner as they go out. Now it resembles some kind of mystic tribal rune, or magical energy...<br><b><i>Update: (A few minutes later)</i></b> I wanted to emphasize the theme of mysterious ancient energy so I changed the connections from simple line to quadratic curves, with a random offset bend that increases towards the edge of the circle. This creates an interesting contrast between the geometric design of the center and the stringy loops of the edge.<br><b><i>(3/6/2022)</i></b> I added white shadows to everything to create a glowing effect and added random white glowing dots around to emphasize the energy theme.<br><b><i><mark>Actually finished! (3/6/2022)</mark> Added to <a href = "generative-art-gallery.html" target = "_blank">generative-art-gallery.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx75 = canvas75.getContext("2d");
  canvas75.width = canvas75.height = 1000;
  
  let cachedSqrt75 = [];
  for (let i = 0; i < 1100; i++) cachedSqrt75.push(Math.sqrt(i));
  
  let connectDist75 = 40;
  let spiralScale75 = 15;
  let spiralJitter75 = 25;
  let lineWidth75 = 5;
  let lineBend75 = 50;
  let minBend75 = 0;
  let numDots75 = 150;
  let dotSize75 = 6;
  let hue75 = 0;
  let dotOpacity75 = 1//0.35;
  let shadowSize75 = 10//5;
  let shadowRatio75 = 0//0.8;
  
  let goldenAngle75 = toRad(3);//Math.PI * (3 - Math.sqrt(5));
  
  let points75 = [];
  
  function drawDot75(x, y, isSquare) {
    ctx75.fillStyle = `hsla(${hue75}deg, 100%, 100%, ${dotOpacity75})`;
    ctx75.shadowColor = `hsl(${hue75}deg, 100%, 100%)`;
    ctx75.shadowBlur = 10;
    let r = dotSize75 * randBetween(0.5, 1);
    let offset = Math.random() * Math.PI * 2;
    
    for (let j = 0; j < 3; j++) {
      if (!isSquare) ctx75.fillCircle(x, y, r / 1.3);
      else {
        ctx75.beginPath();
        for (let i = 0; i < 4; i++) {
          let a = ((i / 4) * Math.PI * 2) + offset;
          ctx75.lineTo(x + (r * Math.cos(a)), y + (r * Math.sin(a)));
        }
        ctx75.fill();
      }
    }
    ctx75.shadowBlur = 0;
  }
  
  function spiralPoints75() {
    points75 = [];
    let offset = Math.random() * Math.PI * 2;
    
    for (let i = 0; i < 1000; i++) {
      let a = (i * goldenAngle75) + offset;
      let r = cachedSqrt75[i] * spiralScale75;
      
      let x = (canvas75.width / 2) + (r * Math.cos(a));
      let y = (canvas75.height / 2) + (r * Math.sin(a));
      
      let a2 = Math.random() * Math.PI * 2;
      let r2 = Math.random() * spiralJitter75;
      
      points75.push({x: x + (r2 * Math.cos(a2)), y: y + (r2 * Math.sin(a2))});
    }
  }
  
  function connectPoints75() {
    ctx75.lineCap = ctx75.lineJoin = "round";
    ctx75.shadowColor = "white";
    let hue = hue75;
    
    for (let i = 0; i < points75.length; i++) {
      for (let j = 0; j < points75.length; j++) {
        if (i !== j) {
          let dx = points75[i].x - points75[j].x;
          let dy = points75[i].y - points75[j].y;
          let distSq = (dx * dx) + (dy * dy);
          if (distSq <= connectDist75 * connectDist75) {
            let iRatio = i / points75.length;
            ctx75.strokeStyle = ctx75.shadowColor = `hsl(${hue}deg, 100%, ${(iRatio * 95) + 10}%)`;
            ctx75.lineWidth = ((1 - iRatio) * lineWidth75) + 0.2;
            ctx75.shadowBlur = iRatio > shadowRatio75 ? shadowSize75 : 0;
            
            let p = {};
            let a = Math.random() * Math.PI * 2;
            let bend = (iRatio * lineBend75) + minBend75;
            let r = Math.random() * bend;
            p.x = ((points75[i].x + points75[j].x) / 2) + (r * Math.cos(a));
            p.y = ((points75[i].y + points75[j].y) / 2) + (r * Math.sin(a));
            
            ctx75.beginPath();
            ctx75.moveTo(points75[i].x, points75[i].y);
            ctx75.quadraticCurveTo(p.x, p.y, points75[j].x, points75[j].y);
            ctx75.stroke();
          }
        }
      }
    }
    ctx75.shadowBlur = 0;
  }
  
  function draw75() {
    ctx75.fillStyle = "black";
    ctx75.fillRect(0, 0, canvas75.width, canvas75.height);
    
    hue75 = Math.random() * 360;
    goldenAngle75 = toRad(randBetween(2, 4));
    if (Math.random() < 0.5) goldenAngle75 *= -1;
    
    spiralPoints75();
    
    connectPoints75();
    
    for (let i = 0; i < numDots75; i++) {
      let r = (canvas75.width / 2) - ((canvas75.width / 2) * Math.random() * Math.random());
      let a = Math.random() * Math.PI * 2;
      drawDot75((canvas75.width / 2) + (r * Math.cos(a)), (canvas75.height / 2) + (r * Math.sin(a)), Math.random() < 0);
    }
  }
  draw75();
</script>
<canvas id = "canvas74" style = "width: 500px; height: 500px"></canvas>
<button onclick = "draw74()">Redraw</button>
<div class = "desc"><b><i>(3/4/2022)</i></b> I worked out a program to draw the impossible Penrose Triangle.<br><b><i>(3/5/2022)</i></b> Went from drawing one large triangle, to drawing lots of them in a hexagon grid. I really like the design of the triangles but I'm not happy with this arrangement of them and I want to find a more cool looking way to put them on the screen.</div>
<hr><hr>
<script>
  const ctx74 = canvas74.getContext("2d");
  canvas74.width = canvas74.height = 1000;
  
  const ratio74 = Math.sqrt(3) / 2;
  let gridSize74 = 6;
  let hueVariation74 = 0.1;
  
  function drawTriangle74(x, y, radius, angle, hue) {
    ctx74.strokeStyle = "white";
    ctx74.lineWidth = 1;
    ctx74.lineCap = ctx74.lineJoin = "round";
    
    let side = radius / (ratio74 * 5.5);
    let h = hue + randBetween(-180 * hueVariation74, 180 * hueVariation74);
    let s = randBetween(50, 100);
    
    for (let i = 2; i >= 0; i--) {
      ctx74.fillStyle = `hsl(${h}deg, ${s}%, ${((i / 2) * 70) + 15}%)`;
      
      let ca = 30 + (i * 120) + angle;
      let r = side * (4 / 3) * ratio74;
      let cx = x + (r * Math.cos(toRad(ca)));
      let cy = y + (r * Math.sin(toRad(ca)));
      
      ctx74.beginPath();
      ctx74.moveTo(cx, cy);
      
      ca -= 30;
      cx += side * Math.cos(toRad(ca));
      cy += side * Math.sin(toRad(ca));
      ctx74.lineTo(cx, cy);
      
      ca -= 120;
      cx += side * 5 * Math.cos(toRad(ca));
      cy += side * 5 * Math.sin(toRad(ca));
      ctx74.lineTo(cx, cy);
      
      ca -= 120;
      cx += side * 6 * Math.cos(toRad(ca));
      cy += side * 6 * Math.sin(toRad(ca));
      ctx74.lineTo(cx, cy);
      
      ca -= 60;
      cx += side * Math.cos(toRad(ca));
      cy += side * Math.sin(toRad(ca));
      ctx74.lineTo(cx, cy);
      
      ca -= 120;
      cx += side * 5 * Math.cos(toRad(ca));
      cy += side * 5 * Math.sin(toRad(ca));
      ctx74.lineTo(cx, cy);
      
      ca += 120;
      cx += side * 3 * Math.cos(toRad(ca));
      cy += side * 3 * Math.sin(toRad(ca));
      ctx74.lineTo(cx, cy);
      
      ctx74.fill();
      //ctx74.stroke();
    }
  }
  
  function draw74() {
    ctx74.fillStyle = "black";
    ctx74.fillRect(0, 0, canvas74.width, canvas74.height);
    
    gridSize74 = Math.round(randBetween(3, 10));
    
    let tileSize = canvas74.width / gridSize74;
    let numX = gridSize74 + 2; // Compensate for staggered rows and x-offset
    let numY = Math.ceil(gridSize74 * (1 / ratio74)) + 1; // Compensate for vertical compression and y-offset
    let hue = Math.random() * 360;
    
    let offsetX = Math.random() * tileSize;
    let offsetY = Math.random() * tileSize;
    
    for (let x = 0; x < numX; x++) {
      for (let y = 0; y < numY; y++) {
        let _x = y % 2 === 0 ? x : x - 0.5;
        _x += 0.5;
        _y = y * ratio74;
        _y += 0.5;
        
        let tileX = (_x * tileSize) - offsetX;
        let tileY = (_y * tileSize) - offsetY;
        
        let dx = tileX - (canvas74.width / 2)// - tileX;
        let dy = tileY - (canvas74.height / 2)// - tileY;
        let a = Math.random() * 360//toDeg(Math.atan2(dy, dx)) + 30;
        
        drawTriangle74(tileX, tileY, tileSize * 0.5, a, hue);
      }
    }
  }
  draw74();
</script>
<canvas id = "canvas73"></canvas>
<button onclick = "draw73()">Redraw</button>
<div class = "desc"><b><i>(3/1/2022)</i></b> More variation circle packing, this time with random triangles drawn instead of circles, and with a visual size ratio of 1.5x so they overlap each other but still are spaced out nicely.<br><b><i>Update: (Later that day)</i></b> Added more paramaters that get randomized. Lines are drawn on every triangle either from its center to its corners or its center to its edges, randomized every generation. There is also a random tilt factor for how rotated each triangle will be off the global angle, and a skew angle for how skewed the triangles will be from a perfect equilateral.<br><b><i><mark>Actually finished! (3/1/2022)</mark> Added to <a href = "generative-art-gallery.html" target = "_blank">generative-art-gallery.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx73 = canvas73.getContext("2d");
  canvas73.width = canvas73.height = 1000;
  
  let maxCircles73 = 2000;
  let canvas73Filled = false;
  let minCircle73Size = 5;
  let maxCircle73Size = 100;
  let circle73SizeRatio = 1.5;
  let brightnessRatio73 = 1;
  let hue73 = 0;
  let angleOffset73 = 0;
  let sides73 = 3//Math.round(randBetween(3, 5));
  let skew73 = 0;
  let edges73 = false;
  let tilt73 = 15;
  
  function randColor73() {
    let s = Math.random() * Math.random() * 40;
    return `hsl(${hue73 + randBetween(-5, 5)}deg, ${randBetween(20, 40) + s}%, ${randBetween(30, 60) * brightnessRatio73}%)`;
  }
  
  function drawCircle73(x, y, radius) {
    //angleOffset73 = Math.random() * Math.PI * 2;
    ctx73.fillStyle = randColor73();
    
    ctx73.lineWidth = 2;
    ctx73.lineCap = ctx73.lineJoin = "round";
    ctx73.strokeStyle = "black";
    
    let numPoints = sides73;
    let angle = (Math.PI * 2) / numPoints;
    let corners = [];
    let offset = toRad(randBetween(-tilt73, tilt73));
    
    ctx73.beginPath();
    for (let i = 0; i < numPoints; i++) {
      let a = (angle * i) + angleOffset73 + offset + toRad(randBetween(-skew73, skew73));
      let r = radius;
      let iX = x + (r * Math.cos(a));
      let iY = y + (r * Math.sin(a));
      corners.push({x: iX, y: iY});
      ctx73.lineTo(iX, iY);
    }
    ctx73.lineTo(corners[0].x, corners[0].y);
    ctx73.lineTo(corners[1].x, corners[1].y);
    
    ctx73.fill();
    ctx73.stroke();
    
    ctx73.beginPath();
    
    let mX = (corners[0].x + corners[1].x + corners[2].x) / 3;
    let mY = (corners[0].y + corners[1].y + corners[2].y) / 3;
    let edges = [];
    for (let i = 0; i < 3; i++) {
      let j = corners[i];
      let k = corners[(i + 1) % 3];
      edges.push({x: (j.x + k.x) / 2, y: (j.y + k.y) / 2});
    }
    
    for (let i = 0; i < 3; i++) {
      ctx73.moveTo(mX, mY);
      if (edges73) ctx73.lineTo(edges[i].x, edges[i].y);
      else ctx73.lineTo(corners[i].x, corners[i].y);
    }
    
    ctx73.stroke();
    
  }
  
  function Circle73() {
    let x = Math.random() * canvas73.width;
    let y = Math.random() * canvas73.height;
    let tries = 0;
    while (!validatePoint73(x, y)) {
      if (tries > 1000) {
        canvas73Filled = true;
        return;
      }
      x = Math.random() * canvas73.width;
      y = Math.random() * canvas73.height;
      tries++;
    }
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.grow();
  }
  Circle73.prototype.grow = function() {
    let smallestDist = Infinity;
    for (let i = 0; i < circle73Array.length; i++) {
      if (i != circle73Array.indexOf(this)) {
        let dx = this.x - circle73Array[i].x;
        let dy = this.y - circle73Array[i].y;
        let distSq = (dx * dx) + (dy * dy);
        let dist = Math.sqrt(distSq) - circle73Array[i].radius;
        if (dist <= smallestDist) smallestDist = dist;
      }
    }
    // Uncomment to constrain within canvas edges:
    /*let distToTop = this.y;
    if (distToTop <= smallestDist) smallestDist = distToTop;
    let distToRight = canvas73.width - this.x;
    if (distToRight <= smallestDist) smallestDist = distToRight;
    let distToBottom = canvas73.height - this.y;
    if (distToBottom <= smallestDist) smallestDist = distToBottom;
    let distToLeft = this.x;
    if (distToLeft <= smallestDist) smallestDist = distToLeft;*/
    this.radius = Math.min(smallestDist, maxCircle73Size);
    drawCircle73(this.x, this.y, this.radius * circle73SizeRatio);
  };
  let circle73Array = [];
  
  function validatePoint73(x, y) {
    for (let i = 0; i < circle73Array.length; i++) {
      let dx = circle73Array[i].x - x;
      let dy = circle73Array[i].y - y;
      let distSq = (dx * dx) + (dy * dy);
      let r = circle73Array[i].radius + minCircle73Size;
      if (distSq <= r * r) return false; // Too close to a circle
    }
    // Uncomment to constrain within canvas edges:
    /*if (x < minCircle73Size || x > canvas73.width - minCircle73Size) return false; // Too close to left/right
    if (y < minCircle73Size || y > canvas73.height - minCircle73Size) return false; // Too close to top/bottom*/
    return true;
  }
  
  function draw73() {
    brightnessRatio73 = randBetween(0.8, 1.1);
    angleOffset73 = Math.random() * Math.PI * 2;
    hue73 = Math.random() * 360;
    edges73 = Math.random() < 0.5;
    tilt73 = randBetween(0, 15);
    skew73 = randBetween(0, 15);
    
    ctx73.fillStyle = `hsl(${hue73}deg, 80%, 15%)`;
    ctx73.fillRect(0, 0, canvas73.width, canvas73.height);
    
    canvas73Filled = false;
    circle73Array = [];
    while (circle73Array.length < maxCircles73 && !canvas73Filled) circle73Array.push(new Circle73());
  }
  draw73();
</script>
<canvas id = "canvas72"></canvas>
<button onclick = "draw72()">Redraw</button>
<div class = "desc"><b><i>(2/28/2022)</i></b> Random rock path generator, it's based on circle packing but instead of drawing circles it draws random rock shapes. I also worked with better color manipulation here, because each rock is colored as a random variation on a basic brown color, but less saturated. The orangey-brown shade of the rocks reminds me of a dry desert canyon.<br><b><i>Update: (Later that day)</i></b> I added a few more settings so I could test some ideas for variations but none of them really interested me so they're all at their default values.<br><b><i><mark>Actually finished! (2/28/2022)</mark> Added to <a href = "generative-art-gallery.html" target = "_blank">generative-art-gallery.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx72 = canvas72.getContext("2d");
  canvas72.width = canvas72.height = 1000;
  
  let maxCircles72 = 2000;
  let canvas72Filled = false;
  let minCircle72Size = 5;
  let maxCircle72Size = 100;
  let circle72SizeRatio = 1.1;
  let brightnessRatio72 = 1;
  let hue72 = 0;
  let drawChance72 = 1;
  let tinyRatio72 = 0.5; // Ratio at which rocks are considered "tiny" and take drawChance into account for if they will draw or not
  let firstRatio72 = 2; // Ratio that the first circle is drawn at
  let drawSpecialFirst72 = false; // Draw "pond" for first rock or not
  let minRockRadiusRatio72 = 0.8; // Lowest ratio of radius that rock vertices can be located at when drawing
  
  function randColor72() {
    let s = Math.random() * Math.random() * 40;
    return `hsl(${randBetween(25, 33) + hue72}deg, ${randBetween(20, 40) + s}%, ${randBetween(30, 60) * brightnessRatio72}%)`;
  }
  
  function drawCircle72(x, y, radius, isFirst) {
    if (isFirst) {
      ctx72.fillStyle = `hsl(${randBetween(220, 260)}deg, ${randBetween(75, 100)}%, ${randBetween(60, 75)}%)`;
      ctx72.fillCircle(x, y, radius);
      return;
    }
    ctx72.fillStyle = randColor72();
    
    let numPoints = 7;
    let angle = (Math.PI * 2) / numPoints;
    let offset = Math.random() * Math.PI * 2;
    let start = {};
    
    ctx72.beginPath();
    for (let i = 0; i < numPoints; i++) {
      let a = (angle * i) + offset + randBetween(-angle / 3, angle / 3);
      let r = radius * randBetween(minRockRadiusRatio72, 1);
      let iX = x + (r * Math.cos(a));
      let iY = y + (r * Math.sin(a));
      if (i === 0) start = {x: iX, y: iY};
      ctx72.lineTo(iX, iY);
    }
    ctx72.lineTo(start.x, start.y);
    
    ctx72.fill();
  }
  
  function Circle72(isFirst) {
    this.isFirst = isFirst;
    let x = Math.random() * canvas72.width;
    let y = Math.random() * canvas72.height;
    let tries = 0;
    while (!validatePoint72(x, y)) {
      if (tries > 1000) {
        canvas72Filled = true;
        return;
      }
      x = Math.random() * canvas72.width;
      y = Math.random() * canvas72.height;
      tries++;
    }
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.grow();
  }
  Circle72.prototype.grow = function() {
    let smallestDist = Infinity;
    for (let i = 0; i < circle72Array.length; i++) {
      if (i != circle72Array.indexOf(this)) {
        let dx = this.x - circle72Array[i].x;
        let dy = this.y - circle72Array[i].y;
        let distSq = (dx * dx) + (dy * dy);
        let dist = Math.sqrt(distSq) - circle72Array[i].radius;
        if (dist <= smallestDist) smallestDist = dist;
      }
    }
    // Uncomment to constrain within canvas edges:
    /*let distToTop = this.y;
    if (distToTop <= smallestDist) smallestDist = distToTop;
    let distToRight = canvas72.width - this.x;
    if (distToRight <= smallestDist) smallestDist = distToRight;
    let distToBottom = canvas72.height - this.y;
    if (distToBottom <= smallestDist) smallestDist = distToBottom;
    let distToLeft = this.x;
    if (distToLeft <= smallestDist) smallestDist = distToLeft;*/
    this.radius = Math.min(smallestDist, maxCircle72Size);
    let c = 0;
    if (this.radius < maxCircle72Size * tinyRatio72) c = drawChance72;
    else c = 1;
    let ratio = this.isFirst ? 1 + ((circle72SizeRatio - 1) / 2) : circle72SizeRatio;
    if (Math.random() < c) drawCircle72(this.x, this.y, this.radius * ratio, this.isFirst);
  };
  let circle72Array = [];
  
  function validatePoint72(x, y) {
    for (let i = 0; i < circle72Array.length; i++) {
      let dx = circle72Array[i].x - x;
      let dy = circle72Array[i].y - y;
      let distSq = (dx * dx) + (dy * dy);
      let r = circle72Array[i].radius + minCircle72Size;
      if (distSq <= r * r) return false; // Too close to a circle
    }
    // Uncomment to constrain within canvas edges:
    /*if (x < minCircle72Size || x > canvas72.width - minCircle72Size) return false; // Too close to left/right
    if (y < minCircle72Size || y > canvas72.height - minCircle72Size) return false; // Too close to top/bottom*/
    return true;
  }
  
  function draw72() {
    ctx72.fillStyle = "hsl(29deg, 82%, 22%)"; // Brown
    ctx72.fillRect(0, 0, canvas72.width, canvas72.height);
    
    brightnessRatio72 = randBetween(0.8, 1.1);
    
    canvas72Filled = false;
    circle72Array = [];
    
    if (drawSpecialFirst72) {
      maxCircle72Size *= firstRatio72;
      circle72Array.push(new Circle72(true));
      maxCircle72Size /= firstRatio72;
    }
    while (circle72Array.length < maxCircles72 && !canvas72Filled) circle72Array.push(new Circle72(false));
  }
  draw72();
</script>
<canvas id = "canvas71"></canvas>
<button onclick = "draw71()">Redraw</button>
<div class = "desc"><b><i>(2/28/2022)</i></b> I finally got a triangle grid working, but I wasn't really sure what to do with it so I have this kind of kite pattern thing, which isn't super interesting. It sort of reminds me of square holes covering the ground.</div>
<hr><hr>
<script>
  const ctx71 = canvas71.getContext("2d");
  canvas71.width = canvas71.height = 1000;
  
  const ratio71 = Math.sqrt(3) / 2;
  
  let gridSize71 = 6;
  
  function drawTriangle71(x, y, sideLength, flip, color) { //    /\: Normal    \/: flipped
    let cx = x;
    let cy = y;
    let ca = -Math.PI / 2;
    
    ctx71.lineWidth = 2;
    ctx71.lineCap = ctx71.lineJoin = "round";
    ctx71.fillStyle = color;
    
    ctx71.beginPath();
    ctx71.moveTo(cx, cy);
    for (let i = 0; i < 3; i++) {
      cx += sideLength * Math.cos(ca);
      cy += sideLength * Math.sin(ca);
      ca += ((2 * Math.PI) / 3) * (flip ? -1 : 1);
      ctx71.lineTo(cx, cy);
    }
    
    /*let mx = (points[0].x + points[1].x + points[2].x) / 3;
    let my = (points[0].y + points[1].y + points[2].y) / 3;
    
    for (let i = 0; i < 3; i++) {
      ctx71.moveTo(points[i].x, points[i].y);
      ctx71.lineTo(mx, my);
    }*/
    
    ctx71.fill();
    ctx71.stroke();
  }
  
  function draw71() {
    ctx71.fillStyle = "white";
    ctx71.fillRect(0, 0, canvas71.width, canvas71.height);
    
    let tileSize = canvas71.width / gridSize71;
    let numX = Math.ceil(gridSize71 / ratio71) + 1;
    let numY = gridSize71 + 2;
    
    for (let x = -1; x < numX; x++) {
      for (let y = -1; y < numY; y++) {
        let _x = x * tileSize * ratio71;
        let _y = x % 2 === 0 ? y : y - 0.5;
        _y *= tileSize;
        
        let hue = Math.random() * 360;
        let saturation = randBetween(50, 100);
        let layers = Math.round(randBetween(5, 10));
        let darkness = randBetween(5, 20);
        
        for (let i = layers; i > 0; i--) {
          let iRatio = i / layers;
          let color = `hsl(${hue}deg, ${saturation}%, ${(iRatio * 60) + darkness}%)`;
          drawTriangle71(_x, _y, tileSize * iRatio, false, color);
          drawTriangle71(_x, _y, tileSize * iRatio, true, color);
        }
      }
    }
  }
  draw71();
</script>
<canvas id = "canvas70"></canvas>
<button onclick = "draw70()">Redraw</button>
<div class = "desc"><b><i>(2/26/2022)</i></b> Nested tangent circles, each circle (inside the main circles) touches the edge of the one around it.<br><b><i>(3/1/2022)</i></b> Decreased the grid size and increased the outline width to make everything more visible.</div>
<hr><hr>
<script>
  const ctx70 = canvas70.getContext("2d");
  canvas70.width = canvas70.height = 1000;
  
  let gridSize70 = 5;
  let ratio70 = Math.sqrt(3) / 2;
  
  function drawCircle70(x, y, radius) {
    ctx70.beginPath();
    ctx70.arc(x, y, radius, 0, Math.PI * 2);
  }
  
  function draw70() {
    ctx70.fillStyle = "white";
    ctx70.fillRect(0, 0, canvas70.width, canvas70.height);
    
    let tileSize = canvas70.width / gridSize70;
    let columns = gridSize70 + 2; // Compensate for staggered rows and x-offset
    let rows = Math.ceil(gridSize70 * (1 / ratio70)) + 1; // Compensate for horizontal compression and y-offset
    
    let offsetX = Math.random() * tileSize;
    let offsetY = Math.random() * tileSize;
    
    for (let x = 0; x < columns; x++) {
      for (let y = -1; y < rows; y++) {
        let _x = y % 2 === 0 ? x : x - 0.5;
        _x += 0.5;
        _y = y * ratio70;
        _y += 0.5;
        
        let cx = (_x * tileSize) - offsetX; // Current x
        let cy = (_y * tileSize) - offsetY; // Current y
        let ca = Math.random() * Math.PI * 2; // Current angle
        let cr = tileSize / 2; // Current radius
        let sign = Math.random() < 0.5 ? 1 : -1;
        
        let layers = Math.round(randBetween(3, 5));
        let hue = Math.random() * 360;
        
        for (let i = 0; i < layers; i++) {
          ctx70.fillStyle = `hsla(${hue}deg, 50%, 15%, 0.4)`;
          ctx70.lineWidth = 2;
          drawCircle70(cx, cy, cr);
          ctx70.fill();
          ctx70.stroke();
          
          //ca += (Math.PI / 3) * sign;
          let lastCr = cr;
          cr *= randBetween(0.6, 0.8);
          let r = lastCr - cr;
          cx += r * Math.cos(ca);
          cy += r * Math.sin(ca);
        }
      }
    }
  }
  draw70();
</script>
<canvas id = "canvas69"></canvas>
<button onclick = "Walker69.draw()">Redraw</button>
<div class = "desc"><b><i>(2/25/2022)</i></b> Random walker but it has 3 degrees of freedom - hue, saturation, and/or lightness - which are randomly turned on or off every generation. If they are turned on, that degree will change randomly as it walks.</div>
<hr><hr>
<script>
  const ctx69 = canvas69.getContext("2d");
  canvas69.width = canvas69.height = 1000;
  
  let gridSize69 = 100;
  let variation69 = 5;
  let steps69 = 30000;
  
  let Walker69 = {};
  Walker69.walk = function() {
    let d = Math.floor(Math.random() * 4);
    
    if (d === 0) this.y--; // Up
    else if (d === 1) this.x++; // Right
    else if (d === 2) this.y++; // Down
    else if (d === 3) this.x--; // Left
    
    this.x = (this.x + gridSize69) % gridSize69;
    this.y = (this.y + gridSize69) % gridSize69;
    
    if (this.changeH) {
      this.H += Math.random() * variation69 * randSign();
    }
    if (this.changeS) {
      let step = Math.random() * variation69;
      if (this.S < step) this.S += step;
      else if (this.S > 100 - step) this.S -= step;
      else this.S += step * randSign();
    }
    if (this.changeL) {
      let step = Math.random() * variation69;
      if (this.L < step) this.L += step;
      else if (this.L > 100 - step) this.L -= step;
      else this.L += step * randSign();
    }
    
    ctx69.fillStyle = `hsl(${this.H}deg, ${this.S}%, ${this.L}%)`;
    let tileSize = canvas69.width / gridSize69;
    ctx69.fillRect(this.x * tileSize, this.y * tileSize, tileSize, tileSize);
  };
  Walker69.draw = function() {
    ctx69.fillStyle = "white";
    ctx69.fillRect(0, 0, canvas69.width, canvas69.height);
    
    this.x = Math.floor(gridSize69 / 2);
    this.y = Math.floor(gridSize69 / 2);
    
    this.changeH = Math.random() < 0.5;
    this.changeS = Math.random() < 0.5;
    this.changeL = Math.random() < 0.5;
    if (!this.changeH && !this.changeS && !this.changeL) {
      this.changeH = this.changeS = this.changeL = true;
    }
    
    this.H = Math.random() * 360;
    this.S = randBetween(25, 100);
    this.L = randBetween(25, 75);
    
    for (let i = 0; i < steps69; i++) this.walk();
  };
  Walker69.draw();
</script>
<canvas id = "canvas68"></canvas>
<button onclick = "draw68()">Redraw</button>
<div class = "desc"><b><i>(2/24/2022)</i></b> Random <a href = "https://en.wikipedia.org/wiki/Pythagorean_tiling" target = "_blank">Pythagorean tiling</a> with the same concentric coloring from the hexagon grid.<br><b><i>(2/25/2022)</i></b> Added more randomness, the grid size and size of the smaller square is randomized every generation.</div>
<hr><hr>
<script>
  const ctx68 = canvas68.getContext("2d");
  canvas68.width = canvas68.height = 1000;
  
  let gridSize68 = 5;
  let ratio68 = 0.3;
  
  function drawTile68(x, y, size, flip) {
    let cx = x + (size / 2);
    let cy = y + (size / 2);
    
    let hue = Math.random() * 360;
    let saturation = randBetween(50, 100);
    
    let layers = Math.round(randBetween(2, 5));
    for (let i = layers; i > 0; i--) {
      let iRatio = i / layers;
      let bRatio = flip ? 1 - iRatio : iRatio;
      ctx68.fillStyle = ctx68.strokeStyle = `hsl(${hue}deg, ${saturation}%, ${(bRatio * 40) + 25}%)`;
      ctx68.fillRectFromCenter(cx, cy, size * iRatio, size * iRatio);
      ctx68.strokeRectFromCenter(cx, cy, size * iRatio, size * iRatio);
    }
  }
  
  function draw68() {
    ctx68.fillStyle = "white";
    ctx68.fillRect(0, 0, canvas68.width, canvas68.height);
    
    ratio68 = randBetween(0.2, 0.6);
    gridSize68 = Math.round(randBetween(3, 8));
    
    let tileSize = canvas68.width / gridSize68;
    let offset = Math.ceil(gridSize68 * ratio68) + 1;
    let sign = Math.random() < 0.5 ? 1 : -1;
    let flip = Math.random() < 0.5;
    
    for (let x = -offset; x < gridSize68 + offset; x++) {
      for (let y = -offset; y < gridSize68 + offset; y++) {
        let _x = x + (y * ratio68 * sign);
        let _y = y + (x * ratio68 * -sign);
        drawTile68(_x * tileSize, _y * tileSize, tileSize, flip); // Big square
        
        _x = (_x * tileSize) + tileSize;
        _y = (_y * tileSize) + (sign === 1 ? tileSize - (tileSize * ratio68) : 0);
        drawTile68(_x, _y, tileSize * ratio68, !flip); // Little square
      }
    }
  }
  draw68();
</script>
<canvas id = "canvas67"></canvas>
<button onclick = "draw67()">Redraw</button>
<div class = "desc"><b><i>(2/22/2022)</i></b> Random concentric hexagon grid tiling.</div>
<hr><hr>
<script>
  const ctx67 = canvas67.getContext("2d");
  canvas67.width = canvas67.height = 1000;
  
  const ratio67 = Math.sqrt(3) / 2;
  let gridSize67 = 20;
  
  function drawHexagon67(x, y, radius) { // Radius: side to opposite side
    let side = radius / ratio67;
    
    let cx = x - radius;
    let cy = y - (side / 2);
    let ca = 90;
    
    ctx67.lineWidth = 2;
    ctx67.lineCap = ctx67.lineJoin = "round";
    
    let vertices = [];
    
    ctx67.beginPath();
    ctx67.moveTo(cx, cy);
    for (let i = 0; i < 6; i++) {
      vertices.push({x: cx, y: cy});
      cx += side * Math.cos(toRad(ca));
      cy += side * Math.sin(toRad(ca));
      ca -= 60;
      ctx67.lineTo(cx, cy);
    }
  }
  
  function draw67() {
    ctx67.fillStyle = "white";
    ctx67.fillRect(0, 0, canvas67.width, canvas67.height);
    
    gridSize67 = Math.round(randBetween(5, 15));
    
    let tileSize = canvas67.width / gridSize67;
    let columns = gridSize67 + 2; // Compensate for staggered rows and x-offset
    let rows = Math.ceil(gridSize67 * (1 / ratio67)) + 1; // Compensate for horizontal compression and y-offset
    
    let offsetX = Math.random() * tileSize;
    let offsetY = Math.random() * tileSize;
    
    for (let x = 0; x < columns; x++) {
      for (let y = -1; y < rows; y++) {
        let _x = y % 2 === 0 ? x : x - 0.5;
        _x += 0.5;
        _y = y * ratio67;
        _y += 0.5;
        
        let hexX = (_x * tileSize) - offsetX;
        let hexY = (_y * tileSize) - offsetY;
        
        let layers = Math.round(randBetween(Math.random() < 0.5 ? 1 : 2, 5));
        let hue = Math.random() * 360;
        let swap = Math.random() < 0.5;
        let saturation = randBetween(50, 100);
        for (let i = layers; i > 0; i--) {
          let iRatio = i / layers;
          let bRatio = swap ? 1 - iRatio : iRatio;
          let brightness = (bRatio * 40) + 25;
          ctx67.fillStyle = ctx67.strokeStyle = `hsl(${hue}deg, ${saturation}%, ${brightness}%)`;
          drawHexagon67(hexX, hexY, tileSize * 0.5 * iRatio);
          ctx67.fill();
          ctx67.stroke();
        }
      }
    }
  }
  draw67();
</script>
<canvas id = "canvas66"></canvas>
<button onclick = "draw66()">Redraw</button>
<div class = "desc"><b><i>(2/22/2022)</i></b> Random cubic optical illusion generator, it looks 3D and you can make it flip orientations in your mind.</div>
<hr><hr>
<script>
  const ctx66 = canvas66.getContext("2d");
  canvas66.width = canvas66.height = 1000;
  
  const ratio66 = Math.sqrt(3) / 2;
  let gridSize66 = 25;
  let brightColor66;
  let darkColor66;
  
  function drawHexagon66(x, y, radius, flip) { // Radius: side to opposite side
    let side = radius / ratio66;
    
    let cx = x - radius;
    let cy = y - (side / 2);
    let ca = 90;
    
    ctx66.lineWidth = 2;
    ctx66.lineCap = ctx66.lineJoin = "round";
    
    let vertices = [];
    
    for (let i = 0; i < 6; i++) {
      vertices.push({x: cx, y: cy});
      cx += side * Math.cos(toRad(ca));
      cy += side * Math.sin(toRad(ca));
      ca -= 60;
    }
    
    let offset = flip ? 1 : 0;
    
    for (let i = 0; i < 3; i++) {
      let brightSide;
      if (!flip) brightSide = i === 2;
      else brightSide = i === 0;
      
      let j = (i * 2) + offset;
      let v1 = vertices[j];
      let v2 = vertices[(j + 1) % 6];
      let v3 = vertices[(j + 2) % 6];
      
      ctx66.fillStyle = brightSide ? brightColor66 : darkColor66;
      
      ctx66.beginPath();
      ctx66.moveTo(x, y);
      ctx66.lineTo(v1.x, v1.y);
      ctx66.lineTo(v2.x, v2.y);
      ctx66.lineTo(v3.x, v3.y);
      ctx66.lineTo(x, y);
      ctx66.fill();
      ctx66.stroke();
    }
  }
  
  function draw66() {
    ctx66.fillStyle = "white";
    ctx66.fillRect(0, 0, canvas66.width, canvas66.height);
    
    gridSize66 = Math.round(randBetween(5, 25));
    
    let tileSize = canvas66.width / gridSize66;
    let offsetX = Math.random() * tileSize;
    let offsetY = Math.random() * tileSize;
    
    let hue = Math.random() * 360;
    brightColor66 = `hsl(${hue}deg, 100%, 60%)`;
    darkColor66 = `hsl(${hue + 180}deg, 50%, 40%)`;
    
    for (let x = 0; x < gridSize66 + 2; x++) {
      for (let y = -1; y < gridSize66 + 6; y++) {
        let _x = y % 2 === 0 ? x : x - 0.5;
        _x += 0.5;
        _y = y * ratio66;
        _y += 0.5;
        drawHexagon66((_x * tileSize) - offsetX, (_y * tileSize) - offsetY, tileSize / 2, Math.random() < 0.5);
      }
    }
  }
  draw66();
</script>
<canvas id = "canvas65"></canvas>
<button onclick = "draw65()">Redraw</button>
<div class = "desc"><b><i>(2/21/2022)</i></b> I tried to make a different snowflake generator than the one I made for <a href = "snowflake.html" target = "_blank">snowflake.html</a> by using symmetric fractal trees, but I'm not super impressed with the result.</div>
<hr><hr>
<script>
  const ctx65 = canvas65.getContext("2d");
  canvas65.width = canvas65.height = 1000;
  
  let maxDepth65 = 8;
  let symmetry65 = 6;
  let startLength65 = 150;
  let startWidth65 = 10;
  let lengthRatio65 = 0.75;
  let widthRatio65 = 0.8;
  let branchAngle65 = 60;
  
  function drawBranch65(x, y, angle, length, width, depth) {
    if (depth > maxDepth65) return;
    
    let endX = x + (length * Math.cos(angle));
    let endY = y + (length * Math.sin(angle));
    
    ctx65.strokeStyle = `hsl(240deg, 100%, ${((depth / maxDepth65) * 70) + 30}%)`;
    ctx65.lineWidth = width;
    ctx65.lineCap = ctx65.lineJoin = "round";
    ctx65.beginPath();
    ctx65.moveTo(x, y);
    ctx65.lineTo(endX, endY);
    ctx65.stroke();
    
    let newLength = length * lengthRatio65;
    let newWidth = width * widthRatio65;
    
    if (depth + 1 <= maxDepth65) {
      drawBranch65(endX, endY, angle - toRad(branchAngle65), newLength, newWidth, depth + 1);
      drawBranch65(endX, endY, angle + toRad(branchAngle65), newLength, newWidth, depth + 1);
    }
  }
  
  function draw65() {
    ctx65.fillStyle = "black";
    ctx65.fillRect(0, 0, canvas65.width, canvas65.height);
    
    lengthRatio65 = randBetween(0.6, 0.75);
    branchAngle65 = randBetween(20, 45);
    symmetry65 = Math.round(randBetween(3, 8));
    
    for (let i = 0; i < symmetry65; i++) {
      drawBranch65(
        canvas65.width / 2, // x
        canvas65.height / 2, // y
        ((i / symmetry65) * Math.PI * 2) - (Math.PI / 2), // angle
        startLength65, // length
        startWidth65, // width
        1 // depth
      );
    }
  }
  draw65();
</script>
<canvas id = "canvas64"></canvas>
<button onclick = "draw64()">Redraw</button>
<div class = "desc"><b><i>(2/21/2022)</i></b> Tiling the plane with Tetris-style T-blocks, along with some random coloring.</div>
<hr><hr>
<script>
  const ctx64 = canvas64.getContext("2d");
  canvas64.width = canvas64.height = 1000;
  
  let gridSize64 = 10;
  let sizeRatio64 = 1;
  
  function drawTBlock64(x, y, size, flip) {
    let xSign = flip ? -1 : 1;
    let s2 = size / 2;
    
    let cx = x + (s2 * xSign) + ((size / 4) * xSign);
    let cy = y - (size / 4);
    
    ctx64.beginPath();
    ctx64.moveTo(cx, cy);
    
    cx -= s2 * xSign;
    ctx64.lineTo(cx, cy);
    
    cy -= s2;
    ctx64.lineTo(cx, cy);
    
    cx -= s2 * xSign;
    ctx64.lineTo(cx, cy);
    
    cy += s2 * 3;
    ctx64.lineTo(cx, cy);
    
    cx += s2 * xSign;
    ctx64.lineTo(cx, cy);
    
    cy -= s2;
    ctx64.lineTo(cx, cy);
    
    cx += s2 * xSign;
    ctx64.lineTo(cx, cy);
    
    cy -= s2;
    ctx64.lineTo(cx, cy);
  }
  
  function draw64() {
    ctx64.fillStyle = "white";
    ctx64.fillRect(0, 0, canvas64.width, canvas64.height);
    
    gridSize64 = Math.round(randBetween(5, 25));
    let tileSize = canvas64.width / gridSize64;
    let hueOffset = Math.random() * 360;
    
    for (let x = 0; x < gridSize64; x++) {
      for (let y = -1; y < gridSize64 + 1; y++) {
        let sign = x % 2 !== 0;
        if (y % 2 !== 0) sign = !sign;
        
        let yRatio = y / gridSize64;
        let xRatio = x / gridSize64;
        
        ctx64.fillStyle = ctx64.strokeStyle = `hsl(${hueOffset + (yRatio * 360) + randBetween(-15, 15)}deg, ${randBetween(50, 100)}%, ${((xRatio * 50) + 25) + randBetween(-15, 15)}%)`;
        let size = tileSize * sizeRatio64;
        drawTBlock64(((x + 0.5) * tileSize) - ((size / 4) * (sign ? -1 : 1)), (y + 0.5) * tileSize, size, sign);
        ctx64.fill();
        ctx64.stroke();
      }
    }
  }
  draw64();
</script>
<canvas id = "canvas63" style = "width: 500px; height: 500px"></canvas>
<button onclick = "ShapeWalker63.walk()">Regenerate</button>
<div><b><u>Turn Chance:</u></b> <span id = "turnChance63Txt">100</span>%</div>
<input type = "range" min = "0" max = "100" step = "10" value = "100" id = "turnChance63Range" oninput = "updateSettings63()">
<div class = "desc"><b><i>(2/17/2022)</i></b> A variation on the previous project, with the same shape walker idea but uncontstrained, and it cycles through a few different shapes and colors every time.</div>
<hr><hr>
<script>
  const ctx63 = canvas63.getContext("2d");
  canvas63.width = canvas63.height = 1000;
  
  let stepSize63 = 20;
  let stepsToChange63 = 5000;
  let turnChance63 = 1;
  let numWalks63 = 5;
  let opacity63 = 0.5;
  let lineWidth63 = 2;
  let shadowOpacity63 = 0.5;
  let shadowScale63 = 10;
  
  let shape63Array = [
    { // Triangle
      angle: 120,
      scale: 1,
      hue: 0
    },
    { // Square
      angle: 90,
      scale: 0.8,
      hue: 120
    },
    { // Hexagon
      angle: 60,
      scale: 0.5,
      hue: 240
    }
  ];
  
  function randShape63() {
    return shape63Array[Math.floor(Math.random() * shape63Array.length)];
  }
  
  let ShapeWalker63 = {};
  ShapeWalker63.resetPos = function() {
    this.x = Math.random() * canvas63.width;
    this.y = Math.random() * canvas63.height;
    this.angle = Math.random() * 360;
    
    this.shape = randShape63();
    this.color = `hsla(${Math.random() * 360}deg, 50%, ${randBetween(50, 70)}%, ${opacity63})`;
  };
  ShapeWalker63.walk = function() {
    ctx63.fillStyle = "black";
    ctx63.fillRect(0, 0, canvas63.width, canvas63.height);
    
    this.stepSize = randBetween(0.5, 1) * stepSize63;
    
    for (let i = 0; i < numWalks63; i++) {
      this.resetPos();
      
      ctx63.strokeStyle = this.color;
      ctx63.lineWidth = 2;
      ctx63.lineCap = ctx63.lineJoin = "round";
      
      ctx63.beginPath();
      ctx63.moveTo(this.x, this.y);
      
      for (let j = 0; j < stepsToChange63; j++) {
        if (Math.random() < turnChance63) this.angle += this.shape.angle * randSign();
        this.x += this.stepSize * this.shape.scale * Math.cos(toRad(this.angle));
        this.y += this.stepSize * this.shape.scale * Math.sin(toRad(this.angle));
        
        ctx63.lineTo(this.x, this.y);
      }
      
      ctx63.globalAlpha = shadowOpacity63;
      ctx63.lineWidth = lineWidth63 * shadowScale63;
      ctx63.stroke();
      
      ctx63.globalAlpha = 1;
      ctx63.lineWidth = lineWidth63;
      ctx63.stroke();
    }
  };
  ShapeWalker63.walk();
  
  function updateSettings63() {
    turnChance63Txt.innerHTML = turnChance63Range.value;
    turnChance63 = Number(turnChance63Range.value) / 100;
  }
</script>
<canvas id = "canvas62" style = "width: 500px; height: 500px"></canvas>
<button onclick = "draw62()">Regenerate</button>
<div class = "desc"><b><i>(2/16/2022)</i></b> Small clusters of connected shapes generated by a grid of random walkers that each have a set turn size (120&deg;, 90&deg;, or 60&deg; (for triangle, square, or hexagon, respectively)) and walk around randomly until they leave their square.</div>
<hr><hr>
<script>
  const ctx62 = canvas62.getContext("2d");
  canvas62.width = canvas62.height = 1000;
  
  let gridSize62 = 8;
  let padding62 = 0;
  let drawChance62 = 1;
  let turnChance62 = 1;
  let hueOffset62 = Math.random() * 360;
  
  let shape62Array = [
    { // Triangle
      angle: 120,
      scale: 1,
      hue: 0
    },
    { // Square
      angle: 90,
      scale: 0.8,
      hue: 120
    },
    { // Hexagon
      angle: 60,
      scale: 0.5,
      hue: 240
    }
  ];
  
  function randShape62() {
    return shape62Array[Math.floor(Math.random() * shape62Array.length)];
  }
  
  function drawShape62(x, y, size) {
    let shape = randShape62();
    
    ctx62.strokeStyle = `hsl(${shape.hue + hueOffset62}deg, 50%, ${randBetween(40, 60)}%)`;
    ctx62.lineWidth = 2;
    ctx62.lineCap = ctx62.lineJoin = "round";
    
    let cx = x + (size / 2);
    let cy = y + (size / 2);
    let ca = Math.random() * 360;
    let stepSize = size * randBetween(0.08, 0.2) * shape.scale;
    
    ctx62.beginPath();
    ctx62.moveTo(cx, cy);
    
    while (true) {
      let lastX = cx;
      let lastY = cy;
      if (Math.random() < turnChance62) ca += shape.angle * randSign();
      cx += stepSize * Math.cos(toRad(ca));
      cy += stepSize * Math.sin(toRad(ca));
      
      let xOff = cx < x || cx > x + size;
      let yOff = cy < y || cy > y + size;
      
      if (xOff || yOff) {
        ctx62.stroke();
        return;
      }
      
      ctx62.lineTo(cx.clamp(x, x + size), cy.clamp(y, y + size));
    }
  }
  
  function draw62() {
    ctx62.fillStyle = "black";
    ctx62.fillRect(0, 0, canvas62.width, canvas62.height);
    
    hueOffset62 = Math.random() * 360;
    
    let tileSize = canvas62.width / gridSize62;
    let padding = tileSize * padding62;
    
    for (let x = 0; x < gridSize62; x++) {
      for (let y = 0; y < gridSize62; y++) {
        let _x = (x * tileSize) + padding;
        let _y = (y * tileSize) + padding;
        if (Math.random() < drawChance62) drawShape62(_x, _y, tileSize - (padding * 2));
      }
    }
  }
  draw62();
</script>
<canvas id = "canvas61"></canvas>
<button onclick = "startCanvas61(this)" style = "color: red; border-color: red"><b><i>Paused</i></b></button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>[ FPS: <span id = "fps61Txt"></span> ]</b></i></div>
<div class = "desc"><b><i>(2/16/2022)</i></b> Experimenting with more particle physics, this time with "blades" cutting around the screen and shooting sparks.</div>
<hr><hr>
<script>
  const ctx61 = canvas61.getContext("2d");
  canvas61.width = canvas61.height = 1000;
  let canvas61Running = false;
  
  let ratio61 = Math.random();
  let period61 = 300;
  
  let showPaths61 = false;
  
  let maxSpark61Age = 200;
  let spark61Size = 3;
  let spark61Bounciness = 0.5;
  let spark61Gravity = 0.25;
  
  function smoothEase61(ratio) {
    // Map number between 0 and 1 to partial cosine wave, smoothing out the ends and wrapping around
    return (1 - Math.cos(Math.PI * 2 * ratio)) / 2;
  }
  
  function Blade61(pathType, pathSpecs) {
    this.ratioOffset = Math.random();
    
    this.pathType = pathType;
    if (this.pathType === 0) { // Line
      this.start = pathSpecs.start;
      this.end = pathSpecs.end;
      this.dx = this.end.x - this.start.x;
      this.dy = this.end.y - this.start.y;
    }
    else if (this.pathType === 1) { // Ellipse
      this.ellipse = pathSpecs.ellipse;
      this.radiusX = pathSpecs.radiusX;
      this.radiusY = pathSpecs.radiusY;
    }
  }
  Blade61.prototype.update = function() {
    if (this.pathType === 0) { // Line
      let smoothRatio = smoothEase61((ratio61 + this.ratioOffset) % 1);
      this.x = this.start.x + (this.dx * smoothRatio);
      this.y = this.start.y + (this.dy * smoothRatio);
    }
    else if (this.pathType === 1) { // Ellipse
      let angle = ((ratio61 + this.ratioOffset) % 1) * Math.PI * 2;
      this.x = this.ellipse.x + (this.radiusX * Math.cos(angle));
      this.y = this.ellipse.y + (this.radiusY * Math.sin(angle));
    }
    
    let dx = this.x - this.lastX;
    let dy = this.y - this.lastY;
    for (let i = 0; i < 2; i++) spark61Array.push(new Spark61(this.x, this.y, -dx, -dy));
    
    this.lastX = this.x;
    this.lastY = this.y;
  };
  Blade61.prototype.draw = function() {
    if (showPaths61) {
      ctx61.strokeStyle = "gray";
      ctx61.lineWidth = 2;
      if (this.pathType === 0) { // Line
        ctx61.beginPath();
        ctx61.moveTo(this.start.x, this.start.y);
        ctx61.lineTo(this.end.x, this.end.y);
        ctx61.stroke();
      }
      else if (this.pathType === 1) { // Ellipse
        ctx61.beginPath();
        ctx61.ellipse(this.ellipse.x, this.ellipse.y, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);
        ctx61.stroke();
      }
    }
    
    ctx61.fillCircle(this.x, this.y, 5);
  };
  let blade61Array = [];
  
  function Spark61(x, y, vx, vy) {
    this.x = x;
    this.y = y;
    this.lastX = this.x;
    this.lastY = this.y;
    this.vx = vx + randBetween(-2, 2);
    this.vy = vy + randBetween(-2, 2);
    this.age = 0;
    this.maxAge = Math.round(randBetween(0.5, 1) * maxSpark61Age);
    this.size = randBetween(0.75, 1) * spark61Size;
    
    this.dead = false;
    
    this.hue = 60//240 + randBetween(-15, 15);
  }
  Spark61.prototype.update = function() {
    this.age++;
    if (this.age >= this.maxAge) {
      this.dead = true;
      return;
    }
    
    this.vy += spark61Gravity;
    
    this.x += this.vx;
    this.y += this.vy;
    
    if (this.x < 0) {
      this.x = 0;
      this.vx *= -spark61Bounciness;
    }
    if (this.x > canvas61.width) {
      this.x = canvas61.width;
      this.vx *= -spark61Bounciness;
    }
    if (this.y < 0) {
      this.y = 0;
      this.vy *= -spark61Bounciness;
    }
    if (this.y > canvas61.height) {
      this.y = canvas61.height;
      this.vy *= -spark61Bounciness;
    }
  };
  Spark61.prototype.draw = function() {
    let ratio = 1 - (this.age / this.maxAge);
    if (ratio < 0) ratio = 0;
    
    ctx61.lineCap = ctx61.lineJoin = "round";
    ctx61.strokeStyle = `hsl(${this.hue}deg, 100%, ${ratio * 75}%)`;
    ctx61.lineWidth = this.size//(this.size * 0.5) + (this.size * 0.5 * ratio);
    
    
    ctx61.beginPath();
    ctx61.moveTo(this.lastX, this.lastY);
    ctx61.lineTo(this.x, this.y);
    ctx61.stroke();
    
    this.lastX = this.x;
    this.lastY = this.y;
  };
  let spark61Array = [];
  
  let lastFrame61Time = 0;
  let lastFps61DisplayTime = 1000;
  function frame61() {
    if (Date.now() - lastFps61DisplayTime >= 500) {
      fps61Txt.innerHTML = (1000 / (Date.now() - lastFrame61Time)).toFixed(1);
      lastFps61DisplayTime = Date.now();
    }
    lastFrame61Time = Date.now();
    
    ctx61.fillStyle = "black";
    ctx61.fillRect(0, 0, canvas61.width, canvas61.height);
    
    ratio61 += 1 / period61;
    ratio61 %= 1;
    
    for (let i = 0; i < blade61Array.length; i++) {
      blade61Array[i].update();
      //blade61Array[i].draw();
    }
    
    for (let i = 0; i < spark61Array.length; i++) {
      spark61Array[i].update();
      spark61Array[i].draw();
      
      if (spark61Array[i].dead) {
        spark61Array.splice(i, 1);
        i--;
      }
    }
    
    if (canvas61Running) requestAnimationFrame(frame61);
  }
  
  function reset61() {
    ctx61.fillStyle = "black";
    ctx61.fillRect(0, 0, canvas61.width, canvas61.height);
    
    ratio61 = Math.random();
    
    blade61Array = [];
    spark61Array = [];
    
    for (let i = 0; i < 1; i++) {
      blade61Array.push(new Blade61(
        1, // Path Type
        { // Path Specs
          ellipse: {
            x: 500,
            y: 500
          },
          radiusX: 400,
          radiusY: 400
        }
      ));
    }
    
    let padding = 100;
    blade61Array.push(new Blade61(
      0, // Path Type
      { // Path Specs
        start: {
          x: padding,
          y: padding
        },
        end: {
          x: canvas61.width - padding,
          y: canvas61.height - padding
        }
      }
    ));
    blade61Array.push(new Blade61(
      0, // Path Type
      { // Path Specs
        start: {
          x: canvas61.width - padding,
          y: padding
        },
        end: {
          x: padding,
          y: canvas61.height - padding
        }
      }
    ));
    
    if (!canvas61Running) frame61();
  }
  reset61();
  
  function startCanvas61(caller) {
    if (canvas61Running) {
      canvas61Running = false;
      caller.innerHTML = "<b><i>Paused</i></b>";
      caller.style.color = caller.style.borderColor = "red";
    }
    else {
      canvas61Running = true;
      caller.innerHTML = "<b><i>Running</i></b>";
      caller.style.color = caller.style.borderColor = "green";
      frame61();
    }
  }
</script>
<canvas id = "canvas60"></canvas>
<button onclick = "draw60()">Regenerate</button>
<div class = "desc"><b><i>(2/12/2022)</i></b> Another Genuary 2021 prompt, this time from January 25th's "Make a grid of permutations of something." I'm not super happy with how this turned out but it looks sort of interesting. It's a 23x23 grid where each square shows the next number in binary (backwards) (with lime being 0 and black being 1) drawn in another smaller 3x3 grid. So, the first tile is 0 in binary, being<br><b>000<br>000<br>000</b><br> And the next one is 1 in binary, being<br><b>100<br>000<br>000</b>, and so on.<br>For example the 21st tile would be<br><b>101<br>010<br>000</b>.<br><b><i>(2/15/2022)</i></b> Added randomness--it works in the same way except that the first tile isn't always 0, it's a random number between 1 and 511. Then the next tile isn't always just one more, it's a random amount more. It's still pretty dull for the most part but at least it's not always the exact same.<br><b><i>Update: (A few minutes later)</i></b> I added some more randomness so that the color is random as well as the size of each tile when it's drawn, to give some more variation.</div>
<hr><hr>
<script>
  const ctx60 = canvas60.getContext("2d");
  canvas60.width = canvas60.height = 1000;
  
  let colors60 = [`hsl(120deg, 100%, 50%)`, "black"];
  let ratio60 = 2;
  let stepSize60 = 3;
  let opacity60 = 0.5;
  
  function drawTile60(_x, _y, size, string) {
    let tileSize = size / 3;
    
    let i = 0;
    
    for (let y = 0; y < 3; y++) {
      for (let x = 0; x < 3; x++) {
        ctx60.fillStyle = ctx60.strokeStyle = colors60[Number(string.charAt(string.length - 1 - i))];
        ctx60.globalAlpha = opacity60;
        ctx60.lineWidth = 2;
        
        let tileX = _x + (x * tileSize);
        let tileY = _y + (y * tileSize);
        let tileSizeScaled = tileSize * ratio60;
        
        let tileCX = tileX + (tileSizeScaled / 2);
        let tileCY = tileY + (tileSizeScaled / 2);
        
        ctx60.fillRectFromCenter(tileCX, tileCY, tileSizeScaled, tileSizeScaled);
        ctx60.strokeRectFromCenter(tileCX, tileCY, tileSizeScaled, tileSizeScaled);
        
        ctx60.globalAlpha = 1;
        
        i++;
      }
    }
  }
  
  function draw60() {
    ctx60.globalAlpha = 1;
    ctx60.fillStyle = "black";
    ctx60.fillRect(0, 0, canvas60.width, canvas60.height);
    
    colors60[0] = `hsl(${Math.random() * 360}deg, 100%, 50%)`;
    ratio60 = randBetween(1, 2);
    
    let tileSize = canvas60.width / 23;
    
    let i = Math.floor(Math.random() * 511);
    
    for (let y = 0; y < 23; y++) {
      for (let x = 0; x < 23; x++) {
        drawTile60(x * tileSize, y * tileSize, tileSize, i.toString(2).padStart(9, "0"));
        i += Math.round(randBetween(1, stepSize60));
        //if (i > 511) return;
      }
    }
  }
  draw60();
</script>
<canvas id = "canvas59" style = "width: 500px; height: 500px"></canvas>
<button onclick = "draw59()">Regenerate</button>
<div class = "desc"><b><i>(2/12/2022)</i></b> Another late Genuary project, this time inspired from last year's prompt for January 4th: "Small areas of symmetry." Each tile has vertical and horizontal symmetry, and a randomized grid size.</div>
<hr><hr>
<script>
  const ctx59 = canvas59.getContext("2d");
  canvas59.width = canvas59.height = 1000;
  
  let hueVariation59 = 0.1;
  
  function randGridSize59() {
    let arr = [5, 10, 20, 25];
    return arr[Math.floor(Math.random() * arr.length)];
  }
  
  function drawTile59(_x, _y, size, hue) {
    let gridSize = randGridSize59();
    let tileSize = size / gridSize;
    
    let hue1 = hue + randBetween(hueVariation59 * -180, hueVariation59 * 180);
    let hue2 = hue1 + 180 + randBetween(hueVariation59 * -180, hueVariation59 * 180);
    let color1 = `hsl(${hue1}deg, ${randBetween(50, 100)}%, ${randBetween(40, 60)}%)`;
    let color2 = `hsl(${hue2}deg, ${randBetween(50, 100)}%, ${randBetween(40, 60)}%)`;
    
    for (let x = 0; x < gridSize / 2; x++) {
      for (let y = 0; y < gridSize / 2; y++) {
        let xM = gridSize - x - 1; // Mirrored x
        let yM = gridSize - y - 1; // Mirrored y
        
        ctx59.fillStyle = Math.random() < 0.5 ? color1 : color2;
        
        ctx59.fillRect(_x + (x * tileSize), _y + (y * tileSize), tileSize, tileSize);
        ctx59.fillRect(_x + (xM * tileSize), _y + (y * tileSize), tileSize, tileSize);
        ctx59.fillRect(_x + (x * tileSize), _y + (yM * tileSize), tileSize, tileSize);
        ctx59.fillRect(_x + (xM * tileSize), _y + (yM * tileSize), tileSize, tileSize);
      }
    }
  }
  
  function draw59() {
    ctx59.fillStyle = "white";
    ctx59.fillRect(0, 0, canvas59.width, canvas59.height);
    
    let gridSize = 10;
    let tileSize = canvas59.width / gridSize;
    let hue = Math.random() * 360;
    
    for (let x = 0; x < gridSize; x++) {
      for (let y = 0; y < gridSize; y++) {
        drawTile59(x * tileSize, y * tileSize, tileSize, hue);
      }
    }
  }
  draw59();
</script>
<canvas id = "canvas58" style = "width: 500px; height: 500px"></canvas>
<button onclick = "draw58()">Regenerate</button>
<div class = "desc"><b><i>(2/10/2022)</i></b> A late project inspired by Genuary 2022's prompt for January 20th: "Make a sea of shapes."</div>
<hr><hr>
<script>
  const ctx58 = canvas58.getContext("2d");
  canvas58.width = canvas58.height = 1000;
  
  function multRand58(n) { // Multiply n random numbers together
    let prod = 1;
    for (let i = 0; i < n; i++) prod *= Math.random();
    return prod;
  }
  
  function colorFromRatio58(ratio, hue) {
    return `hsl(${hue + (ratio * 80) - 40}deg, 80%, ${75 - (ratio * 40)}%)`;
  }
  function sizeFromRatio58(ratio) {
    return 20 * ((ratio * 0.75) + 0.25);
  }
  
  function drawRandSquare58(_x, hue) {
    let x = _x + (multRand58(3) * canvas58.width * 0.5 * randSign());
    let y = (canvas58.height / 2) + (multRand58(2) * canvas58.height * 0.5 * randSign());
    
    let ratioX = x / canvas58.width;
    let ratioY = 1 - (Math.abs(y - (canvas58.height / 2)) / (canvas58.height / 2));
    
    ctx58.fillStyle = colorFromRatio58(ratioX, hue);
    ctx58.globalAlpha = ratioY;
    
    let s = sizeFromRatio58(ratioY);
    let s2 = s / 2;
    
    ctx58.fillRect(x - s2, y - s2, s, s);
    ctx58.strokeRect(x - s2, y - s2, s, s);
  }
  
  function drawRandTriangle58(_x, hue) {
    for (let j = 0; j < 2; j++) {
      let x = _x + (multRand58(3) * canvas58.width * 0.5 * randSign());
      let y = (canvas58.height / 2) + (multRand58(2) * canvas58.height * 0.5 * randSign());
      
      let ratioX = x / canvas58.width;
      let ratioY = 1 - (Math.abs(y - (canvas58.height / 2)) / (canvas58.height / 2));
      
      ctx58.fillStyle = colorFromRatio58(ratioX, hue);
      ctx58.globalAlpha = ratioY;
      
      let s = sizeFromRatio58(ratioY);
      let s2 = s / 2;
      
      ctx58.beginPath();
      ctx58.moveTo(x, y - s2);
      ctx58.lineTo(x + s2, y + s2);
      ctx58.lineTo(x - s2, y + s2);
      ctx58.lineTo(x, y - s2);
      ctx58.lineTo(x + s2, y + s2);
      
      ctx58.fill();
      ctx58.stroke();
    }
  }
  
  function drawRandCircle58(_x, hue) {
    let x = _x + (multRand58(3) * canvas58.width * 0.5 * randSign());
    let y = (canvas58.height / 2) + (multRand58(2) * canvas58.height * 0.5 * randSign());
    
    let ratioX = x / canvas58.width;
    let ratioY = 1 - (Math.abs(y - (canvas58.height / 2)) / (canvas58.height / 2));
    
    ctx58.fillStyle = colorFromRatio58(ratioX, hue);
    ctx58.globalAlpha = ratioY;
    
    let s = sizeFromRatio58(ratioY);
    let s2 = s / 2;
    
    ctx58.fillCircle(x, y, s2);
    ctx58.strokeCircle(x, y, s2);
  }
  
  function draw58() {
    ctx58.fillStyle = "white";
    ctx58.globalAlpha = 1;
    ctx58.fillRect(0, 0, canvas58.width, canvas58.height);
    
    ctx58.strokeStyle = "black";
    ctx58.lineWidth = 1;
    
    for (let i = 0; i < 5000; i++) {
      drawRandSquare58(0, 0);
      drawRandCircle58(canvas58.width * 0.25, 60);
      
      drawRandTriangle58(canvas58.width * 0.5, 30);
      
      drawRandSquare58(canvas58.width * 0.75, 120);
      drawRandCircle58(canvas58.width, 90);
    }
  }
  draw58();
</script>
<canvas id = "canvas57" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas57(this)">Start</button>
<button onclick = "reset57()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps57Txt"></span></b></i></div>
<div class = "desc"><b><i>(2/7/2022)</i></b> (Click to add "flowers") I'm honestly not sure what this is...I was going for some interesting interactive generative art and ended up with a weird "flower"-like thing. I'm not sure how I feel about this one, but I don't like deleting work so it's gonna stay here.</div>
<hr><hr>
<script>
  const ctx57 = canvas57.getContext("2d");
  canvas57.width = canvas57.height = 1000;
  let canvas57Running = false;
  let canvas57Rect = canvas57.getBoundingClientRect();
  let canvas57Ratio = canvas57.width / 500;
  
  let startGrid57DotSize = 0;
  let maxGrid57DotSize = 30;
  let maxGrid57VisualDotSize = 15;
  let grid57DotGrowRate = 0.5;
  let stepsPerFrame57 = 4;
  let grid57DotOpacity = 0.05;
  
  function Grid57(x, y, gridSize) {
    this.x = x;
    this.y = y;
    this.gridSize = gridSize;
    this.dotSize = startGrid57DotSize;
    
    this.dead = false;
    
    this.color = `hsl(${Math.random() * 360}deg, 100%, 30%)`;
    
    this.dotSizeRatio = randBetween(0.75, 1.25);
  }
  Grid57.prototype.update = function() {
    this.dotSize += grid57DotGrowRate;
    if (this.dotSize >= maxGrid57DotSize) this.dead = true;
  };
  Grid57.prototype.draw = function() {
    if (this.dead) return;
    
    ctx57.globalAlpha = grid57DotOpacity;
    ctx57.fillStyle = this.color;
    
    for (let x = 0; x < this.gridSize; x++) {
      for (let y = 0; y < this.gridSize; y++) {
        let _x = this.x + ((x - (this.gridSize / 2) + 0.5) * this.dotSize);
        let _y = this.y + ((y - (this.gridSize / 2) + 0.5) * this.dotSize);
        
        let s = Math.min(this.dotSize * 0.4, maxGrid57VisualDotSize) * this.dotSizeRatio * 1.5;
        
        //ctx57.fillCircle(_x, _y, s);
        ctx57.fillRectFromCenter(_x, _y, s, s);
      }
    }
    
    ctx57.globalAlpha = 1;
  };
  let grid57Array = [];
  
  let lastFrame57Time = 0;
  let lastFps57DisplayTime = 1000;
  function frame57() {
    if (Date.now() - lastFps57DisplayTime >= 500) {
      fps57Txt.innerHTML = (1000 / (Date.now() - lastFrame57Time)).toFixed(1);
      lastFps57DisplayTime = Date.now();
    }
    lastFrame57Time = Date.now();
    
    for (let i = 0; i < grid57Array.length; i++) {
      for (let j = 0; j < stepsPerFrame57; j++) {
        grid57Array[i].update();
        grid57Array[i].draw();
      }
      
      if (grid57Array[i].dead) {
        grid57Array.splice(i, 1);
        i--;
      }
    }
    
    if (canvas57Running) requestAnimationFrame(frame57);
  }
  
  function reset57() {
    let hue = Math.random() * 360;
    ctx57.fillStyle = `hsl(${hue}deg, 60%, 80%)`;
    ctx57.fillRect(0, 0, canvas57.width, canvas57.height);
    ctx57.lineWidth = 10;
    
    let gridSize = Math.round(randBetween(5, 10));
    let tileSize = canvas57.width / gridSize;
    
    for (let x = 0; x < gridSize; x++) {
      ctx57.strokeStyle = `hsla(${hue + 180 + randBetween(-15, 15)}deg, 100%, 50%, 0.2)`;
      
      let o = randBetween(-0.2, 0.2);
      
      ctx57.beginPath();
      ctx57.moveTo((x + o) * tileSize, 0);
      o = randBetween(-0.2, 0.2);
      ctx57.lineTo((x + o) * tileSize, canvas57.height);
      ctx57.stroke();
    }
    for (let y = 0; y < gridSize; y++) {
      ctx57.strokeStyle = `hsla(${hue + 180 + randBetween(-15, 15)}deg, 100%, 50%, 0.2)`;
      
      let o = randBetween(-0.2, 0.2);
      
      ctx57.beginPath();
      ctx57.moveTo(0, (y + o) * tileSize);
      o = randBetween(-0.2, 0.2);
      ctx57.lineTo(canvas57.width, (y + o) * tileSize);
      ctx57.stroke();
    }
    
    grid57Array = [];
    
    if (!canvas57Running) frame57();
  }
  reset57();
  
  function startCanvas57(caller) {
    if (canvas57Running) {
      canvas57Running = false;
      caller.innerHTML = "Start";
    }
    else {
      canvas57Running = true;
      caller.innerHTML = "Stop";
      frame57();
    }
  }
  
  canvas57.addEventListener("mousedown", e => {
    if (!canvas57Running) return;
    
    e.preventDefault();
    canvas57Rect = canvas57.getBoundingClientRect();
    
    let mouseX = (e.clientX - canvas57Rect.left) * canvas57Ratio;
    let mouseY = (e.clientY - canvas57Rect.top) * canvas57Ratio;
    
    grid57Array.push(new Grid57(mouseX, mouseY, Math.round(randBetween(2, 6))));
  });
</script>
<canvas id = "canvas56" style = "width: 500px; height: 500px"></canvas>
<button onclick = "reset56()">Reset</button>
<button onclick = "switchMode56()" id = "mode56Btn">Current Mode: Human vs. Computer</button>
<div class = "desc"><b><i>(2/5/2022)</i></b> Simple Tic-Tac-Toe game, currently only works for 2 human players and has no ending. I want to add an AI algorithm for playing against a human, as well as sensing when the game is over and who won.<br><b><i>Update: (Later that day)</i></b> Added an AI that currently just places an O in a random spot, as well as tracking for when the board is full (but not if a line is made, which should also end the game).<br><b><i>(2/7/2022)</i></b> Added a button to switch between 2 player and 1 player. Eventually I want to add AI to the computer using <a href = "https://www.youtube.com/watch?v=trKjYdBASyQ" target = "_blank">this</a> Coding Train tutorial, but for now the computer just plays randomly.</div>
<hr><hr>
<script>
  const ctx56 = canvas56.getContext("2d");
  canvas56.width = canvas56.height = 1000;
  let canvas56Running = false;
  let canvas56Rect = canvas56.getBoundingClientRect();
  let canvas56Ratio = canvas56.width / 500;
  
  let padding56 = 150;
  let gridSize56 = 3;
  let tileSize56 = (canvas56.width - (padding56 * 2)) / gridSize56;
  let pieceSizeRatio56 = 0.5;
  let currTurn56 = "X";
  let twoPlayer56 = false;
  let computerTimeout56;
  let gameOver56 = false;
  
  let grid56 = [];
  
  function drawGrid56() {
    ctx56.clearRect(0, 0, canvas56.width, canvas56.height);
    
    gameOver56 = !openSpots56();
    
    ctx56.strokeStyle = "black";
    ctx56.lineWidth = tileSize56 * 0.04;
    ctx56.lineCap = ctx56.lineJoin = "round";
    
    ctx56.beginPath();
    
    // Vertical lines
    for (let i = 1; i < gridSize56; i++) {
      ctx56.moveTo(padding56 + (i * tileSize56), padding56);
      ctx56.lineTo(padding56 + (i * tileSize56), canvas56.height - padding56);
    }
    
    // Horizontal lines
    for (let i = 1; i < gridSize56; i++) {
      ctx56.moveTo(padding56, padding56 + (i * tileSize56));
      ctx56.lineTo(canvas56.width - padding56, padding56 + (i * tileSize56));
    }
    
    ctx56.stroke();
    
    ctx56.lineWidth = tileSize56 * 0.06;
    
    for (let x = 0; x < gridSize56; x++) {
      for (let y = 0; y < gridSize56; y++) {
        let P = gridToCanvas56(x, y);
        let piece = grid56[x][y];
        if (piece === "X") {
          ctx56.strokeStyle = "red";
          drawX56(P.x, P.y, tileSize56 * pieceSizeRatio56);
        }
        else if (piece === "O") {
          ctx56.strokeStyle = "blue";
          ctx56.strokeCircle(P.x, P.y, tileSize56 * pieceSizeRatio56 * 0.5);
        }
      }
    }
    
    if (!gameOver56) {
      ctx56.fillStyle = "black";
      ctx56.font = "bold 40px verdana";
      ctx56.textBaseline = "top";
      ctx56.fillText("Playing:", 40, 40);
      
      ctx56.lineWidth = 5;
      if (currTurn56 === "X") {
        ctx56.strokeStyle = "red";
        drawX56(265, 60, 40);
      }
      else {
        ctx56.strokeStyle = "blue";
        ctx56.strokeCircle(265, 60, 20);
      }
      
      ctx56.font = "bold 30px verdana";
      let txt = "";
      if (twoPlayer56) {
        txt = currTurn56 === "X" ? "Player 1" : "Player 2";
      }
      else {
        txt = currTurn56 === "X" ? "Player" : "Computer";
      }
      ctx56.fillText(txt, 300, 46);
      
      ctx56.lineWidth = 50;
      ctx56.fillStyle = currTurn56 === "X" ? "red" : "blue";
      ctx56.globalAlpha = 0.75;
      ctx56.strokeRect(0, 0, canvas56.width, canvas56.height);
      ctx56.globalAlpha = 1;
    }
  }
  
  function drawX56(x, y, size) {
    let s2 = size / 2;
    
    ctx56.beginPath();
    
    ctx56.moveTo(x - s2, y - s2);
    ctx56.lineTo(x + s2, y + s2);
    ctx56.moveTo(x - s2, y + s2);
    ctx56.lineTo(x + s2, y - s2);
    
    ctx56.stroke();
  }
  
  function openSpots56() {
    let playable = false;
    for (let x = 0; x < gridSize56; x++) {
      for (let y = 0; y < gridSize56; y++) {
        if (grid56[x][y] === "") playable = true;
      }
    }
    return playable;
  }
  
  function playComputer56() {
    if (!openSpots56()) {
      gameOver56 = true;
      drawGrid56();
      return;
    }
    
    let x = Math.floor(Math.random() * gridSize56);
    let y = Math.floor(Math.random() * gridSize56);
    while (grid56[x][y] !== "") {
      x = Math.floor(Math.random() * gridSize56);
      y = Math.floor(Math.random() * gridSize56);
    }
    computerTimeout56 = setTimeout(() => {
      grid56[x][y] = "O";
      currTurn56 = "X";
      drawGrid56();
    }, 1000);
  }
  
  function reset56() {
    currTurn56 = Math.random() < 0.5 ? "X" : "O";
    
    window.clearTimeout(computerTimeout56);
    
    gameOver56 = false;
    
    tileSize56 = (canvas56.width - (padding56 * 2)) / gridSize56;
    
    grid56 = [];
    for (let x = 0; x < gridSize56; x++) {
      let row = [];
      for (let y = 0; y < gridSize56; y++) {
        row.push("");
      }
      grid56.push(row);
    }
    
    if (!twoPlayer56 && currTurn56 === "O") playComputer56();
    
    drawGrid56();
  }
  reset56();
  
  function gridToCanvas56(x, y) {
    return {x: ((x + 0.5) * tileSize56) + padding56, y: ((y + 0.5) * tileSize56) + padding56};
  }
  
  function switchMode56() {
    if (twoPlayer56) {
      twoPlayer56 = false;
      mode56Btn.innerHTML = "Current Mode: Human vs. Computer";
    }
    else {
      twoPlayer56 = true;
      mode56Btn.innerHTML = "Current Mode: Human vs. Human";
    }
    
    reset56();
  }
  
  canvas56.addEventListener("mousedown", e => {
    canvas56Rect = canvas56.getBoundingClientRect();
    
    let mouseX = (e.clientX - canvas56Rect.left) * canvas56Ratio;
    let mouseY = (e.clientY - canvas56Rect.top) * canvas56Ratio;
    
    for (let x = 0; x < gridSize56; x++) {
      for (let y = 0; y < gridSize56; y++) {
        if (grid56[x][y] === "") {
          let tileX = (x * tileSize56) + padding56;
          let tileY = (y * tileSize56) + padding56;
          let xAligned = mouseX >= tileX && mouseX < tileX + tileSize56;
          let yAligned = mouseY >= tileY && mouseY < tileY + tileSize56;
          if (xAligned && yAligned) {
            grid56[x][y] = currTurn56;
            currTurn56 = currTurn56 === "X" ? "O" : "X";
            if (!twoPlayer56 && currTurn56 === "O") playComputer56();
            drawGrid56();
          }
        }
      }
    }
  });
</script>
<canvas id = "canvas55" style = "width: 500px; height: 500px"></canvas>
<button onclick = "reset55()">Regenerate</button>
<button onclick = "test55()">Many</button>
<br>
<input type = "checkbox" id = "rainbow55Checkbox" oninput = "rainbow55 = this.checked">
<label for = "rainbow55Checkbox">Rainbow</label>
<div class = "desc"><b><i>(2/2/2022)</i></b> Started following <a href = "https://www.youtube.com/playlist?list=PLyRZnpOSgMj3K8AV2I6UldnvTj6d_Zrf0" target = "_blank">this</a> generative art tutorial for random crystals by Matthew Epler.<br><b><i>(2/3/2022)</i></b> I finished the tutorial, this time I didn't change very much about how it works (my code is completely different, but the output is basically the same), except making some layers more transparent so it gets less crowded. I also added a setting for rainbow colors instead of the default blue/pink palette.</div>
<hr><hr>
<script>
  const ctx55 = canvas55.getContext("2d");
  canvas55.width = canvas55.height = 2000;
  
  const twoRoot3Minus3 = (Math.sqrt(3) * 2) - 3;
  const twoOverRoot3 = 2 / Math.sqrt(3);
  let fillOpacity55 = 0.5;
  let rainbow55 = false;
  
  let colors55 = [
    "rgb(255, 52, 154)", // pink
    "rgb(4, 0, 152)" // blue
  ];
  function randColor55() {
    if (rainbow55) return `rgb(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`;
    else return colors55[Math.floor(Math.random() * colors55.length)];
  }
  function randWeight55(size) {
    return size * randBetween(0.25, 1);//randBetween(2, 4);
  }
  
  function strokeHexagon55(x, y, radius, offsetAngle) {
    ctx55.beginPath();
    for (let i = 0; i < 8; i++) { // Wrap around 2 extra edges to complete the path and make a clean edge
      let a = ((i / 6) * Math.PI * 2) + offsetAngle;
      ctx55.lineTo(x + (radius * Math.cos(a)), y + (radius * Math.sin(a)));
    }
    ctx55.stroke();
  }
  function fillHexagon55(x, y, radius, offsetAngle) {
    ctx55.beginPath();
    for (let i = 0; i < 8; i++) { // Wrap around 2 extra edges to complete the path and make a clean edge
      let a = ((i / 6) * Math.PI * 2) + offsetAngle;
      ctx55.lineTo(x + (radius * Math.cos(a)), y + (radius * Math.sin(a)));
    }
    ctx55.fill();
  }
  
  let layerChanceArray55 = [
    0.7, // Shape outline
    0.8, // Solid lines
    0.7, // Circles
    0.8, // Dotted lines
    0.8, // Centered shape
    0.7, // Ring of shapes
    0.3 // Stepped hexagons
  ];
  
  function drawCrystal55(x, y, radius, accentSize) {
    let allLayers = [1, 2, 3, 4, 5, 6, 7];
    let layers = [];
    
    for (let i = 0; i < allLayers.length; i++) {
      if (Math.random() < layerChanceArray55[i]) layers.push(i + 1);
    }
    if (layers.length === 0) layers.push(allLayers[Math.floor(Math.random() * allLayers.length)]);
    
    /*let numLayers = Math.round(randBetween(2, allLayers.length));
    for (let i = 0; i < numLayers; i++) {
      let j = Math.floor(Math.random() * allLayers.length);
      layers.push(allLayers[j]);
      allLayers.splice(j, 1);
    }*/
    //layers = [7];
    
    ctx55.lineCap = ctx55.lineJoin = "round";
    
    let symmetry = Math.random() < 0.5 ? 6 : 12;
    let numSteps = Math.random() < 0.5 ? 8 : 10; // 8 or 10 steps
    let stepSize = radius / numSteps;
    let offsetAngle = Math.random() < 0.5 ? Math.PI / 6 : 0;
    
    //
    // LAYER 5: Centered shape
    //
    
    if (layers.includes(5)) {
      ctx55.fillStyle = randColor55();
      ctx55.globalAlpha = fillOpacity55;
      
      let shapeRadius = Math.round(randBetween(1, numSteps)) * stepSize;
      let shapeType = Math.floor(Math.random() * 3);
      if (shapeType === 0) { // Square
        ctx55.fillRectFromCenter(x, y, shapeRadius * Math.SQRT2, shapeRadius * Math.SQRT2);
      }
      else if (shapeType === 1) { // Circle
        ctx55.fillCircle(x, y, shapeRadius);
      }
      else if (shapeType === 2) { // Hexagon
        fillHexagon55(x, y, shapeRadius, offsetAngle);
      }
      
      ctx55.globalAlpha = 1;
    }
    
    //
    // LAYER 6: Ring of shapes
    //
    
    if (layers.includes(6)) {
      ctx55.fillStyle = ctx55.strokeStyle = randColor55();
      ctx55.lineWidth = randWeight55(accentSize);
      let willFill = Math.random() < 0.5;
      
      let distOut = Math.floor(randBetween(1, numSteps));
      let shapeType = Math.floor(Math.random() * 3);
      let shapeDiameter = 0;
      let backwards = Math.random() < 0.5;
      
      if (distOut < numSteps / 2) shapeDiameter = Math.floor(randBetween(1, distOut)) * stepSize;
      else if (distOut > numSteps / 2) shapeDiameter = Math.floor(randBetween(1, numSteps - distOut)) * stepSize;
      else shapeDiameter = Math.floor(randBetween(1, (numSteps / 2) + 1)) * stepSize;
      
      let shapeRadius = shapeDiameter / 2;
      
      for (let i = 0; i < 6; i++) {
        let a = (i / 6) * Math.PI * 2
        
        if (shapeType === 0) { // Circle
          ctx55.beginPath();
          ctx55.arc(x + (distOut * stepSize * Math.cos(a)), y + (distOut * stepSize * Math.sin(a)), shapeRadius, 0, Math.PI * 2);
        }
        
        else if (shapeType === 1) { // Square
          let rectRadius = shapeRadius * Math.SQRT1_2;
          let rectDiameter = shapeDiameter * Math.SQRT1_2;
          
          let edge = (distOut * stepSize) - rectRadius;
          let cx = x + (edge * Math.cos(a));
          let cy = y + (edge * Math.sin(a));
          let ca = a;
          
          ctx55.beginPath();
          ctx55.moveTo(cx, cy);
          
          ca += Math.PI / 2;
          cx += rectRadius * Math.cos(ca);
          cy += rectRadius * Math.sin(ca);
          ctx55.lineTo(cx, cy);
          
          for (let j = 0; j < 3; j++) {
            ca -= Math.PI / 2;
            cx += rectDiameter * Math.cos(ca);
            cy += rectDiameter * Math.sin(ca);
            ctx55.lineTo(cx, cy);
          }
          
          ca -= Math.PI / 2;
          cx += rectRadius * Math.cos(ca);
          cy += rectRadius * Math.sin(ca);
          ctx55.lineTo(cx, cy);
        }
        
        else if (shapeType === 2) { // Triangle
          let edge = (distOut * stepSize) - shapeRadius;
          if (backwards) edge += shapeDiameter * twoOverRoot3;
          let cx = x + (edge * Math.cos(a));
          let cy = y + (edge * Math.sin(a));
          let ca = a;
          if (backwards) ca += Math.PI;
          
          ctx55.beginPath();
          ctx55.moveTo(cx, cy);
          
          ca += Math.PI / 6;
          cx += shapeDiameter * Math.cos(ca);
          cy += shapeDiameter * Math.sin(ca);
          ctx55.lineTo(cx, cy);
          
          for (let i = 0; i < 2; i++) {
            ca -= Math.PI * (2 / 3);
            cx += shapeDiameter * Math.cos(ca);
            cy += shapeDiameter * Math.sin(ca);
            ctx55.lineTo(cx, cy);
          }
        }
        
        if (willFill) {
          ctx55.globalAlpha = fillOpacity55;
          ctx55.fill();
          ctx55.globalAlpha = 1;
        }
        else ctx55.stroke();
      }
    }
    
    //
    // LAYER 7: Stepped hexagons
    //
    
    if (layers.includes(7)) {
      ctx55.strokeStyle = randColor55();
      ctx55.lineWidth = randWeight55(accentSize)
      
      let center = Math.round(randBetween(1, 3));
      for (let i = center; i < numSteps; i++) {
        strokeHexagon55(x, y, i * stepSize, offsetAngle);
      }
    }
    
    //
    // LAYER 1: Shape outline
    //
    
    if (layers.includes(1)) {
      ctx55.strokeStyle = randColor55();
      ctx55.lineWidth = randWeight55(accentSize);
      
      let isHexagon = Math.random() < 0.5;
      
      if (isHexagon) strokeHexagon55(x, y, radius, offsetAngle);
      else ctx55.strokeCircle(x, y, radius);
    }
    
    //
    // LAYER 2: Solid lines
    //
    
    if (layers.includes(2)) {
      ctx55.strokeStyle = randColor55();
      ctx55.lineWidth = randWeight55(accentSize);
      let lineStart = Math.round(randBetween(0, numSteps - 1));
      let lineEnd = Math.round(randBetween(lineStart + 1, numSteps));
      lineStart *= stepSize;
      lineEnd *= stepSize;
      
      for (let i = 0; i < symmetry; i++) {
        let a = (i / symmetry) * Math.PI * 2;
        ctx55.beginPath();
        ctx55.moveTo(x + (lineStart * Math.cos(a)), y + (lineStart * Math.sin(a)));
        ctx55.lineTo(x + (lineEnd * Math.cos(a)), y + (lineEnd * Math.sin(a)));
        ctx55.stroke();
      }
    }
    
    //
    // LAYER 3: Circles
    //
    
    if (layers.includes(3)) {
      ctx55.strokeStyle = randColor55();
      ctx55.lineWidth = randWeight55(accentSize);
      
      let touchAdjacent = Math.random() < 0.5;
      let ratio = touchAdjacent ? 1 / 3 : twoRoot3Minus3;
      let circleRadius = radius * ratio;
      let circlePosition = radius - circleRadius;
      for (let i = 0; i < 6; i++) {
        let a = (i / 6) * Math.PI * 2;
        ctx55.strokeCircle(x + (circlePosition * Math.cos(a)), y + (circlePosition * Math.sin(a)), circleRadius);
      }
    }
    
    //
    // LAYER 4: Dotted lines
    //
    
    if (layers.includes(4)) {
      ctx55.fillStyle = randColor55();
      
      for (let i = 0; i < symmetry; i++) {
        let a = (i / symmetry) * Math.PI * 2;
        for (let j = 1; j < numSteps; j++) {
          ctx55.fillCircle(x + (j * stepSize * Math.cos(a)), y + (j * stepSize * Math.sin(a)), accentSize);
        }
      }
    }
  }
  
  function reset55() {
    ctx55.clearRect(0, 0, canvas55.width, canvas55.height);
    
    drawCrystal55(canvas55.width / 2, canvas55.height / 2, (canvas55.width / 2) - 100, 10);
  }
  reset55();
  
  function test55() {
    ctx55.clearRect(0, 0, canvas55.width, canvas55.height);
    
    let gridSize = 6;
    let tileSize = canvas55.width / gridSize;
    for (let x = 0; x < gridSize; x++) {
      for (let y = 0; y < gridSize; y++) {
        drawCrystal55((x + 0.5) * tileSize, (y + 0.5) * tileSize, tileSize * 0.45, 4);
      }
    }
  }
</script>
<canvas id = "canvas54"></canvas>
<button onclick = "Turtle54.move()">Draw More</button>
<div><b><u>d&theta;:</u></b> <span id = "turtle54TurnStepTxt">1.01</span>&deg;</div>
<br>
<button onclick = "Turtle54.turnStep = Number((Turtle54.turnStep + 0.1).toFixed(6)); reset54()">+0.1&deg;</button>
<button onclick = "Turtle54.turnStep = Number((Turtle54.turnStep - 0.1).toFixed(6)); reset54()">-0.1&deg;</button>
<br><br>
<button onclick = "Turtle54.turnStep = Number((Turtle54.turnStep + 0.001).toFixed(6)); reset54()">+0.001&deg;</button>
<button onclick = "Turtle54.turnStep = Number((Turtle54.turnStep - 0.001).toFixed(6)); reset54()">-0.001&deg;</button>
<br><br>
<button onclick = "Turtle54.turnStep = Number((Turtle54.turnStep + 0.000001).toFixed(6)); reset54()">+0.000001&deg;</button>
<button onclick = "Turtle54.turnStep = Number((Turtle54.turnStep - 0.000001).toFixed(6)); reset54()">-0.000001&deg;</button>
<br><br>
<button onclick = "Turtle54.turnStep = 1; reset54()">Reset to 1&deg;</button>
<div class = "desc"><b><i>(2/1/2022)</i></b> Turtle graphics plotting Euler spirals, inspired by <a href = "https://www.youtube.com/watch?v=kMBj2fp52tA" target = "_blank">this</a> Numberphile video, with added buttons to change d&theta;, showing how sensitive the pattern is to intial conditions. Basically the turtle starts out moves forward and turns <b>d&theta;&deg;</b>, then moves and turns 2<b>d&theta;&deg;</b>, and then moves and turns 3<b>d&theta;&deg;</b>, and then 4<b>d&theta;&deg;</b>, and so on. By changing <b>d&theta;&deg;</b>, even by an incredibly small amount, it greatly changes the complexity of the resulting designs.</div>
<hr><hr>
<script>
  const ctx54 = canvas54.getContext("2d");
  canvas54.width = canvas54.height = 1000;
  
  let Turtle54 = {
    x: canvas54.width / 2,
    y: canvas54.height / 2,
    angle: 0,
    turnStep: 1.01,
    currMult: 1,
    iterations: 100000,
    stepSize: 2
  };
  Turtle54.move = function() {
    ctx54.beginPath();
    ctx54.moveTo(this.x, this.y);
    
    for (let i = 0; i < this.iterations; i++) {
      this.x += this.stepSize * Math.cos(this.angle);
      this.y += this.stepSize * Math.sin(this.angle);
      
      ctx54.lineTo(this.x, this.y);
      
      this.angle += this.currMult * toRad(this.turnStep);
      this.currMult++;
    }
    
    ctx54.stroke();
  };
  
  function reset54() {
    ctx54.clearRect(0, 0, canvas54.width, canvas54.height);
    
    Turtle54.x = canvas54.width / 2;
    Turtle54.y = canvas54.height / 2;
    Turtle54.angle = 0;
    Turtle54.currMult = 1;
    
    turtle54TurnStepTxt.innerHTML = Turtle54.turnStep;
    
    Turtle54.move();
  }
  reset54();
</script>
<canvas id = "canvas53"></canvas>
<button onclick = "draw53()">Regenerate</button>
<div class = "desc"><b><i>(2/1/2022)</i></b> More generative art, this time inspired by <a href = "https://tylerxhobbs.com/works/2018/fragments-of-vision-b" target = "_blank">this</a> artwork by Tyler Hobbs. There's lots of paramaters like brightness variation, saturation, etc. that are randomized every generation so that every time it looks similar but distinct.</div>
<hr><hr>
<script>
  const ctx53 = canvas53.getContext("2d");
  canvas53.width = canvas53.height = 1000;
  
  let columns53 = 10;
  let rows53 = 100;
  let drawChance53 = 0.5;
  let brightness53 = 50;
  let brightnessVariation53 = 1;
  let outline53 = false;
  let saturation53 = 50;
  let hueVariation53 = 0.1;
  let whiteLines53 = true;
  
  function drawDiamond53(x, y, size, color, outline) {
    ctx53.fillStyle = color;
    
    ctx53.lineWidth = 1;
    ctx53.strokeStyle = "black";
    
    let half = size / 2;
    
    ctx53.beginPath();
    ctx53.moveTo(x, y);
    ctx53.lineTo(x + half, y + half);
    ctx53.lineTo(x + size, y);
    ctx53.lineTo(x + half, y - half);
    ctx53.lineTo(x, y);
    
    ctx53.fill();
    if (outline) ctx53.stroke();
  }
  
  function draw53() {
    ctx53.fillStyle = "white";
    ctx53.fillRect(0, 0, canvas53.width, canvas53.height);
    
    columns53 = Math.round(randBetween(2, 16));
    rows53 = Math.random() < 0.5 ? Math.round(randBetween(25, 50)) : Math.round(randBetween(100, 200));
    
    let arr = [0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1];
    drawChance53 = arr[Math.floor(Math.random() * arr.length)];
    
    brightness53 = Math.round(randBetween(0, 10)) * 10;
    
    outline53 = Math.random() < 0.25;
    
    brightnessVariation53 = Math.random();
    
    saturation53 = randBetween(0, 100);
    
    hueVariation53 = Math.random() * Math.random();
    
    
    
    let scaleX = canvas53.width / columns53;
    let scaleY = canvas53.height / rows53;
    let offsetY = Math.ceil(scaleX / scaleY);
    
    for (let x = 0; x < columns53; x++) {
      let hue = Math.random() * 360;
      let vHue = randSign() * (randBetween(90, 360) / rows53);
      
      for (let y = -offsetY; y < rows53 + offsetY; y++) {
        let _y1 = y * scaleY;
        let _y2 = x % 2 === 0 ? _y1 : canvas53.height - _y1;
        
        let brightness = 0;
        if (Math.random() < 0.5) brightness = randBetween(brightness53, ((100 - brightness53) * brightnessVariation53) + brightness53);
        else brightness = randBetween(brightness53, brightness53 * (1 - brightnessVariation53));
        
        if (Math.random() < drawChance53) drawDiamond53(x * scaleX, _y2, scaleX, `hsl(${hue + randBetween(-180 * hueVariation53, 180 * hueVariation53)}deg, ${randBetween(saturation53, 100)}%, ${brightness}%)`, outline53);
        
        hue += vHue;
      }
    }
    
    if (whiteLines53) {
      for (let x = 0; x <= columns53; x++) {
        let _x = x * scaleX;
        ctx53.lineWidth = scaleY;
        ctx53.strokeStyle = "white";
        
        ctx53.beginPath();
        ctx53.moveTo(_x, 0);
        ctx53.lineTo(_x, canvas53.height);
        ctx53.stroke();
      }
    }
  }
  draw53();
</script>
<canvas id = "canvas52"></canvas>
<button onclick = "startCanvas52(this)">Start</button>
<button onclick = "reset52()">Reset</button>
<br>
<div><b><u>Mode:</u></b></div>
<button onclick = "mode52 = 1; reset52()">1</button>
<button onclick = "mode52 = 2; reset52()">2</button>
<button onclick = "mode52 = 3; reset52()">3</button>
<button onclick = "mode52 = 4; reset52()">4</button>
<button onclick = "mode52 = 5; reset52()">5</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps52Txt"></span></b></i></div>
<div class = "desc"><b><i>(1/31/2022)</i></b> More generative art experimenting, with selectable modes for several different artworks, all based on a similar particle system that moves arounds and shrinks, leaving colored trails behind.<br><b><i>(2/1/2021)</i></b> Added more modes.</div>
<hr><hr>
<script>
  const ctx52 = canvas52.getContext("2d");
  canvas52.width = canvas52.height = 1000;
  let canvas52Running = false;
  
  let mode52 = 1;
  
  let spawnRadius52 = 300;
  let fallRate52 = 4;
  let shrinkRate52 = 0.1;
  let particle52Radius = 10;
  let t52 = 0;
  let period52 = 400;
  let wiggle52 = 2;
  let slideSpeed52 = 15;
  
  function Particle52() {
    if (mode52 === 1) {
      let a = Math.random() * Math.PI * 2;
      let r = spawnRadius52 + randBetween(-10, 10);
      this.x = (canvas52.width / 2) + (r * Math.cos(a));
      this.y = (canvas52.height / 3) + (r * Math.sin(a));
      
      if (Math.random() < 0.03) {
        this.x = Math.random() * canvas52.width;
        this.y = Math.random() * canvas52.height;
      }
      
      this.radius = particle52Radius * randBetween(0.75, 1);
      this.color = `hsla(${t52 * 720}deg, ${randBetween(80, 100)}%, ${randBetween(30, 50)}%, 0.25)`;
      
      this.done = false;
      
      this.fallRate = randBetween(0.75, 1) * fallRate52;
      this.shrinkRate = randBetween(0.75, 1) * shrinkRate52;
    }
    
    else if (mode52 === 2) {
      let a = Math.random() * Math.PI * 2;
      let r = spawnRadius52 + 50;
      this.x = (canvas52.width / 2) + (r * Math.cos(a));
      this.y = (canvas52.height / 2) + (r * Math.sin(a));
      
      this.color = `hsla(${120 + randBetween(-60, 60)}deg, 100%, ${randBetween(30, 50)}%, 0.25)`;
      this.done = false;
      
      this.radius = particle52Radius * randBetween(0.75, 1);
      
      this.shrinkRate = randBetween(0.75, 1) * shrinkRate52;
      
      this.slideSpeed = slideSpeed52 * randBetween(0.75, 1);
    }
    
    else if (mode52 === 3) {
      this.angle = Math.random() * Math.PI * 2;
      let r = spawnRadius52 + 25 + randBetween(-10, 10);
      this.x = (canvas52.width / 2) + (r * Math.cos(this.angle));
      this.y = (canvas52.height / 2) + (r * Math.sin(this.angle));
      this.done = false;
      
      this.radius = particle52Radius * randBetween(0.75, 1);
      
      this.shrinkRate = randBetween(0.75, 1) * shrinkRate52;
      
      this.slideSpeed = slideSpeed52 * randBetween(0.15, 0.33) * randSign();
      
      let hue = this.slideSpeed < 1 ? randBetween(-30, 30) : 240 + randBetween(-30, 30);
      let brightness = this.slideSpeed < 1 ? randBetween(30, 50) : randBetween(50, 80);
      this.color = `hsla(${hue}deg, ${randBetween(80, 100)}%, ${brightness}%, 0.25)`;
    }
    
    else if (mode52 === 4) {
      this.angle = Math.random() * Math.PI * 2;
      let r = spawnRadius52 + 50;
      this.x = (canvas52.width / 2) + (r * Math.cos(this.angle));
      this.y = (canvas52.height / 2) + (r * Math.sin(this.angle));
      
      this.angle += toRad(120);//randBetween(-10, 10));
      
      this.done = false;
      
      this.radius = particle52Radius * randBetween(0.75, 1);
      
      this.shrinkRate = randBetween(0.75, 1) * shrinkRate52;
      
      this.slideSpeed = slideSpeed52 * randBetween(0.75, 1) * 2;
      this.color = `hsla(${t52 * 360}deg, ${randBetween(50, 100)}%, ${randBetween(30, 50)}%, 0.25)`;
    }
    
    else if (mode52 === 5) {
      this.done = false;
      
      this.radius = particle52Radius * randBetween(0.75, 1);
      
      this.shrinkRate = randBetween(0.75, 1) * shrinkRate52;
      
      this.slideSpeed = slideSpeed52 * randBetween(0.75, 1);
      this.dir = Math.round(Math.random());
      
      this.color = Math.random() < 0.5 ? "rgba(255, 255, 255, 0.25)" : "black";
      
      let a = Math.random() * Math.PI * 2;
      let r = spawnRadius52 + 50 + randBetween(-25, 25);//this.color === "black" ? (spawnRadius52 + 50 + randBetween(-10, 10)) : (spawnRadius52 + 50);
      this.x = (canvas52.width / 2) + (r * Math.cos(a));
      this.y = (canvas52.height / 2) + (r * Math.sin(a));
    }
  }
  Particle52.prototype.render = function() {
    if (this.done) return;
    
    if (mode52 === 1) {
      this.y += this.fallRate;
      this.x += Math.random() * randSign() * wiggle52;
      this.radius -= this.shrinkRate;
      if (this.radius <= 0) {
        this.done = true;
        return;
      }
      
      ctx52.fillStyle = this.color;
      ctx52.fillCircle(this.x, this.y, this.radius);
    }
    
    else if (mode52 === 2) {
      if (this.done) return;
      
      this.x += Math.random() * randSign() * this.slideSpeed;
      
      this.radius -= this.shrinkRate;
      if (this.radius <= 0) {
        this.done = true;
        return;
      }
      
      ctx52.fillStyle = this.color;
      ctx52.fillCircle(this.x, this.y, this.radius / 2);
    }
    
    else if (mode52 === 3) {
      if (this.done) return;
      
      let r = Math.random() * this.slideSpeed;
      this.x += r * Math.cos(this.angle);
      this.y += r * Math.sin(this.angle);
      
      this.radius -= this.shrinkRate;
      if (this.radius <= 0) {
        this.done = true;
        return;
      }
      
      ctx52.fillStyle = this.color;
      ctx52.fillCircle(this.x, this.y, this.radius / 2);
    }
    
    else if (mode52 === 4) {
      if (this.done) return;
      
      let lastX = this.x;
      let lastY = this.y;
      
      let r = Math.random() * randSign() * this.slideSpeed;
      this.x += r * Math.cos(this.angle);
      this.y += r * Math.sin(this.angle);
      
      this.radius -= this.shrinkRate;
      if (this.radius <= 0) {
        this.done = true;
        return;
      }
      
      ctx52.lineCap = ctx52.lineJoin = "round";
      ctx52.strokeStyle = this.color;
      ctx52.lineWidth = this.radius;
      ctx52.beginPath();
      ctx52.moveTo(lastX, lastY);
      ctx52.lineTo(this.x, this.y);
      ctx52.stroke();
    }
    
    else if (mode52 === 5) {
      if (this.done) return;
      
      if (this.dir === 0) this.x += Math.random() * randSign() * Math.round(randBetween(1, this.slideSpeed));
      else this.y += Math.random() * randSign() * Math.round(randBetween(1, this.slideSpeed));
      
      this.radius -= this.shrinkRate;
      if (this.radius <= 0) {
        this.done = true;
        return;
      }
      
      ctx52.fillStyle = this.color;
      ctx52.fillCircle(this.x, this.y, this.color === "black" ? 2 : 1);
    }
  };
  let particle52Array = [];
  
  let lastFrame52Time = 0;
  let lastFps52DisplayTime = 1000;
  function frame52() {
    if (Date.now() - lastFps52DisplayTime >= 500) {
      fps52Txt.innerHTML = (1000 / (Date.now() - lastFrame52Time)).toFixed(1);
      lastFps52DisplayTime = Date.now();
    }
    lastFrame52Time = Date.now();
    
    t52 += 1 / period52;
    t52 = (t52 + 1) % 1;
    
    let n = 3;
    if (mode52 === 5) n = 6;
    for (let i = 0; i < n; i++) particle52Array.push(new Particle52());
    
    for (let i = 0; i < particle52Array.length; i++) {
      particle52Array[i].render();
      
      if (particle52Array[i].done) {
      particle52Array.splice(i, 1);
        i--;
      }
    }
    
    if (canvas52Running) requestAnimationFrame(frame52);
  }
  
  function reset52() {
    ctx52.fillStyle = "black";
    ctx52.fillRect(0, 0, canvas52.width, canvas52.height);
    
    particle52Array = [];
    
    if (!canvas52Running) frame52();
  }
  reset52();
  
  function startCanvas52(caller) {
    if (canvas52Running) {
      canvas52Running = false;
      caller.innerHTML = "Start";
    }
    else {
      canvas52Running = true;
      caller.innerHTML = "Stop";
      frame52();
    }
  }
</script>
<canvas id = "canvas51" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas51(this)">Start</button>
<button onclick = "reset51()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps51Txt"></span></b></i></div>
<div class = "desc"><b><i>(1/31/2022)</i></b> Experimenting with <a href = "https://archive.lib.msu.edu/crcmath/math/math/c/c850.htm" target = "_blank">curlicue fractals</a> gave me an idea for this "galaxy" generator. Each walker is a curlicue fractal, but it's step size is randomized every 500 steps (500 steps are taken per frame). This creates interesting and intricate doodle-like designs and patterns.</div>
<hr><hr>
<script>
  const ctx51 = canvas51.getContext("2d");
  canvas51.width = canvas51.height = 2000;
  let canvas51Running = false;
  
  let stepsPerFrame51 = 500;
  let numWalkers51 = 10;
  let precision51 = 50;
  
  function Walker51(hue) {
    this.x = Math.random() * canvas51.width;
    this.y = Math.random() * canvas51.height;
    this.theta = Math.random() * Math.PI * 2;
    this.phi = Math.random() * Math.PI * 2;
    this.s = 0;
    this.sPeriod = 0;
    this.cs = 0;
    this.velocity = 0;
    this.color = `hsla(${hue}deg, 100%, ${randBetween(70, 90)}%, 0.1)`;
    this.randomize();
  }
  Walker51.prototype.randomize = function() {
    this.s = Number(Math.random().toFixed(precision51))//Math.random();
    this.sPeriod = Math.round(randBetween(0, 5));
    this.cs = 0;
    this.velocity = randBetween(0.5, 2);
  };
  Walker51.prototype.walk = function() {
    this.cs++;
    if (this.cs >= this.sPeriod) {
      this.randomize();
    }
    for (let i = 0; i < stepsPerFrame51; i++) {
      this.theta = (this.theta + (this.s * Math.PI * 2)) % (Math.PI * 2);
      this.phi = (this.phi + this.theta) % (Math.PI * 2);
      
      this.x += this.velocity * Math.cos(this.phi);
      this.y += this.velocity * Math.sin(this.phi);
      
      this.x = (this.x + canvas51.width) % canvas51.width;
      this.y = (this.y + canvas51.height) % canvas51.height;
      
      ctx51.fillStyle = this.color;
      ctx51.fillRect(this.x, this.y, 1, 1);
    }
  };
  let walker51Array = [];
  
  let lastFrame51Time = 0;
  let lastFps51DisplayTime = 1000;
  function frame51() {
    if (Date.now() - lastFps51DisplayTime >= 500) {
      fps51Txt.innerHTML = (1000 / (Date.now() - lastFrame51Time)).toFixed(1);
      lastFps51DisplayTime = Date.now();
    }
    lastFrame51Time = Date.now();
    
    for (let i = 0; i < walker51Array.length; i++) walker51Array[i].walk();
    
    if (canvas51Running) requestAnimationFrame(frame51);
  }
  
  function reset51() {
    ctx51.fillStyle = "black";
    ctx51.fillRect(0, 0, canvas51.width, canvas51.height);
    
    walker51Array = [];
    for (let i = 0; i < numWalkers51; i++) walker51Array.push(new Walker51((i / numWalkers51) * 360));
    
    if (!canvas51Running) frame51();
  }
  reset51();
  
  function startCanvas51(caller) {
    if (canvas51Running) {
      canvas51Running = false;
      caller.innerHTML = "Start";
    }
    else {
      canvas51Running = true;
      caller.innerHTML = "Stop";
      frame51();
    }
  }
</script>
<canvas id = "canvas50"></canvas>
<button onclick = "startCanvas50(this)">Start</button>
<button onclick = "reset50()">Reset</button>
<button onclick = "trailing50 = !trailing50">Toggle Trailing</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps50Txt"></span></b></i></div>
<div class = "desc"><b><i>(1/31/2022)</i></b> Inspired by <a href = "https://www.dwitter.net/d/24844" target = "_blank">this</a> Dweet, I made a simple recreation of it that turned out pretty underwhelming. I tried adding color and trailing so it's a bit more interesting but this took like 5 minutes and I'm not super proud of the end result.</div>
<hr><hr>
<script>
  const ctx50 = canvas50.getContext("2d");
  canvas50.width = canvas50.height = 1000;
  let canvas50Running = false;
  
  let numVertices50 = 25;
  let stepsPerFrame50 = 2;
  let trailing50 = true;
  
  function Vertex50(x, y, angle, velocity) {
    this.x = x;
    this.y = y;
    this.vx = velocity * Math.cos(toRad(angle));
    this.vy = velocity * Math.sin(toRad(angle));
    this.color = `rgb(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`;//color;
  }
  Vertex50.prototype.draw = function() {
    ctx50.strokeStyle = this.color;
    ctx50.lineWidth = 1;
    for (let i = 0; i < vertex50Array.length; i++) {
      if (i !== vertex50Array.indexOf(this)) {
        ctx50.beginPath();
        ctx50.moveTo(this.x, this.y);
        ctx50.lineTo(vertex50Array[i].x, vertex50Array[i].y);
        ctx50.stroke();
      }
    }
  };
  Vertex50.prototype.update = function() {
    this.x += this.vx;
    this.y += this.vy;
    
    if (this.x < 0) {
      this.x = 0;
      this.vx *= -1;
    }
    if (this.x > canvas50.width) {
      this.x = canvas50.width;
      this.vx *= -1;
    }
    if (this.y < 0) {
      this.y = 0;
      this.vy *= -1;
    }
    if (this.y > canvas50.height) {
      this.y = canvas50.height;
      this.vy *= -1;
    }
  };
  let vertex50Array = [];
  
  let lastFrame50Time = 0;
  let lastFps50DisplayTime = 1000;
  
  function frame50() {
    if (Date.now() - lastFps50DisplayTime >= 500) {
      fps50Txt.innerHTML = (1000 / (Date.now() - lastFrame50Time)).toFixed(1);
      lastFps50DisplayTime = Date.now();
    }
    lastFrame50Time = Date.now();
    
    ctx50.fillStyle = `rgba(0, 0, 0, ${trailing50 ? 0.1 : 1})`;
    ctx50.fillRect(0, 0, canvas50.width, canvas50.height);
    
    for (let i = 0; i < vertex50Array.length; i++) {
      for (let j = 0; j < stepsPerFrame50; j++) vertex50Array[i].update();
      vertex50Array[i].draw();
    }
    
    if (canvas50Running) requestAnimationFrame(frame50);
  }
  
  function reset50() {
    ctx50.fillStyle = "black";
    ctx50.fillRect(0, 0, canvas50.width, canvas50.height);
    
    vertex50Array = [];
    for (let i = 0; i < numVertices50; i++) {
      vertex50Array.push(new Vertex50(
        canvas50.width / 2,//Math.random() * canvas50.width, // x
        canvas50.height / 2,//Math.random() * canvas50.height, // y
        ((i / numVertices50) * 360) + randBetween(-10, 10), // angle
        4 // velocity
      ));
    }
    
    if (!canvas50Running) frame50();
  }
  reset50();
  
  function startCanvas50(caller) {
    if (canvas50Running) {
      canvas50Running = false;
      caller.innerHTML = "Start";
    }
    else {
      canvas50Running = true;
      caller.innerHTML = "Stop";
      frame50();
    }
  }
</script>
<canvas id = "canvas49" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas49(this)">Start</button>
<button onclick = "if (window.confirm('Are you sure you want to reset your highscore?')) {highScore49 = 0; window.localStorage.setItem('highscore', 0);}">Reset Highscore</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps49Txt"></span></b></i></div>
<div class = "desc"><b><i>(1/25/2022)</i></b> Interactive Plinko board game, click at the top to add a ball. I possibly want to add like some scoring system with different sections at the bottom but I'm not sure yet and it'll probably stay like this for awhile.<br><b><i>(1/27/2022)</i></b> I added better UI for the remaining pinballs and made a little particle cloud when a ball falls off the screen, which I'll have change based on what section it landed in, when I add them.<br><b><i>(1/29/2022)</i></b> Added some more randomness in the pegs, so that when a ball bounces off a peg, the angle and bounciness is randomized slightly.<br><b><i>(1/30/2022)</i></b> I finally added the buckets at the bottom, and made an animation for scoring along with a total score variable. There is an array of buckets that get shuffled around every reset, to guarantee a good variety of bucket values. The reason I was delaying adding buckets is that I didn't want to try to figure out how to add add physics for the bucket edges, but I decided to make the edges not have any collision and it still looks fine.<br><b><i>Update: (Later that day)</i></b> I added a game over screen so you can keep replaying the game like an arcade.<br><b><i>Update: (Even later that day)</i></b> I added three different powerups that slide across the board -- there's a pink +1 ball powerup, a yellow x2 mult powerup (which makes the ball that collects it worth twice as much when falling into a bucket), and a gray elevator powerup, which makes the ball that collects it slide straight down, so you can align with a high value bucket for more strategy. I also added game stats to the game over page.<br><b><i>(1/31/2022)</i></b> Made highscore saved in local storage, so it is retained on page reload, and slightly modified the animation when a peg is hit.</div>
<hr><hr>
<script>
  const ctx49 = canvas49.getContext("2d");
  canvas49.width = canvas49.height = 1000;
  let canvas49Running = false;
  let canvas49Ratio = canvas49.width / 500;
  let canvas49Rect = canvas49.getBoundingClientRect();
  
  let peg49Radius = 10;
  let pegRows49 = 13;
  let peg49Bounciness = 0.8;
  let ball49Color = "#f05ba8";
  let ball49Radius = 20;
  let gravity49 = 0.3;
  let glowFade49 = 0.02;
  let defaultMaxBalls49 = 5;
  let maxBalls49 = defaultMaxBalls49;
  let numBuckets49 = 10;
  let bucket49Height = 60;
  let bucket49Thickness = 5;
  let bucket49TemplateArray = [];
  let score49 = 0;
  let highScore49 = 0;
  //if (window.localStorage.getItem("highscore") !== "null") highScore49 = window.localStorage.getItem("highscore");
  //else window.localStorage.setItem("highscore", 0);
  let replenishBalls49 = false;
  let gameOver49 = false;
  let gameOver49Opacity = 0;
  let powerUp49Radius = 15;
  let numPowerUp49Array = [3, 4, 2]; // +1 Ball, x2 Mult, Elevator
  let powerUp49SlidePeriod = 800;
  let powerUp49Value = 100;
  let peg49Value = 5;
  let ball49SlideSpeed = 5;
  let stats49 = {
    pegsTouched: 0,
    extraBalls: 0,
    powerUpsCollected: 0,
    gameStartTime: 0,
    gameLength: 0
  };
  let playableY49 = 100;
  
  function Ball49(x, y) {
    this.x = x;
    this.y = y;
    
    this.vx = 0;
    this.vy = 0;
    
    this.dead = false;
    
    this.glowOpacity = 0;
    this.mult = 1;
    this.slidingDown = false;
  }
  Ball49.prototype.draw = function() {
    if (this.dead) return;
    if (this.slidingDown) { // Draw pole if sliding
      ctx49.beginPath();
      ctx49.moveTo(this.x, 0);
      ctx49.lineTo(this.x, canvas49.height);
      
      ctx49.strokeStyle = "black";
      ctx49.lineWidth = 6;
      ctx49.stroke();
      
      ctx49.strokeStyle = "hsl(0deg, 0%, 70%)";
      ctx49.lineWidth = 3;
      ctx49.stroke();
    }
    
    ctx49.fillStyle = ball49Color;
    ctx49.fillCircle(this.x, this.y, ball49Radius);
    
    if (this.mult > 1) {
      ctx49.fillStyle = "yellow";
      ctx49.globalAlpha = 0.75;
      ctx49.fillCircle(this.x, this.y, ball49Radius);
      ctx49.globalAlpha = 1;
      
      ctx49.fillStyle = "black";
      ctx49.font = "bold 20px verdana";
      ctx49.textAlign = "center";
      ctx49.textBaseline = "middle";
      if (!this.slidingDown) ctx49.fillText(`x${this.mult}`, this.x, this.y);
    }
    
    ctx49.strokeStyle = "black";
    ctx49.lineWidth = 2;
    ctx49.strokeCircle(this.x, this.y, ball49Radius);
    
    if (this.slidingDown) { // Draw down arrow if sliding
      ctx49.lineWidth = 4;
      ctx49.beginPath();
      ctx49.moveTo(this.x, this.y - (ball49Radius * 0.5));
      ctx49.lineTo(this.x, this.y + (ball49Radius * 0.5));
      ctx49.moveTo(this.x - (ball49Radius * 0.5), this.y);
      ctx49.lineTo(this.x, this.y + (ball49Radius * 0.5));
      ctx49.lineTo(this.x + (ball49Radius * 0.5), this.y);
      ctx49.stroke();
    }
  };
  Ball49.prototype.update = function() {
    if (this.dead) return;
    this.glowOpacity -= glowFade49;
    if (this.glowOpacity < 0) this.glowOpacity = 0;
    
    this.x += this.vx;
    this.y += this.vy;
    if (!this.slidingDown) this.vy += gravity49;
    else this.vy = ball49SlideSpeed;
    
    if (!this.slidingDown) { // If not sliding, check for collisions with pegs
      for (let i = 0; i < peg49Array.length; i++) {
        let dx = this.x - peg49Array[i].x;
        let dy = this.y - peg49Array[i].y;
        let distSq = (dx * dx) + (dy * dy);
        let rad = ball49Radius + peg49Radius;
        if (distSq <= rad * rad) {
          let angle = Math.atan2(dy, dx) + randBetween(-0.02, 0.02);
          let collX = Math.cos(angle);
          let collY = Math.sin(angle);
          let speed = ((this.vx * collX) + (this.vy * collY)) * 2;
          let bounciness = peg49Bounciness * randBetween(0.9, 1);
          this.vx -= bounciness * speed * collX;
          this.vy -= bounciness * speed * collY;
          let r = rad + 0.01;
          this.x = peg49Array[i].x + (r * collX);
          this.y = peg49Array[i].y + (r * collY);
          this.glowOpacity = peg49Array[i].glowOpacity = 0.75;
          score49 += peg49Value * this.mult;
          stats49.pegsTouched++;
        }
      }
    }
    
    if (this.x > canvas49.width + ball49Radius) this.x = -ball49Radius;
    if (this.x < -ball49Radius) this.x = canvas49.width + ball49Radius;
    
    for (let i = 0; i < powerUp49Array.length; i++) {
      let dx = powerUp49Array[i].x - this.x;
      let dy = powerUp49Array[i].y - this.y;
      let distSq = (dx * dx) + (dy * dy);
      let rad = ball49Radius + powerUp49Radius;
      if (distSq <= rad * rad && !powerUp49Array[i].collected) {
        powerUp49Array[i].collect(this);
        stats49.powerUpsCollected++;
      }
    }
    
    if (this.y > canvas49.height + (ball49Radius * 2)) this.score();
  };
  Ball49.prototype.score = function() {
    this.dead = true;
    
    this.x = this.x.clamp(5, canvas49.width - 5);
    
    for (let i = 0; i < bucket49Array.length; i++) {
      let b = bucket49Array[i];
      if (this.x >= b.x && this.x < b.x + b.width) {
        this.x = b.x + (b.width / 2);
        score49 += b.value * this.mult;
        if (b.value === 0) {
          b.glowOpacity = 1.25;
          return;
        }
        b.glowOpacity = 1;
      }
    }
    
    for (let i = 0; i < 100; i++) {
      particle49Array.push(new Particle49(
        randBetween(this.x - ball49Radius, this.x + ball49Radius), // x
        this.y - (Math.random() * ball49Radius * 2), // y
        randBetween(255, 285), // angle
        randBetween(3, 8), // velocity
        `hsl(${randBetween(-60, 60)}deg, 100%, ${randBetween(30, 50)}%)`, // color
        randBetween(5, 10), // size
        randBetween(0.5, 1), // opacity
        randBetween(0.008, 0.015), // fadeRate
        false, // hasFriction
        false // hasOutline
      ));
    }
  };
  let ball49Array = [];
  
  function Peg49(x, y, color) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.glowOpacity = 0;
  }
  Peg49.prototype.draw = function() {
    ctx49.fillStyle = this.color;
    
    ctx49.globalAlpha = this.glowOpacity;
    ctx49.fillCircle(this.x, this.y, peg49Radius * (1 + (this.glowOpacity * 1.33)));
    
    ctx49.globalAlpha = 1;
    ctx49.fillCircle(this.x, this.y, peg49Radius);
  };
  Peg49.prototype.update = function() {
    this.glowOpacity -= glowFade49;
    if (this.glowOpacity < 0) this.glowOpacity = 0;
  };
  let peg49Array = [];
  
  function Particle49(x, y, angle, velocity, color, size, opacity, fadeRate, hasFriction, hasOutline) {
    this.x = x;
    this.y = y;
    this.velocity = velocity;
    this.angle = angle;
    this.vx = velocity * Math.cos(toRad(angle));
    this.vy = velocity * Math.sin(toRad(angle));
    this.color = color;
    this.size = size;
    this.opacity = opacity;
    this.fadeRate = fadeRate;
    this.hasFriction;
    this.hasOutline = hasOutline;
  }
  Particle49.prototype.update = function() {
    this.opacity -= this.fadeRate;
    if (this.opacity <= 0) {
      this.opacity = 0;
      this.dead = true;
      return;
    }
    
    this.vx = this.velocity * Math.cos(toRad(this.angle)) * (this.hasFriction ? this.opacity : 1);
    this.vy = this.velocity * Math.sin(toRad(this.angle)) * (this.hasFriction ? this.opacity : 1);
    
    this.x += this.vx;
    this.y += this.vy;
  };
  Particle49.prototype.draw = function() {
    ctx49.fillStyle = this.color;
    ctx49.strokeStyle = "black";
    ctx49.lineWidth = 2;
    ctx49.globalAlpha = this.opacity;
    
    ctx49.fillCircle(this.x, this.y, this.size * this.opacity);
    
    if (this.hasOutline) ctx49.strokeCircle(this.x, this.y, this.size * this.opacity);
    
    ctx49.globalAlpha = 1;
  };
  let particle49Array = [];
  
  function Bucket49(x, y, width, height, value, color, textColor) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.value = value;
    this.color = color;
    this.textColor = textColor;
    
    this.glowOpacity = 0;
  }
  Bucket49.prototype.draw = function() {
    ctx49.strokeStyle = "black";
    ctx49.lineWidth = bucket49Thickness;
    ctx49.lineCap = ctx49.lineJoin = "round";
    
    ctx49.fillStyle = this.color; // Draw bucket color
    ctx49.fillRect(this.x, this.y, this.width, this.height);
    
    ctx49.globalAlpha = this.glowOpacity; // Draw bucket glow
    ctx49.fillRect(this.x, playableY49 + 2, this.width, canvas49.height - this.height - playableY49 - 2);
    ctx49.globalAlpha = 1;
    
    ctx49.beginPath(); // Draw bucket edges
    ctx49.moveTo(this.x, this.y);
    ctx49.lineTo(this.x, this.y + this.height);
    ctx49.moveTo(this.x + this.width, this.y);
    ctx49.lineTo(this.x + this.width, this.y + this.height);
    ctx49.stroke();
    
    ctx49.fillStyle = this.textColor;
    ctx49.font = "bold 30px verdana";
    ctx49.textAlign = "center";
    ctx49.textBaseline = "top";
    ctx49.fillText(this.value, this.x + (this.width / 2), this.y + (this.height / 2) - 15);
  };
  Bucket49.prototype.update = function() {
    this.glowOpacity -= glowFade49;
    if (this.glowOpacity < 0) this.glowOpacity = 0;
  };
  let bucket49Array = [];
  
  function PowerUp49(y, type) {
    this.x = 0;
    this.y = y;
    this.type = type;
    
    this.theta = Math.random();
    this.sign = randSign();
    
    this.collected = false;
    
    this.update();
  }
  PowerUp49.prototype.draw = function() {
    if (this.collected) return;
    if (this.type === 1) { // +1 Ball
      ctx49.fillStyle = ball49Color;
      ctx49.strokeStyle = "black";
      ctx49.lineWidth = 2;
      ctx49.fillCircle(this.x, this.y, powerUp49Radius);
      ctx49.strokeCircle(this.x, this.y, powerUp49Radius);
      
      ctx49.lineWidth = 4; // Draw plus
      ctx49.beginPath();
      ctx49.moveTo(this.x, this.y - (powerUp49Radius * 0.5));
      ctx49.lineTo(this.x, this.y + (powerUp49Radius * 0.5));
      ctx49.moveTo(this.x - (powerUp49Radius * 0.5), this.y);
      ctx49.lineTo(this.x + (powerUp49Radius * 0.5), this.y);
      ctx49.stroke();
    }
    
    else if (this.type === 2) { // x2 Mult
      ctx49.fillStyle = "yellow";
      ctx49.strokeStyle = "black";
      ctx49.lineWidth = 2;
      ctx49.fillCircle(this.x, this.y, powerUp49Radius);
      ctx49.strokeCircle(this.x, this.y, powerUp49Radius);
      
      ctx49.fillStyle = "black";
      ctx49.font = "bold 15px verdana";
      ctx49.textAlign = "center";
      ctx49.textBaseline = "middle";
      ctx49.fillText("x2", this.x, this.y);
    }
    
    else if (this.type === 3) { // Elevator
      ctx49.fillStyle = "hsl(0deg, 0%, 70%)";
      ctx49.strokeStyle = "black";
      ctx49.lineWidth = 2;
      ctx49.fillCircle(this.x, this.y, powerUp49Radius);
      ctx49.strokeCircle(this.x, this.y, powerUp49Radius);
      
      ctx49.lineWidth = 4; // Draw arrow
      ctx49.beginPath();
      ctx49.moveTo(this.x, this.y - (powerUp49Radius * 0.5));
      ctx49.lineTo(this.x, this.y + (powerUp49Radius * 0.5));
      ctx49.moveTo(this.x - (powerUp49Radius * 0.5), this.y);
      ctx49.lineTo(this.x, this.y + (powerUp49Radius * 0.5));
      ctx49.lineTo(this.x + (powerUp49Radius * 0.5), this.y);
      ctx49.stroke();
    }
  };
  PowerUp49.prototype.update = function() {
    this.theta += this.sign * (1 / powerUp49SlidePeriod);
    this.theta = (this.theta + 1) % 1;
    this.x = ((1 - Math.cos(Math.PI * 2 * this.theta)) / 2) * (canvas49.width - (powerUp49Radius * 2)) + powerUp49Radius;
  };
  PowerUp49.prototype.collect = function(caller) {
    this.collected = true;
    let n = 30;
    for (let i = 0; i < n; i++) {
      particle49Array.push(new Particle49(
        this.x, // x
        this.y, // y
        ((i / n) * 360) + randBetween(-5, 5), // angle
        randBetween(2, 4), // velocity
        "white", // color
        randBetween(5, 10), // size
        1, // opacity
        randBetween(0.008, 0.015), // fadeRate
        false, // hasFriction
        false // hasOutline
      ));
    }
    
    if (this.type === 1) { // +1 Ball
      maxBalls49++;
      stats49.extraBalls++;
    }
    else if (this.type === 2) caller.mult *= 2; // x2 Mult
    else if (this.type === 3) { // Elevator
      caller.slidingDown = true;
      caller.vx = caller.vy = 0;
    }
    
    score49 += powerUp49Value * caller.mult;
  };
  let powerUp49Array = [];
  
  let lastFrame49Time = 0;
  let lastFps49DisplayTime = 1000;
  function frame49() {
    if (Date.now() - lastFps49DisplayTime >= 500) {
      fps49Txt.innerHTML = (1000 / (Date.now() - lastFrame49Time)).toFixed(1);
      lastFps49DisplayTime = Date.now();
    }
    lastFrame49Time = Date.now();
    
    ctx49.fillStyle = "#00e35b";
    ctx49.fillRect(0, 0, canvas49.width, canvas49.height); // Background
    
    ctx49.strokeStyle = "black"; // Playable line
    ctx49.lineWidth = 4;
    ctx49.beginPath();
    ctx49.moveTo(0, playableY49);
    ctx49.lineTo(canvas49.width, playableY49);
    ctx49.stroke();
    
    for (let i = 0; i < maxBalls49; i++) { // Draw remaining balls
      let x = 15 + ball49Radius + ((i * 3) * ball49Radius);
      let y = ball49Radius + 15;
      if (i < maxBalls49 - ball49Array.length) { // Draw ball
        ctx49.fillStyle = ball49Color;
        
        ctx49.fillCircle(x, y, ball49Radius);
        ctx49.strokeStyle = "black";
        ctx49.lineWidth = 2;
        ctx49.strokeCircle(x, y, ball49Radius);
      }
      else { // Draw empty slot
        ctx49.fillStyle = "rgba(0, 0, 0, 0.4)";
        ctx49.fillCircle(x, y, ball49Radius);
      }
    }
    
    for (let i = 0; i < bucket49Array.length; i++) { // Render buckets
      bucket49Array[i].update();
      bucket49Array[i].draw();
    }
    
    for (let i = 0; i < peg49Array.length; i++) { // Render pegs
      peg49Array[i].update();
      peg49Array[i].draw();
    }
    
    for (let i = 0; i < powerUp49Array.length; i++) { // Render powerups
      powerUp49Array[i].draw();
      powerUp49Array[i].update();
      
      if (powerUp49Array[i].collected) {
        powerUp49Array.splice(i, 1);
        i--;
      }
    }
    
    for (let i = 0; i < ball49Array.length; i++) { // Render balls
      ball49Array[i].update();
      ball49Array[i].draw();
      
      if (ball49Array[i].dead && replenishBalls49) {
        ball49Array.splice(i, 1);
        i--;
      }
    }
    
    for (let i = 0; i < particle49Array.length; i++) { // Render particles
      particle49Array[i].update();
      particle49Array[i].draw();
      
      if (particle49Array[i].dead) {
        particle49Array.splice(i, 1);
        i--;
      }
    }
    
    if (score49 > highScore49) highScore49 = score49;
    //window.localStorage.setItem("highscore", highScore49);
    ctx49.fillStyle = "black";
    ctx49.font = "bold 25px verdana";
    ctx49.textBaseline = "top";
    ctx49.textAlign = "right";
    ctx49.fillText(`Score: ${score49.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")}`, canvas49.width - 15, 15);
    ctx49.fillText(`Highscore: ${highScore49.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")}`, canvas49.width - 15, 45);
    
    if (ball49Array.length >= maxBalls49) {
      gameOver49 = true;
      for (let i = 0; i < ball49Array.length; i++) {
        if (!ball49Array[i].dead) gameOver49 = false;
      }
    }
    
    if (!gameOver49) stats49.gameLength = ((Date.now() - stats49.gameStartTime) / 1000).toFixed(1);
    
    ctx49.textAlign = "center";
    ctx49.fillText(stats49.gameLength + "s", canvas49.width / 2, 15);
    
    if (gameOver49) {
      gameOver49Opacity += 0.01;
      if (gameOver49Opacity >= 1) gameOver49Opacity = 1;
      
      ctx49.globalAlpha = gameOver49Opacity;
      ctx49.fillStyle = "black";
      
      ctx49.fillRect(0, 0, canvas49.width, canvas49.height);
      
      ctx49.fillStyle = "red"//"hsl(0deg, 80%, 60%)";
      ctx49.strokeStyle = "white";
      ctx49.lineWidth = 5;
      ctx49.font = "bold 75px verdana";
      ctx49.textAlign = "center";
      ctx49.textBaseline = "top";
      ctx49.strokeText("G A M E", canvas49.width / 2, 100);
      ctx49.strokeText("O V E R", canvas49.width / 2, 200);
      ctx49.fillText("G A M E", canvas49.width / 2, 100);
      ctx49.fillText("O V E R", canvas49.width / 2, 200);
      
      ctx49.font = "bold 40px verdana";
      ctx49.fillStyle = "hsl(120deg, 100%, 35%)";
      ctx49.fillText(`Score: ${score49.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")}`, canvas49.width / 2, 350);
      
      ctx49.fillStyle = "white";
      ctx49.font = "25px verdana";
      ctx49.fillText(`${stats49.pegsTouched.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")} peg${stats49.pegsTouched === 1 ? "" : "s"} hit`, canvas49.width / 2, 425);
      ctx49.fillText(`${stats49.powerUpsCollected} power-up${stats49.powerUpsCollected === 1 ? "" : "s"} collected`, canvas49.width / 2, 475);
      ctx49.fillText(`${stats49.extraBalls} extra ball${stats49.extraBalls === 1 ? "" : "s"} collected`, canvas49.width / 2, 525);
      ctx49.fillText(`${stats49.gameLength} seconds played`, canvas49.width / 2, 575);
      
      ctx49.font = "bold 40px verdana";
      ctx49.fillStyle = "yellow";
      ctx49.fillText(`Highscore: ${highScore49.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",")}`, canvas49.width / 2, 650);
      
      ctx49.fillStyle = "hsl(240deg, 100%, 70%)";
      ctx49.font = "italic 25px verdana";
      ctx49.fillText("Click anywhere to start a new game", canvas49.width / 2, 750);
      
      ctx49.globalAlpha = 1;
    }
    
    if (canvas49Running) requestAnimationFrame(frame49);
  }
  
  function reset49() {
    score49 = 0;
    gameOver49 = false;
    gameOver49Opacity = 0;
    
    stats49 = {
      pegsTouched: 0,
      extraBalls: 0,
      powerUpsCollected: 0,
      gameStartTime: Date.now(),
      gameLength: 0
    };
    
    //window.localStorage.setItem("highscore", highScore49);
    
    maxBalls49 = defaultMaxBalls49;
    
    particle49Array = [];
    
    peg49Array = [];
    let spacing = canvas49.width / pegRows49;
    for (let x = 0; x <= pegRows49; x++) {
      for (let y = 0; y < 10; y++) {
        let _x = y % 2 === 0 ? x + 1 : x + 0.5;
        let hue = y % 2 === 0 ? 240 : 0;
        let color = y % 2 === 0 ? "blue" : "#d40202";
        let last = y % 2 === 0 && x > pegRows49 - 2;
        if (!last) peg49Array.push(new Peg49(_x * spacing, (y + 2) * spacing, color));
      }
    }
    
    ball49Array = [];
    //ball49Array.push(new Ball49(randBetween(200, 800), 100));
    
    bucket49TemplateArray.push({value: 1000, color: "hsl(240deg, 80%, 50%)", textColor: "black"});
    bucket49TemplateArray.push({value: 500, color: "hsl(300deg, 60%, 60%)", textColor: "black"});
    for (let i = 0; i < 2; i++) bucket49TemplateArray.push({value: 250, color: "hsl(120deg, 60%, 40%)", textColor: "black"});
    for (let i = 0; i < 3; i++) bucket49TemplateArray.push({value: 100, color: "hsl(0deg, 80%, 60%)", textColor: "black"});
    for (let i = 0; i < 2; i++) bucket49TemplateArray.push({value: 50, color: "hsl(60deg, 100%, 60%)", textColor: "black"});
    for (let i = 0; i < 1; i++) bucket49TemplateArray.push({value: 0, color: "hsl(0deg, 0%, 10%)", textColor: "white"});
    
    bucket49Array = [];
    let width = canvas49.width / numBuckets49;
    for (let i = 0; i < numBuckets49; i++) {
      let j = Math.floor(Math.random() * bucket49TemplateArray.length);
      let template = bucket49TemplateArray[j];
      bucket49TemplateArray.splice(j, 1);
      bucket49Array.push(new Bucket49(
        i * width, // x
        canvas49.height - bucket49Height, // y
        width, // width
        bucket49Height, // height
        template.value, // value
        template.color, // color
        template.textColor // textColor
      ));
    }
    
    powerUp49Array = [];
    for (let i = 0; i < numPowerUp49Array.length; i++) {
      for (let j = 0; j < numPowerUp49Array[i]; j++) {
        let py = 0;
        if (i === 0) py = Math.round(randBetween(2, 10)) + 0.5; // +1 Ball, generates anywhere on screen
        else if (i === 1) py = Math.round(randBetween(2, 6)) + 0.5; // x2 Mult, generates at top half of screen
        else if (i === 2) py = 2.5; // Elevator, generates in top row only
        
        powerUp49Array.push(new PowerUp49(py * spacing, i + 1));
      }
    }
    
    if (!canvas49Running) frame49();
  }
  reset49();
  
  function startCanvas49(caller) {
    if (canvas49Running) {
      canvas49Running = false;
      caller.innerHTML = "Start";
    }
    else {
      canvas49Running = true;
      caller.innerHTML = "Stop";
      frame49();
    }
  }
  
  canvas49.addEventListener("mousedown", e => {
    if (!canvas49Running) return;
    e.preventDefault();
    
    canvas49Rect = canvas49.getBoundingClientRect();
    let eX = (e.clientX - canvas49Rect.left) * canvas49Ratio;
    eX = eX.clamp(ball49Radius, canvas49.width - ball49Radius);
    let eY = (e.clientY - canvas49Rect.top) * canvas49Ratio;
    
    if (gameOver49 && eY >= playableY49) {
      reset49();
      return;
    }
    
    let a = Math.random() * Math.PI * 2;
    let r = Math.random() * 0.5;
    if (ball49Array.length < maxBalls49 && eY <= playableY49) {
      let newBall = new Ball49(eX, eY);
      newBall.vx = r * Math.cos(a);
      newBall.vy = r * Math.sin(a);
      ball49Array.push(newBall);
    }
  });
</script>
<canvas id = "canvas48"></canvas>
<button onclick = "startCanvas48()">Start/Stop</button>
<button onclick = "reset48()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps48Txt"></span></b></i></div>
<div class = "desc"><b><i>(1/25/2022)</i></b> Genuary 2022's prompt for January 24th, "Create your own pseudo-random number generator and visually check the results." I'm not super proud of this but I'm just gonna leave it how it is.</div>
<hr><hr>
<script>
  const ctx48 = canvas48.getContext("2d");
  canvas48.width = canvas48.height = 1000;
  let canvas48Running = false;
  
  let i48 = 0;
  function random48() {
    i48++;
    return Math.abs(Math.tan((i48 * i48) + i48)) % 1;//Math.abs(Math.sin(Math.sin(i48 ** 2)));
  }
  
  let Walker48 = {
    x: canvas48.width / 2,
    y: canvas48.height / 2,
    hue: 0
  };
  Walker48.walk = function() {
    //let lastX = this.x;
    //let lastY = this.y;
    let a = random48() * Math.PI * 2;
    this.x += 5 * Math.cos(a);
    this.y += 5 * Math.sin(a);
    
    this.hue += (random48() * 0.5) - 0.25;
    
    this.x = (this.x + canvas48.width) % canvas48.width;
    this.y = (this.y + canvas48.height) % canvas48.height;
    
    ctx48.fillStyle = `hsl(${this.hue}deg, 100%, 50%)`;
    ctx48.fillCircle(this.x, this.y, 3);
  };
  
  let lastFrame48Time = 0;
  let lastFps48DisplayTime = 1000;
  
  function frame48() {
    if (Date.now() - lastFps48DisplayTime >= 500) {
      fps48Txt.innerHTML = (1000 / (Date.now() - lastFrame48Time)).toFixed(1);
      lastFps48DisplayTime = Date.now();
    }
    lastFrame48Time = Date.now();
    
    /*for (let i = 0; i < 10; i++) {
      ctx48.fillStyle = `hsl(${random48() * 360}deg, ${(random48() * 20) + 80}%, ${(random48() * 20) + 40}%)`;
      ctx48.fillCircle(random48() * canvas48.width, random48() * canvas48.height, (random48() * 5) + 5);
    }*/
    for (let i = 0; i < 1000; i++) Walker48.walk();
    
    if (canvas48Running) requestAnimationFrame(frame48);
  }
  frame48();
  
  function reset48() {
    ctx48.clearRect(0, 0, canvas48.width, canvas48.height);
    i48 = 0;
    Walker48.x = canvas48.width / 2;
    Walker48.y = canvas48.height / 2;
    Walker48.hue = 0;
    if (!canvas48Running) frame48();
  }
  
  function startCanvas48() {
    if (canvas48Running) canvas48Running = false;
    else {
      canvas48Running = true;
      frame48();
    }
  }
</script>
<canvas id = "canvas47"></canvas>
<button onclick = "startCanvas47()">Start/Stop</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps47Txt"></span></b></i></div>
<table>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Number of Arms:</u></b> <span id = "arm47SymmetryTxt">6</span></div>
      <input type = "range" min = "1" max = "24" step = "1" value = "6" id = "arm47SymmetryRange" oninput = "updateSettings47(false)">
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "arm47ShowArmsCheckbox" oninput = "updateSettings47(false)" CHECKED>
      <label for = "arm47ShowArmsCheckbox">Show Arms</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "arm47RainbowArmsCheckbox" oninput = "updateSettings47(false)">
      <label for = "arm47RainbowArmsCheckbox">Rainbow Arms</label>
    </td>
    <td style = "padding: 10px">
      <div><b><u>Arm Thickness:</u></b> <span id = "arm47ArmThicknessTxt">3</span>px</div>
      <input type = "range" min = "1" max = "15" step = "1" value = "3" id = "arm47ArmThicknessRange" oninput = "updateSettings47(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Joints Per Arm:</u></b> <span id = "arm47SegmentsTxt">5</span></div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "arm47SegmentsRange" oninput = "updateSettings47(true)">
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "arm47ShowJointsCheckbox" oninput = "updateSettings47(false)" CHECKED>
      <label for = "arm47ShowJointsCheckbox">Show Joints</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "arm47RainbowJointsCheckbox" oninput = "updateSettings47(false)">
      <label for = "arm47RainbowJointsCheckbox">Rainbow Joints</label>
    </td>
    <td style = "padding: 10px">
      <div><b><u>Joint Size:</u></b> <span id = "arm47JointSizeTxt">5</span>px</div>
      <input type = "range" min = "1" max = "15" step = "1" value = "5" id = "arm47JointSizeRange" oninput = "updateSettings47(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Arm Length:</u></b> <span id = "arm47TotalLengthTxt">400</span>px</div>
      <input type = "range" min = "100" max = "500" step = "50" value = "400" id = "arm47TotalLengthRange" oninput = "updateSettings47(true)">
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "arm47ShowShadowsCheckbox" oninput = "updateSettings47(false)">
      <label for = "arm47ShowShadowsCheckbox">Show Shadows</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "arm47RainbowShadowsCheckbox" oninput = "updateSettings47(false)">
      <label for = "arm47RainbowShadowsCheckbox">Rainbow Shadows</label>
    </td>
    <td style = "padding: 10px">
      <div><b><u>Shadow Opacity:</u></b> <span id = "arm47ShadowOpacityTxt">25</span>%</div>
      <input type = "range" min = "0" max = "100" step = "5" value = "25" id = "arm47ShadowOpacityRange" oninput = "updateSettings47(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "arm47AnchorOnCheckbox" oninput = "updateSettings47(false)" CHECKED>
      <label for = "arm47AnchorOnCheckbox">Anchor to center</label>
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(1/24/2022)</i></b> Continuing the FABRIK experiment trend, this is a simple FABRIK chain with symmetry (dragged by the cursor), making cool intricate patterns that are similar to <a href = "servo.html" target = "_blank">servo.html</a> but manually controlled.<br><b><i>Update: (Later that day)</i></b> I added all the settings from servo.html and sliders for everything.</div>
<hr><hr>
<script>
  const ctx47 = canvas47.getContext("2d");
  canvas47.width = canvas47.height = 1000;
  let canvas47Running = false;
  let canvas47Ratio = canvas47.width / 300;
  let canvas47Rect = canvas47.getBoundingClientRect();
  
  let Mouse47 = {
    x: 0,
    y: 0,
    down: false
  };
  
  let Arm47 = {
    points: [],
    anchor: {
      x: canvas47.width / 2,
      y: canvas47.height / 2,
      on: true
    },
    segments: 6,
    totalLength: 400,
    symmetry: 6,
    
    showShadows: false,
    showJoints: true,
    showArms: true,
    
    armThickness: 3,
    jointSize: 5,
    shadowOpacity: 0.25,
    
    rainbowArms: false,
    rainbowJoints: false,
    rainbowShadows: false,
    
    easeToCursor: false,
    easeSpeed: 0.05
  };
  Arm47.reset = function() {
    let orientation = 270;
    
    this.segmentLength = this.totalLength / this.segments;
    this.points = [];
    let cx = this.anchor.x;
    let cy = this.anchor.y;
    for (let i = 0; i < this.segments + 1; i++) {
      this.points.push({x: cx, y: cy});
      cx += this.segmentLength * Math.cos(toRad(orientation));
      cy += this.segmentLength * Math.sin(toRad(orientation));
    }
    
    if (!canvas47Running) frame47();
  };
  Arm47.snapToPoint = function(x, y) {
    let oX = this.points[0].x;
    let oY = this.points[0].y;
    let endX = x;
    let endY = y;
    for (let i = this.points.length - 1; i >= 0; i--) {
      this.points[i].x = endX;
      this.points[i].y = endY;
      if (i !== 0) {
        let dx = this.points[i - 1].x - endX;
        let dy = this.points[i - 1].y - endY;
        let angle = Math.atan2(dy, dx);
        endX += this.segmentLength * Math.cos(angle);
        endY += this.segmentLength * Math.sin(angle);
      }
    }
    
    if (!this.anchor.on) return;
    
    endX = oX;
    endY = oY;
    
    for (let i = 0; i < this.points.length; i++) {
      this.points[i].x = endX;
      this.points[i].y = endY;
      if (i !== this.points.length - 1) {
        let dx = this.points[i + 1].x - endX;
        let dy = this.points[i + 1].y - endY;
        let angle = Math.atan2(dy, dx);
        endX += this.segmentLength * Math.cos(angle);
        endY += this.segmentLength * Math.sin(angle);
      }
    }
  };
  Arm47.easeToPoint = function(x, y, t) {
    let endX = this.points[this.points.length - 1].x;
    let endY = this.points[this.points.length - 1].y;
    
    this.snapToPoint(((1 - t) * endX) + (t * x), ((1 - t) * endY) + (t * y));
  };
  Arm47.rotatePoint = function(x, y, angle) {
    let P = {x: x, y: y};
    P.x -= canvas47.width / 2;
    P.y -= canvas47.height / 2;
    
    let R = {x: (P.x * Math.cos(angle)) - (P.y * Math.sin(angle)), y: (P.x * Math.sin(angle)) + (P.y * Math.cos(angle))};
    R.x += canvas47.width / 2;
    R.y += canvas47.height / 2;
    
    return R;
  };
  Arm47.draw = function(angle) {
    ctx47.lineWidth = this.armThickness;
    ctx47.lineCap = ctx47.lineJoin = "round";
    
    ctx47.beginPath();
    for (let i = 0; i < this.points.length; i++) {
      let P = this.rotatePoint(this.points[i].x, this.points[i].y, angle);
      ctx47.lineTo(P.x, P.y);
    }
    
    if (this.showShadows) {
      ctx47.fillStyle = this.rainbowShadows ? `hsla(${toDeg(angle)}deg, 100%, 50%, ${this.shadowOpacity})` : `rgba(0, 0, 0, ${this.shadowOpacity})`;
      ctx47.fill();
    }
    
    if (this.showArms) {
      ctx47.strokeStyle = this.rainbowArms ? `hsl(${toDeg(angle)}deg, 100%, 50%)` : "black";
      ctx47.stroke();
    }
    
    if (this.showJoints) {
      ctx47.fillStyle = this.rainbowJoints ? `hsl(${toDeg(angle)}deg, 100%, 50%)` : "black";
      for (let i = 1; i < this.points.length - 1; i++) {
        let P = this.rotatePoint(this.points[i].x, this.points[i].y, angle);
        ctx47.fillCircle(P.x, P.y, this.jointSize);
      }
    }
  };
  Arm47.update = function() {
    if (Mouse47.down) {
      if (this.easeToCursor) this.easeToPoint(Mouse47.x, Mouse47.y, this.easeSpeed);
      else this.snapToPoint(Mouse47.x, Mouse47.y);
    }
  };
  
  let lastFrame47Time = 0;
  let lastFps47DisplayTime = 1000;
  
  function frame47() {
    if (Date.now() - lastFps47DisplayTime >= 500) {
      fps47Txt.innerHTML = (1000 / (Date.now() - lastFrame47Time)).toFixed(1);
      lastFps47DisplayTime = Date.now();
    }
    lastFrame47Time = Date.now();
    
    ctx47.clearRect(0, 0, canvas47.width, canvas47.height);
    
    Arm47.update();
    for (let i = 0; i < Arm47.symmetry; i++) Arm47.draw((i / Arm47.symmetry) * Math.PI * 2);
    
    if (canvas47Running) requestAnimationFrame(frame47);
  }
  Arm47.reset();
  
  function startCanvas47() {
    if (canvas47Running) canvas47Running = false;
    else {
      canvas47Running = true;
      frame47();
    }
  }
  
  let arm47SegmentsRangeArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 40, 50, 100, 200];
  arm47SegmentsRange.max = arm47SegmentsRangeArray.length - 1;
  arm47SegmentsRange.value = arm47SegmentsRangeArray.indexOf(5);
  
  function updateSettings47(reset) {
    Arm47.symmetry = arm47SymmetryTxt.innerHTML = Number(arm47SymmetryRange.value);
    
    Arm47.segments = arm47SegmentsRangeArray[Number(arm47SegmentsRange.value)] + 1;
    arm47SegmentsTxt.innerHTML = Arm47.segments - 1;
    
    Arm47.totalLength = arm47TotalLengthTxt.innerHTML = Number(arm47TotalLengthRange.value);
    
    let lastAnchor = Arm47.anchor.on;
    Arm47.anchor.on = arm47AnchorOnCheckbox.checked;
    if (!lastAnchor && Arm47.anchor.on) reset = true;
    
    Arm47.showArms = arm47ShowArmsCheckbox.checked;
    Arm47.showJoints = arm47ShowJointsCheckbox.checked;
    Arm47.showShadows = arm47ShowShadowsCheckbox.checked;
    
    Arm47.rainbowArms = arm47RainbowArmsCheckbox.checked;
    Arm47.rainbowJoints = arm47RainbowJointsCheckbox.checked;
    Arm47.rainbowShadows = arm47RainbowShadowsCheckbox.checked;
    
    Arm47.armThickness = arm47ArmThicknessTxt.innerHTML = Number(arm47ArmThicknessRange.value);
    Arm47.jointSize = arm47JointSizeTxt.innerHTML = Number(arm47JointSizeRange.value);
    Arm47.shadowOpacity = Number(arm47ShadowOpacityRange.value) / 100;
    arm47ShadowOpacityTxt.innerHTML = arm47ShadowOpacityRange.value;
    
    if (reset) Arm47.reset();
    else if (!canvas47Running) frame47();
  }
  
  canvas47.addEventListener("mousedown", e => {
    if (!canvas47Running) return;
    e.preventDefault();
    Mouse47.down = true;
    canvas47Rect = canvas47.getBoundingClientRect();
    Mouse47.x = (e.clientX - canvas47Rect.left) * canvas47Ratio;
    Mouse47.y = (e.clientY - canvas47Rect.top) * canvas47Ratio;
  });
  canvas47.addEventListener("mousemove", e => {
    if (!canvas47Running || !Mouse47.down) return;
    e.preventDefault();
    canvas47Rect = canvas47.getBoundingClientRect();
    Mouse47.x = (e.clientX - canvas47Rect.left) * canvas47Ratio;
    Mouse47.y = (e.clientY - canvas47Rect.top) * canvas47Ratio;
  });
  window.addEventListener("mouseup", e => {
    Mouse47.down = false;
  });
</script>
<canvas id = "canvas46" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas46()">Start/Stop</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps46Txt"></span></b></i></div>
<div class = "desc"><b><i>(1/23/2022)</i></b> I want to make another FABRIK-based animation, with colored claws reaching for colored boxes and placing them offscreen, and repeating. I have the arms working but the grabbing and placing down doesn't work yet.<br><b><i>(1/24/2022)</i></b> I finally got everything working properly, each arm bends to grab its box and places it offscreen, and repeats. It might not be super impressive but I like this project and I'm pretty proud of it, and it's really satisfying to watch. I also got the claw part of the arms to look right, and added text to show each arm's total number of collected boxes. This is easily one of my favorite projects I've made.</div>
<hr><hr>
<script>
  const ctx46 = canvas46.getContext("2d");
  canvas46.width = canvas46.height = 1000;
  let canvas46Running = false;
  
  let arm46Length = 600;
  let arm46Segments = 6;
  let arm46Speed = 0.05;
  let arm46SegmentLength = arm46Length / arm46Segments;
  let arm46Thickness = 20;
  let box46Size = 50;
  let arm46MagnetDist = 200;
  let arm46GrabDist = (box46Size + arm46Thickness) / 2;
  let arm46ClawLength = box46Size + arm46Thickness;
  let arm46ClawDepth = box46Size + (arm46Thickness / 2);
  let arm46PlaceDist = box46Size * 1.5;
  let arm46MagnetSpeed = 3;
  let shadows46 = true;
  
  function Arm46(anchorX, anchorY, orientation, color) {
    this.anchor = {
      x: anchorX,
      y: anchorY
    };
    
    this.points = [];
    let cx = this.anchor.x;
    let cy = this.anchor.y;
    for (let i = 0; i < arm46Segments + 1; i++) {
      this.points.push({x: cx, y: cy});
      cx += arm46SegmentLength * Math.cos(toRad(orientation));
      cy += arm46SegmentLength * Math.sin(toRad(orientation));
    }
    
    this.end = {
      x: this.points[this.points.length - 1].x,
      y: this.points[this.points.length - 1].y
    };
    
    this.color = color;
    
    this.box = new Box46(this.color);
    this.pullingBox = false;
    this.holdingBox = false;
    this.destination = {x: this.anchor.x, y: this.anchor.y};
    
    this.collected = 0;
    
    this.speed = arm46Speed// * randBetween(0.75, 1);
  }
  Arm46.prototype.draw = function() {
    ctx46.lineCap = ctx46.lineJoin = "round";
    
    ctx46.beginPath();
    ctx46.moveTo(this.anchor.x, this.anchor.y);
    for (let i = 0; i < this.points.length; i++) ctx46.lineTo(this.points[i].x, this.points[i].y);
    
    let dx = this.points[this.points.length - 2].x - this.end.x;
    let dy = this.points[this.points.length - 2].y - this.end.y;
    let norm = Math.atan2(dy, dx) + (Math.PI / 2);
    let angle = norm + (Math.PI / 2);
    let left = {x: this.end.x - (arm46ClawLength * 0.5 * Math.cos(norm)), y: this.end.y - (arm46ClawLength * 0.5 * Math.sin(norm))};
    let topLeft = {x: left.x + (arm46ClawDepth * Math.cos(angle)), y: left.y + (arm46ClawDepth * Math.sin(angle))};
    let right = {x: this.end.x + (arm46ClawLength * 0.5 * Math.cos(norm)), y: this.end.y + (arm46ClawLength * 0.5 * Math.sin(norm))};
    let topRight = {x: right.x + (arm46ClawDepth * Math.cos(angle)), y: right.y + (arm46ClawDepth * Math.sin(angle))};
    ctx46.moveTo(topLeft.x, topLeft.y);
    ctx46.lineTo(left.x, left.y);
    ctx46.lineTo(right.x, right.y);
    ctx46.lineTo(topRight.x, topRight.y);
    
    if (!shadows46) {
      ctx46.lineWidth = arm46Thickness * 1.33;
      ctx46.strokeStyle = "black";
      ctx46.stroke();
    }
    
    if (shadows46) {
      ctx46.shadowBlur = 10;
      ctx46.shadowColor = "black";
    }
    ctx46.strokeStyle = this.color;
    ctx46.lineWidth = arm46Thickness;
    ctx46.stroke();
    
    ctx46.shadowBlur = 0;
    
    ctx46.fillStyle = "white";
    for (let i = 1; i < this.points.length; i++) ctx46.fillCircle(this.points[i].x, this.points[i].y, arm46Thickness / 4);
    
    this.box.draw(toDeg(angle));
    
    ctx46.fillStyle = this.color;
    ctx46.font = "bold 50px verdana";
    ctx46.shadowBlur = 25;
    ctx46.shadowColor = "black";
    for (let i = 0; i < 5; i++) this.drawScore();
    ctx46.shadowBlur = 0;
  };
  Arm46.prototype.snapToPoint = function(x, y) {
    let oX = this.points[0].x;
    let oY = this.points[0].y;
    let cx = x;
    let cy = y;
    for (let i = this.points.length - 1; i >= 0; i--) {
      this.points[i].x = cx;
      this.points[i].y = cy;
      if (i !== 0) {
        let dx = this.points[i - 1].x - cx;
        let dy = this.points[i - 1].y - cy;
        let angle = Math.atan2(dy, dx);
        cx += arm46SegmentLength * Math.cos(angle);
        cy += arm46SegmentLength * Math.sin(angle);
      }
    }
    
    cx = oX;
    cy = oY;
    
    for (let i = 0; i < this.points.length; i++) {
      this.points[i].x = cx;
      this.points[i].y = cy;
      if (i !== this.points.length - 1) {
        let dx = this.points[i + 1].x - cx;
        let dy = this.points[i + 1].y - cy;
        let angle = Math.atan2(dy, dx);
        cx += arm46SegmentLength * Math.cos(angle);
        cy += arm46SegmentLength * Math.sin(angle);
      }
    }
    
    this.end.x = this.points[this.points.length - 1].x;
    this.end.y = this.points[this.points.length - 1].y;
  };
  Arm46.prototype.easeToPoint = function(x, y, t) {
    this.end.x = this.points[this.points.length - 1].x;
    this.end.y = this.points[this.points.length - 1].y;
    
    this.snapToPoint(((1 - t) * this.end.x) + (t * x), ((1 - t) * this.end.y) + (t * y));
  };
  Arm46.prototype.update = function() {
    if (!this.holdingBox) { // If not holding box, move towards box
      this.easeToPoint(this.box.x, this.box.y, this.speed);
      let dx = this.box.x - this.end.x;
      let dy = this.box.y - this.end.y;
      let distSq = (dx * dx) + (dy * dy);
      
      if (distSq <= arm46MagnetDist * arm46MagnetDist) this.pullingBox = true; // If close enough, activate magnet
      
      if (this.pullingBox) { // Pull box closer
        let dx = this.box.x - this.end.x;
        let dy = this.box.y - this.end.y;
        let angle = Math.atan2(dy, dx) + Math.PI;
        this.box.x += arm46MagnetSpeed * Math.cos(angle);
        this.box.y += arm46MagnetSpeed * Math.sin(angle);
      }
      
      if (distSq <= arm46GrabDist * arm46GrabDist) { // If the box is close enough to the claw, set it to holding
        this.holdingBox = true;
        this.pullingBox = false;
        this.putBoxOnClaw();
        this.setDestination();
      }
    }
    else { // If holding box, ease towards destination
      this.easeToPoint(this.destination.x, this.destination.y, this.speed / 2);
      this.putBoxOnClaw();
      
      let dx = this.destination.x - this.end.x;
      let dy = this.destination.y - this.end.y;
      let distSq = (dx * dx) + (dy * dy);
      
      if (distSq <= arm46PlaceDist * arm46PlaceDist) { // If close enough to destination, place down box
        this.box.resetPos();
        this.holdingBox = false;
        this.collected++;
        this.speed = arm46Speed// * randBetween(0.75, 1);
      }
    }
  };
  Arm46.prototype.putBoxOnClaw = function() {
    let dx = this.points[this.points.length - 2].x - this.end.x;
    let dy = this.points[this.points.length - 2].y - this.end.y;
    let norm = Math.atan2(dy, dx) + (Math.PI / 2);
    let angle = norm + (Math.PI / 2);
    this.box.x = this.end.x + (arm46GrabDist * Math.cos(angle));
    this.box.y = this.end.y + (arm46GrabDist * Math.sin(angle));
  };
  Arm46.prototype.setDestination = function() {
    this.destination = {x: this.anchor.x, y: this.anchor.y};
  };
  let arm46Array = [];
  
  function Box46(color) {
    this.resetPos();
    this.color = color;
  }
  Box46.prototype.draw = function(angle) {
    let a = angle;//(angle + 360) % 90;
    
    if (shadows46) {
      ctx46.shadowBlur = 10;
      ctx46.shadowColor = "black";
    }
    
    ctx46.fillStyle = this.color;
    ctx46.fillRotatedRectFromCenter(this.x, this.y, box46Size, box46Size, a);
    
    ctx46.shadowBlur = 0;
    
    if (!shadows46) {
      ctx46.lineWidth = 3;
      ctx46.strokeStyle = "black";
      ctx46.strokeRotatedRectFromCenter(this.x, this.y, box46Size, box46Size, a);
    }
  };
  Box46.prototype.resetPos = function() {
    this.x = (canvas46.width / 2) + randBetween(-50, 50);
    this.y = (canvas46.height / 2) + randBetween(-50, 50);
  };
  
  let lastFrame46Time = 0;
  let lastFps46DisplayTime = 1000;
  
  function frame46() {
    if (Date.now() - lastFps46DisplayTime >= 500) {
      fps46Txt.innerHTML = (1000 / (Date.now() - lastFrame46Time)).toFixed(1);
      lastFps46DisplayTime = Date.now();
    }
    lastFrame46Time = Date.now();
    
    ctx46.clearRect(0, 0, canvas46.width, canvas46.height);
    
    for (let i = 0; i < arm46Array.length; i++) {
      arm46Array[i].update();
      arm46Array[i].draw();
    }
    
    if (canvas46Running) requestAnimationFrame(frame46);
  }
  
  function reset46() {
    arm46SegmentLength = arm46Length / arm46Segments;
    arm46GrabDist = (box46Size + arm46Thickness) / 2;
    arm46ClawLength = box46Size + arm46Thickness;
    arm46ClawDepth = box46Size + (arm46Thickness / 2);
    arm46PlaceDist = box46Size * 1.5;
    
    arm46Array = [];
    
    let red = new Arm46(0, 0, 45, "red");
    let yellow = new Arm46(canvas46.width, 0, 135, "yellow");
    let green = new Arm46(canvas46.width, canvas46.height, 225, "green");
    let blue = new Arm46(0, canvas46.height, 315, "blue");
    
    red.setDestination = function() {
      if (Math.random() < 0.5) this.destination = {x: randBetween(100, 200), y: -100};
      else this.destination = {x: -100, y: randBetween(100, 200)};
    };
    yellow.setDestination = function() {
      if (Math.random() < 0.5) this.destination = {x: canvas46.width - randBetween(100, 200), y: -100};
      else this.destination = {x: canvas46.width + 100, y: randBetween(100, 200)};
    };
    green.setDestination = function() {
      if (Math.random() < 0.5) this.destination = {x: canvas46.width - randBetween(100, 200), y: canvas46.height + 100};
      else this.destination = {x: canvas46.width + 100, y: canvas46.height - randBetween(100, 200)};
    };
    blue.setDestination = function() {
      if (Math.random() < 0.5) this.destination = {x: randBetween(100, 200), y: canvas46.height + 100};
      else this.destination = {x: -100, y: canvas46.height - randBetween(100, 200)};
    };
    
    red.drawScore = function() {
      ctx46.direction = "ltr";
      ctx46.fillText(this.collected, 25, 65);
    }
    yellow.drawScore = function() {
      ctx46.direction = "rtl";
      ctx46.fillText(this.collected, canvas46.width - 25, 65);
    };
    green.drawScore = function() {
      ctx46.direction = "rtl";
      ctx46.fillText(this.collected, canvas46.width - 25, canvas46.height - 25);
    };
    blue.drawScore = function() {
      ctx46.direction = "ltr";
      ctx46.fillText(this.collected, 25, canvas46.height - 25)
    };
    
    red.snapToPoint(canvas46.width / 2, 0);
    yellow.snapToPoint(canvas46.width, canvas46.height / 2);
    green.snapToPoint(canvas46.width / 2, canvas46.height);
    blue.snapToPoint(0, canvas46.height / 2);
    
    arm46Array.push(red);
    arm46Array.push(yellow);
    arm46Array.push(green);
    arm46Array.push(blue);
    
    if (!canvas46Running) frame46();
  }
  reset46();
  
  function startCanvas46() {
    if (canvas46Running) canvas46Running = false;
    else {
      canvas46Running = true;
      frame46();
    }
  }
</script>
<canvas id = "canvas45" style = "width: 500px; height: 500px"></canvas>
<button onclick = "draw45()">Redraw</button>
<div class = "desc"><b><i>(1/23/2022)</i></b> More random generative art -- I'm not super pleased with how this turned out and at some point in the future I might mess with the parameters until I like it more. But it's still interesting.</div>
<hr><hr>
<script>
  const ctx45 = canvas45.getContext("2d");
  canvas45.width = canvas45.height = 1000;
  
  let bands45 = 100;
  let radius45 = 200;
  let numCircles45 = 25;
  let fillChance45 = 0.25;
  let outlineChance45 = 0.1;
  let colorVariation45 = 0.2;
  
  function Circle45() {
    this.x = Math.random() * canvas45.width;
    this.y = Math.random() * canvas45.height;
    this.hue = Math.random() * 360;
    this.radiusRatio = randBetween(0.5, 1);
  }
  Circle45.prototype.draw = function(radius, brightness) {
    ctx45.fillStyle = `hsla(${this.hue + randBetween(-180 * colorVariation45, 180 * colorVariation45)}deg, ${randBetween(50, 100)}%, ${brightness}%, ${randBetween(0.3, 0.6)})`;
    if (Math.random() < fillChance45) ctx45.fillCircle(this.x, this.y, radius * this.radiusRatio);
    
    ctx45.lineWidth = 2;
    if (Math.random() < outlineChance45) ctx45.strokeCircle(this.x, this.y, radius * this.radiusRatio);
  };
  let circle45Array = [];
  
  function draw45() {
    bands45 = Math.random() < 0.25 ? randBetween(5, 15) : randBetween(40, 100); // 25% chance to draw few bands, 75% chance to draw many bands
    radius45 = randBetween(100, 300);
    numCircles45 = Math.round(randBetween(10, 30));
    fillChance45 = randBetween(0.2, 1);
    outlineChance45 = Math.random() < 0.5 ? Math.random() * fillChance45 * 0.25 : 0; // 50% chance to have outline or no outline
    colorVariation45 = Math.random() * 0.25;
    
    ctx45.fillStyle = `hsl(${Math.random() * 360}deg, ${randBetween(50, 100)}%, ${randBetween(80, 100)}%)`;
    ctx45.fillRect(0, 0, canvas45.width, canvas45.height);
    
    circle45Array = [];
    for (let i = 0; i < numCircles45; i++) circle45Array.push(new Circle45());
    
    for (let i = 1; i <= bands45; i++) {
      let ratio = 1 - (i / bands45);
      let radius = radius45 * ratio;
      let brightness = ratio * 100;
      for (let j = 0; j < circle45Array.length; j++) circle45Array[j].draw(radius, brightness);
    }
  }
  draw45();
</script>
<canvas id = "canvas44" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas44()">Start/Stop</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps44Txt"></span></b></i></div>
<div class = "desc"><b><i>(1/22/2022)</i></b> "Spelunking" Move your cursor slowly around the screen to explore the cave. Another experiment with the <a href = "http://andreasaristidou.com/FABRIK.html" target = "_blank">FABRIK algorithm</a> to make creatures follow the cursor around slowly. They also lose brightness and eye glow the further the cursor is to give an effect like shining a flashlight.</div>
<hr><hr>
<script>
  const ctx44 = canvas44.getContext("2d");
  canvas44.width = canvas44.height = 1000;
  let canvas44Running = false;
  let canvas44Ratio = canvas44.width / 500;
  let canvas44Rect = canvas44.getBoundingClientRect();
  
  let chain44SenseRadius = 200;
  
  let Mouse44 = {
    down: false,
    x: -100,
    y: -100,
    onCanvas: false
  };
  
  function Chain44(anchorX, anchorY, totalLength, numSegments, orientation, thickness, easeSpeed) {
    this.anchor = {
      x: anchorX,
      y: anchorY
    };
    
    this.totalLength = totalLength;
    this.segmentLength = this.totalLength / numSegments;
    
    this.points = [];
    let cx = this.anchor.x;
    let cy = this.anchor.y;
    for (let i = 0; i < numSegments + 1; i++) {
      this.points.push({x: cx, y: cy});
      cx += this.segmentLength * Math.cos(toRad(orientation));
      cy += this.segmentLength * Math.sin(toRad(orientation));
    }
    
    this.end = {
      x: this.points[this.points.length - 1].x,
      y: this.points[this.points.length - 1].y
    };
    
    this.thickness = thickness;
    this.easeSpeed = easeSpeed;
  }
  Chain44.prototype.draw = function() {
    let dx = Mouse44.x - this.end.x;
    let dy = Mouse44.y - this.end.y;
    let distSq = (dx * dx) + (dy * dy);
    let ratio = 1 - (distSq / (canvas44.width * canvas44.width * 0.25));
    this.ratio = ratio;
    
    ctx44.lineWidth = this.thickness;
    ctx44.lineJoin = ctx44.lineCap = "round";
    ctx44.strokeStyle = `hsl(0deg, 0%, ${ratio * 4}%)`;
    ctx44.beginPath();
    for (let i = 0; i < this.points.length; i++) ctx44.lineTo(this.points[i].x, this.points[i].y);
    ctx44.stroke();
    
    ctx44.shadowColor = "white";
    ctx44.shadowBlur = ratio * 20;
    ctx44.fillStyle = `rgba(255, 255, 255, ${ratio})`;
    ctx44.fillCircle(this.end.x, this.end.y, this.thickness / 4);
    ctx44.shadowBlur = 0;
  };
  Chain44.prototype.update = function() {
    this.easeToPoint(Mouse44.x, Mouse44.y, this.easeSpeed);
  };
  Chain44.prototype.snapToPoint = function(x, y) {
    let oX = this.points[0].x;
    let oY = this.points[0].y;
    let cx = x;
    let cy = y;
    for (let i = this.points.length - 1; i >= 0; i--) {
      this.points[i].x = cx;
      this.points[i].y = cy;
      if (i !== 0) {
        let dx = this.points[i - 1].x - cx;
        let dy = this.points[i - 1].y - cy;
        let angle = Math.atan2(dy, dx);
        cx += this.segmentLength * Math.cos(angle);
        cy += this.segmentLength * Math.sin(angle);
      }
    }
    
    cx = oX;
    cy = oY;
    
    for (let i = 0; i < this.points.length; i++) {
      this.points[i].x = cx;
      this.points[i].y = cy;
      if (i !== this.points.length - 1) {
        let dx = this.points[i + 1].x - cx;
        let dy = this.points[i + 1].y - cy;
        let angle = Math.atan2(dy, dx);
        cx += this.segmentLength * Math.cos(angle);
        cy += this.segmentLength * Math.sin(angle);
      }
    }
    
    this.end.x = this.points[this.points.length - 1].x;
    this.end.y = this.points[this.points.length - 1].y;
  };
  Chain44.prototype.easeToPoint = function(x, y, t) {
    this.end.x = this.points[this.points.length - 1].x;
    this.end.y = this.points[this.points.length - 1].y;
    
    this.snapToPoint(((1 - t) * this.end.x) + (t * x), ((1 - t) * this.end.y) + (t * y));
  };
  let chain44Array = [];
  
  function randCanvas44EdgePos() {
    let s = Math.floor(Math.random() * 4);
    if (s === 0) return {x: Math.random() * canvas44.width, y: 0, a: 90}; // top
    if (s === 1) return {x: canvas44.width, y: Math.random() * canvas44.height, a: 180}; // right
    if (s === 2) return {x: Math.random() * canvas44.width, y: canvas44.height, a: 270}; // bottom
    return {x: 0, y: Math.random() * canvas44.height, a: 0}; // left
  }
  
  let lastFrame44Time = 0;
  let lastFps44DisplayTime = 1000;
  
  function frame44() {
    if (Date.now() - lastFps44DisplayTime >= 500) {
      fps44Txt.innerHTML = (1000 / (Date.now() - lastFrame44Time)).toFixed(1);
      lastFps44DisplayTime = Date.now();
    }
    lastFrame44Time = Date.now();
    
    ctx44.fillStyle = "black";
    ctx44.fillRect(0, 0, canvas44.width, canvas44.height);
    
    for (let i = 0; i < chain44Array.length; i++) {
      chain44Array[i].update();
      chain44Array[i].draw();
    }
    
    if (canvas44Running) requestAnimationFrame(frame44);
  }
  
  function reset44() {
    chain44Array = [];
    for (let i = 0; i < 100; i++) {
      let pos = randCanvas44EdgePos();
      chain44Array.push(new Chain44(
        pos.x, // anchorX
        pos.y, // anchorY
        randBetween(100, randBetween(200, 400)), // totalLength
        50,//Math.round(randBetween(3, 7)), // numSegments
        pos.a + 180, // orientation
        randBetween(15, 35), // thickness
        randBetween(0.03, 0.06) // easeSpeed
      ));
    }
    
    /*for (let i = 0; i < chain44Array.length; i++) {
      let a = Math.random() * 360;
      let d = 100;
      let lookX = chain44Array[i].anchor.x + (d * Math.cos(a));
      let lookY = chain44Array[i].anchor.y + (d * Math.sin(a));
      chain44Array[i].easeToPoint(lookX, lookY, 0.5);
    }*/
    
    if (!canvas44Running) frame44();
  }
  reset44();
  
  function startCanvas44() {
    if (canvas44Running) canvas44Running = false;
    else {
      canvas44Running = true;
      frame44();
    }
  }
  
  canvas44.addEventListener("mousemove", e => {
    if (!canvas44Running) return;
    canvas44Rect = canvas44.getBoundingClientRect();
    let eX = (e.clientX - canvas44Rect.left) * canvas44Ratio;
    let eY = (e.clientY - canvas44Rect.top) * canvas44Ratio;
    
    let onX = eX >= 0 && eX <= canvas44.width;
    let onY = eY >= 0 && eY <= canvas44.height
    Mouse44.onCanvas = onX && onY;
    
    if (Mouse44.onCanvas) {
      Mouse44.x = eX;
      Mouse44.y = eY;
    }
  });
</script>
<canvas id = "canvas43"></canvas>
<button onclick = "startCanvas43()">Start/Stop</button>
<button onclick = "reset43()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps43Txt"></span></b></i></div>
<div class = "desc"><b><i>(1/22/2022)</i></b> Simple black hole art/animation.</div>
<hr><hr>
<script>
  const ctx43 = canvas43.getContext("2d");
  canvas43.width = canvas43.height = 1000;
  let canvas43Running = false;
  
  let numPoints43 = 1000;
  let gravity43 = 5;
  let stepsPerFrame43 = 5;
  
  function Point43() {
    this.x = randBetween(-canvas43.width / 2, canvas43.width * 1.5);
    this.y = randBetween(-canvas43.height / 2, canvas43.height * 1.5);
    
    this.color = `hsla(${Math.random() * 360}deg, 100%, ${randBetween(50, 90)}%, 0.5)`;
  }
  Point43.prototype.render = function() {
    let dx = (canvas43.width / 2) - this.x;
    let dy = (canvas43.height / 2) - this.y;
    let angle = Math.atan2(dy, dx) + (Math.PI * 0.4) + randBetween(-0.3, 0.3);
    
    let lastX = this.x;
    let lastY = this.y;
    
    this.x += gravity43 * Math.cos(angle);
    this.y += gravity43 * Math.sin(angle);
    
    if ((dx * dx) + (dy * dy) < 100) {
      this.x = canvas43.width / 2;
      this.y = canvas43.height / 2;
      this.vx = 0;
      this.vy = 0;
    }
    
    ctx43.strokeStyle = this.color;
    ctx43.lineCap = ctx43.lineJoin = "round";
    ctx43.beginPath();
    ctx43.moveTo(lastX, lastY);
    ctx43.lineTo(this.x, this.y);
    ctx43.stroke();
  };
  let point43Array = [];
  
  let lastFrame43Time = 0;
  let lastFps43DisplayTime = 1000;
  
  function frame43() {
    if (Date.now() - lastFps43DisplayTime >= 500) {
      fps43Txt.innerHTML = (1000 / (Date.now() - lastFrame43Time)).toFixed(1);
      lastFps43DisplayTime = Date.now();
    }
    lastFrame43Time = Date.now();
    
    for (let j = 0; j < stepsPerFrame43; j++) {
      for (let i = 0; i < point43Array.length; i++) point43Array[i].render();
    }
    
    if (canvas43Running) requestAnimationFrame(frame43);
  }
  
  function reset43() {
    ctx43.fillStyle = "black";
    ctx43.fillRect(0, 0, canvas43.width, canvas43.height);
    
    point43Array = [];
    for (let i = 0; i < numPoints43; i++) point43Array.push(new Point43);
    
    if (!canvas43Running) frame43();
  }
  reset43();
  
  function startCanvas43() {
    if (canvas43Running) canvas43Running = false;
    else {
      canvas43Running = true;
      frame43();
    }
  }
</script>
<canvas id = "canvas42" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas42()">Start/Stop</button>
<button onclick = "reset42()">Regenerate</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps42Txt"></span></b></i></div>
<div><b><u>Circles:</u></b> <span id = "circles42Txt">1</span></div>
<br>
<div><b><u>Max Circles:</u></b> <span id = "maxCircles42Txt">1,000</span></div>
<input type = "range" min = "0" max = "10" step = "1" value = "0" id = "maxCircles42Range" oninput = "updateSettings42()">
<br>
<input type = "checkbox" id = "drawToFinish42Checkbox" oninput = "updateSettings42()">
<label for = "drawToFinish42Checkbox">Draw Immediately</label>
<div class = "desc"><b><i>(1/21/2022)</i></b> Circle generative art, using <a href = "https://www.dwitter.net/d/24732" target = "_blank">this</a> algorithm, the settings are randomized every generation.</div>
<hr><hr>
<script>
  const ctx42 = canvas42.getContext("2d");
  canvas42.width = canvas42.height = 1000;
  let canvas42Running = false;
  
  let maxCircle42Radius = 2000;
  let stepsPerFrame42 = 25;
  let hue42 = 0;
  let maxCircles42 = 1000;
  let hueVariation42 = 0.1;
  let brightness42 = 50;
  let brightnessVariation42 = 0.2;
  let opacity42 = 0.4;
  let circle42SizeRatio = 1;
  let outline42 = true;
  let fill42 = true;
  let drawToFinish42 = false;
  
  function Circle42() {
    if (circle42Array.length >= maxCircles42) return;
    
    this.x = Math.random() * canvas42.width;
    this.y = Math.random() * canvas42.height;
    
    let minDist = Infinity;
    for (let i = 0; i < circle42Array.length; i++) {
      let dx = circle42Array[i].x - this.x;
      let dy = circle42Array[i].y - this.y;
      let dist = Math.abs(Math.sqrt((dx * dx) + (dy * dy)) - circle42Array[i].radius);
      if (dist < minDist) minDist = dist;
    }
    if (minDist > maxCircle42Radius) minDist = maxCircle42Radius;
    if (circle42Array.length === 0) minDist = 2000;
    
    this.radius = minDist;
    
    circle42Array.push(this);
    
    this.draw();
  }
  Circle42.prototype.draw = function() {
    let h = hue42 + randBetween(-180 * hueVariation42, 180 * hueVariation42);
    let s = randBetween(50, 100);
    let l = 0;
    if (Math.random() >= 0.5) l = brightness42 * (1 - (Math.random() * brightnessVariation42));
    else l = ((100 - brightness42) * Math.random() * brightnessVariation42) + brightness42;
    
    ctx42.fillStyle = `hsla(${h}deg, ${s}%, ${l}%, ${opacity42})`;
    ctx42.strokeStyle = "black";
    ctx42.lineWidth = 1;
    
    ctx42.beginPath();
    ctx42.arc(this.x, this.y, this.radius * circle42SizeRatio, 0, Math.PI * 2);
    if (fill42) ctx42.fill();
    if (outline42) ctx42.stroke();
  };
  let circle42Array = [];
  
  let lastFrame42Time = 0;
  let lastFps42DisplayTime = 1000;
  
  function frame42() {
    if (Date.now() - lastFps42DisplayTime >= 500) {
      fps42Txt.innerHTML = (1000 / (Date.now() - lastFrame42Time)).toFixed(1);
      lastFps42DisplayTime = Date.now();
    }
    lastFrame42Time = Date.now();
    
    if (drawToFinish42) return;
    
    for (let i = 0; i < stepsPerFrame42; i++) new Circle42();
    
    circles42Txt.innerHTML = circle42Array.length.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    
    if (canvas42Running) requestAnimationFrame(frame42);
  }
  
  function reset42() {
    ctx42.fillStyle = "white";
    ctx42.fillRect(0, 0, canvas42.width, canvas42.height);
    
    hue42 = Math.random() * 360;
    hueVariation42 = Math.random() < 0.7 ? randBetween(0.2, 0.5) : Math.random(); // 70% chance to have less extreme values
    brightness42 = Math.random() < 0.7 ? randBetween(30, 60) : (Math.random() * 100); // 70% chance to have less extreme values
    brightnessVariation42 = Math.random();
    opacity42 = Math.random() < 0.5 ? randBetween(0.3, 0.6) : randBetween(0.6, 1); // 50% chance to be lighter or darker
    outline42 = Math.random() < 0.7; // 70% chance to have outline on
    if (outline42 && Math.random() < 0.1) fill42 = false; // If outline is on, 10% chance to have no fill
    else fill42 = true;
    maxCircle42Radius = Math.random() < 0.5 ? randBetween(50, 250) : randBetween(500, 1000); // 50% chance to generate smaller circles or bigger circles
    
    circle42Array = [];
    
    if (drawToFinish42) {
      while (circle42Array.length < maxCircles42) new Circle42();
    }
    else {
      for (let i = 0; i < stepsPerFrame42; i++) new Circle42();
    }
    
    circles42Txt.innerHTML = circle42Array.length.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  reset42();
  
  function startCanvas42() {
    if (canvas42Running) canvas42Running = false;
    else {
      canvas42Running = true;
      frame42();
    }
  }
  
  let maxCircles42RangeArray = [5, 10, 20, 30, 50, 100, 200, 300, 500, 750, 1000, 2000, 3000, 5000, 7000, 10000];
  maxCircles42Range.max = maxCircles42RangeArray.length - 1;
  maxCircles42Range.value = maxCircles42RangeArray.indexOf(1000);
  
  function updateSettings42() {
    maxCircles42 = maxCircles42RangeArray[Number(maxCircles42Range.value)];
    maxCircles42Txt.innerHTML = maxCircles42.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    
    let last = drawToFinish42;
    
    drawToFinish42 = drawToFinish42Checkbox.checked;
    
    if (!last && drawToFinish42) {
      while (circle42Array.length < maxCircles42) new Circle42();
    }
    else frame42();
  }
</script>
<canvas id = "canvas41"></canvas>
<button onclick = "startCanvas41()">Start/Stop</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps41Txt"></span></b></i></div>
<table>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Friction:</u></b> <span id = "friction41Txt">25</span>%</div>
      <input type = "range" min = "0" max = "100" value = "25" step = "5" id = "friction41Range" oninput = "updateSettings41(false)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Bug Random Wander Factor:</u></b> <span id = "randTurn41Txt">10</span>%</div>
      <input type = "range" min = "0" max = "100" value = "10" step = "5" id = "randTurn41Range" oninput = "updateSettings41(false)">
    </td>
    <td style = "padding: 10px" rowspan = "5">
      <button style = "border-radius: 10px" onclick = "resetSettings41()"><b><i>Reset Settings</i></b></button>
      <br><br>
      <button onclick = "reset41(false)">Reset Bugs Randomly</button>
      <br><br>
      <button onclick = "reset41(true)">Reset Bugs to Circle</button>
      <br><br>
      <button onclick = "randomizeBug41Following()">Randomize Bug Following</button>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Number of Bugs:</u></b> <span id = "numBugs41Txt">1000</span></div>
      <input type = "range" min = "0" max = "10" value = "0" step = "1" id = "numBugs41Range" oninput = "updateSettings41(true)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Bug Size:</u></b> <span id = "bug41SizeTxt">3</span>px</div>
      <input type = "range" min = "1" max = "20" value = "3" step = "1" id = "bug41SizeRange" oninput = "updateSettings41(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "colorBugs41Checkbox" oninput = "updateSettings41(false)">
      <label for = "colorBugs41Checkbox">Colored Bugs</label>
    </td>
    <td style = "padding: 10px">
      <div><b><u>Bug Hue:</u></b> <span id = "bug41HueTxt">0</span>&deg;</div>
      <input type = "range" min = "0" max = "360" value = "0" step = "10" id = "bug41HueRange" oninput = "updateSettings41(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "reverseContrast41Checkbox" oninput = "updateSettings41(false)">
      <label for = "reverseContrast41Checkbox">Reverse Contrast</label>
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(1/20/2022)</i></b> An attempt to replicate the design in <a href = "https://www.dwitter.net/d/24687" target = "_blank">this</a>, with random bugs following each other, but it just devolves into a blob in the middle quickly.<br><b><i>(1/21/2022)</i></b> I added a trailing effect which greatly improves how cool it looks and made each bug be assigned another random bug to follow -- without worrying about "each bug follows one bug, each bug is only followed by one bug." I also added reset buttons and made the bugs turn a little bit from directly facing their target for more random behavior. Later I made the bugs accelerate towards their targets instead of just moving towards it, with some friction, and I also added settings for everything and sliders.<br><b><i>Update: (Later that day)</i></b> I finalized everything and added more settings and color.</div>
<hr><hr>
<script>
  const ctx41 = canvas41.getContext("2d");
  canvas41.width = canvas41.height = 1000;
  let canvas41Running = false;
  
  let friction41 = 0.25;
  let randTurn41 = 0.1;
  let bug41Size = 3;
  let clearRate41 = 0.1;
  let numBugs41 = 1000;
  let stepsPerFrame41 = 5;
  let edgeSize41 = 5;
  let reverseContrast41 = false;
  let colorBugs41 = false;
  let bug41Hue = 0;
  
  function Bug41(x, y) {
    this.x = x;
    this.y = y;
    
    this.lastX = this.x;
    this.lastY = this.y;
    
    this.vx = 0;
    this.vy = 0;
    
    this.brightness = Math.random();
    this.hue = bug41Hue;
  }
  Bug41.prototype.update = function() {
    for (let i = 0; i < stepsPerFrame41; i++) {
      let dx = this.following.x - this.x;
      let dy = this.following.y - this.y;
      let angle = Math.atan2(dy, dx) + (Math.random() * Math.PI * randTurn41 * randSign()); // Get angle to bug it's following
      
      this.vx += Math.cos(angle); // Accelerate
      this.vy += Math.sin(angle);
    }
  };
  Bug41.prototype.move = function() {
    this.lastX = this.x;
    this.lastY = this.y;
    
    this.vx *= 1 - friction41; // Dampen velocity
    this.vy *= 1 - friction41;
    
    this.x += this.vx;
    this.y += this.vy;
    
    if (this.x > canvas41.width - edgeSize41) { // Stop at right edge
      this.x = canvas41.width - edgeSize41;
      this.vx = 0;
    }
    else if (this.x < edgeSize41) { // Stop at left edge
      this.x = edgeSize41;
      this.vx = 0;
    }
    if (this.y > canvas41.height - edgeSize41) { // Stop at bottom edge
      this.y = canvas41.height - edgeSize41;
      this.vy = 0;
    }
    else if (this.y < edgeSize41) { // Stop at top edge
      this.y = edgeSize41;
      this.vy = 0;
    }
  };
  Bug41.prototype.draw = function() {
    if (colorBugs41) ctx41.strokeStyle = reverseContrast41 ? `hsl(${bug41Hue}deg, 100%, ${(this.brightness * 40) + 60}%)` : `hsl(${bug41Hue}deg, 100%, ${this.brightness * 40}%)`;
    else ctx41.strokeStyle = reverseContrast41 ? "white" : "black";
    ctx41.lineCap = ctx41.lineJoin = "round";
    ctx41.lineWidth = bug41Size;
    ctx41.beginPath();
    ctx41.moveTo(this.lastX, this.lastY);
    ctx41.lineTo(this.x, this.y);
    ctx41.stroke();
  };
  let bug41Array = [];
  
  function randomizeBug41Following() {
    for (let i = 0; i < bug41Array.length; i++) {
      let j = Math.floor(Math.random() * bug41Array.length);
      while (j === i) j = Math.floor(Math.random() * bug41Array.length);
      bug41Array[i].following = bug41Array[j]; // Get random index, different from itself, and follow it
    }
  }
  
  let lastFrame41Time = 0;
  let lastFps41DisplayTime = 1000;
  
  function frame41() {
    if (Date.now() - lastFps41DisplayTime >= 500) {
      fps41Txt.innerHTML = (1000 / (Date.now() - lastFrame41Time)).toFixed(1);
      lastFps41DisplayTime = Date.now();
    }
    lastFrame41Time = Date.now();
    
    ctx41.fillStyle = reverseContrast41 ? `rgba(0, 0, 0, ${clearRate41})`: `rgba(255, 255, 255, ${clearRate41})`;
    ctx41.fillRect(0, 0, canvas41.width, canvas41.height);
    
    for (let i = 0; i < bug41Array.length; i++) {
      bug41Array[i].update();
      bug41Array[i].move();
      bug41Array[i].draw();
    }
    
    if (canvas41Running) requestAnimationFrame(frame41);
  }
  frame41();
  
  function reset41(circle) {
    ctx41.fillStyle = reverseContrast41 ? "black" : "white";
    ctx41.fillRect(0, 0, canvas41.width, canvas41.height);
    
    bug41Array = [];
    for (let i = 0; i < numBugs41; i++) {
      let a = (i / numBugs41) * Math.PI * 2;
      let bug;
      if (circle) {
        bug = new Bug41(
          (canvas41.width / 2) + ((canvas41.width / 2) * Math.cos(a)), // x
          (canvas41.height / 2) + ((canvas41.height / 2) * Math.sin(a)) // y
        );
      }
      else {
        bug = new Bug41(
          Math.random() * canvas41.width, // x
          Math.random() * canvas41.height // y
        );
      }
      bug41Array.push(bug);
    }
    
    randomizeBug41Following();
    
    if (!canvas41Running) frame41();
  }
  
  reset41(false);
  
  function startCanvas41() {
    if (canvas41Running) canvas41Running = false;
    else {
      canvas41Running = true;
      frame41();
    }
  }
  
  let numBugs41RangeArray = [2, 3, 4, 5, 10, 25, 50, 100, 200, 300, 400, 500, 750, 1000, 1500, 2000];
  numBugs41Range.max = numBugs41RangeArray.length - 1;
  numBugs41Range.value = numBugs41RangeArray.indexOf(1000);
  
  function updateSettings41(reset) {
    friction41 = Number(friction41Range.value) / 100;
    friction41Txt.innerHTML = friction41Range.value;
    
    randTurn41 = Number(randTurn41Range.value) / 100;
    randTurn41Txt.innerHTML = randTurn41Range.value;
    
    bug41Size = bug41SizeTxt.innerHTML = Number(bug41SizeRange.value);
    
    numBugs41 = numBugs41Txt.innerHTML = numBugs41RangeArray[Number(numBugs41Range.value)];
    
    colorBugs41 = colorBugs41Checkbox.checked;
    
    bug41Hue = bug41HueTxt.innerHTML = Number(bug41HueRange.value);
    
    reverseContrast41 = reverseContrast41Checkbox.checked;
    
    if (reset) reset41(false);
  }
  
  function resetSettings41() {
    friction41Range.value = 25;
    randTurn41Range.value = 10;
    bug41SizeRange.value = 3;
    numBugs41Range.value = numBugs41RangeArray.indexOf(1000);
    colorBugs41Checkbox.checked = false;
    bug41HueRange.value = 0;
    reverseContrast41Checkbox.checked = false;
    
    updateSettings41(true);
  }
</script>
<canvas id = "canvas40"></canvas>
<button onclick = "startCanvas40()">Start/Stop</button>
<button onclick = "randomizeColors40()">Change Colors</button>
<button onclick = "randomizeRuleString40()">Change Rule</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps40Txt"></span></b></i></div>
<div class = "desc"><b><i>(1/19/2022)</i></b> (Somewhat underwhelming) 1D Cellular Automata scrolling viewer, with randomly changing rule and random colors.</div>
<hr><hr>
<script>
  const ctx40 = canvas40.getContext("2d");
  canvas40.width = canvas40.height = 1000;
  let canvas40Running = false;
  
  /*let colors40 = [ // "High contrast colors" list
    "#ffb300",
    "#803e75",
    "#ff6800",
    "#a6bdd7",
    "#c10020",
    "#cea262",
    "#817066",
    "#007d34",
    "#f6768e",
    "#232c16"
  ];*/
  
  let grid40 = [];
  let gridSize40 = 100;
  let colorOn40 = "";
  let colorOff40 = "";
  let ruleString40 = "01101110"; // 1D Cellular Automata rule system from Wolfram's "A New Kind of Science"
  let timer40 = 0;
  
  function reset40() {
    grid40 = [];
    for (let x = 0; x < gridSize40; x++) {
      let row = [];
      for (let y = 0; y < gridSize40; y++) {
        row.push(Math.random() >= 0.5); // Fill grid with random on/off
      }
      grid40.push(row);
    }
    
    randomizeRuleString40();
    
    /*let colorCopy = [];
    for (let i = 0; i < colors40.length; i++) colorCopy.push(colors40[i]);
    colorOn40 = colorCopy.splice(Math.floor(Math.random() * colorCopy.length), 1);
    colorOff40 = colorCopy.splice(Math.floor(Math.random() * colorCopy.length), 1);*/
    randomizeColors40();

    
    if (!canvas40Running) frame40();
  }
  
  function randomizeColors40() {
    colorOn40 = `hsl(${Math.random() * 360}deg, 100%, ${randBetween(35, 50)}%)`;
    colorOff40 = `hsl(${Math.random() * 360}deg, 100%, ${randBetween(50, 65)}%)`;
  }
  
  function updateGrid40() {
    ctx40.clearRect(0, 0, canvas40.width, canvas40.height);
    
    let tileSize = canvas40.width / gridSize40;
    
    for (let y = 1; y < gridSize40; y++) {
      for (let x = 0; x < gridSize40; x++) {
        grid40[x][y - 1] = grid40[x][y]; // Move each row up
        ctx40.fillStyle = grid40[x][y - 1] ? colorOn40 : colorOff40;
        ctx40.fillRect(x * tileSize, (y - 1) * tileSize, tileSize, tileSize); // Draw current cell in new position
      }
      
      if (y === gridSize40 - 1) { // Update last row
        let nextRow = [];
        for (let x = 0; x < gridSize40; x++) {
          let neighbors = "";
          neighbors += grid40[(x - 1 + gridSize40) % gridSize40][y] ? "1" : "0"; // Left neighbor
          neighbors += grid40[x][y] ? "1" : "0"; // Itself
          neighbors += grid40[(x + 1) % gridSize40][y] ? "1" : "0"; // Right neighbor
          nextRow.push(ruleString40[parseInt(neighbors, 2)] === "1");
        }
        for (let x = 0; x < gridSize40; x++) {
          grid40[x][y] = nextRow[x];
          ctx40.fillStyle = grid40[x][y] ? colorOn40 : colorOff40;
          ctx40.fillRect(x * tileSize, y * tileSize, tileSize, tileSize); // Draw current cell
        }
      }
    }
  }
  
  function randomizeRuleString40() {
    ruleString40 = "";
    for (let i = 0; i < 8; i++) ruleString40 += Math.random() >= 0.5 ? "1" : "0";
    for (let x = 0; x < gridSize40; x++) grid40[x][gridSize40 - 1] = Math.random() >= 0.5;
  }
  
  let lastFrame40Time = 0;
  let lastFps40DisplayTime = 1000;
  
  function frame40() {
    if (Date.now() - lastFps40DisplayTime >= 500) {
      fps40Txt.innerHTML = (1000 / (Date.now() - lastFrame40Time)).toFixed(1);
      lastFps40DisplayTime = Date.now();
    }
    lastFrame40Time = Date.now();
    
    timer40++;
    if (timer40 > gridSize40 + 1) {
      timer40 = 0;
      randomizeRuleString40();
    }
    
    updateGrid40();
    
    if (canvas40Running) requestAnimationFrame(frame40);
  }
  reset40();
  
  function startCanvas40() {
    if (canvas40Running) canvas40Running = false;
    else {
      canvas40Running = true;
      frame40();
    }
  }
</script>
<canvas id = "canvas39" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas39()">Start/Stop</button>
<button onclick = "reset39()">Reset</button>
<br>
<input type = "checkbox" id = "turbo39Checkbox" oninput = "turbo39 = this.checked">
<label for = "turbo39Checkbox">Turbo</label>
<div><b><u>Number of Lines:</u></b> <span id = "numLines39Txt">0</span></div>
<div><b><u>Current Ratio:</u></b> <span id = "currRatio39Txt">0</span>% (Ideal: 33.33333%)</div>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps39Txt"></span></b></i></div>
<div class = "desc"><b><i>(12/20/2021)</i></b> Simple simulation I made to replicate the first problem in <a href = "https://www.youtube.com/watch?v=mZBwsm6B280" target = "_blank">this</a> Numberphile video, demonstrating the 1/3 probability that a random chord drawn in a circle will have a greater side length than its inscribed triangle.</div>
<hr><hr>
<script>
  const ctx39 = canvas39.getContext("2d");
  canvas39.width = canvas39.height = 1000;
  let canvas39Running = false;
  
  let radius39 = canvas39.width / 2;
  let lineWidth39 = 1;
  let opacity39 = 0.5;
  let targetLen39 = Math.sqrt(3) * radius39;
  let targetLen39Sq = targetLen39 * targetLen39;
  let numGreater39 = 0;
  let numLess39 = 0;
  let stepsPerFrame39 = 10;
  let turbo39 = false;
  
  function drawRandChord39() {
    stepsPerFrame39 = turbo39 ? 1000 : 10;
    for (let i = 0; i < stepsPerFrame39; i++) {
      let a1 = Math.random() * Math.PI * 2;
      let x1 = radius39 + (radius39 * Math.cos(a1));
      let y1 = radius39 + (radius39 * Math.sin(a1));
      
      let a2 = Math.random() * Math.PI * 2;
      let x2 = radius39 + (radius39 * Math.cos(a2));
      let y2 = radius39 + (radius39 * Math.sin(a2));
      
      let dx = x2 - x1;
      let dy = y2 - y1;
      let distSq = (dx * dx) + (dy * dy);
      
      let greater = distSq > targetLen39Sq;
      if (greater) numGreater39++;
      else numLess39++;
      
      ctx39.globalAlpha = opacity39;
      ctx39.strokeStyle = greater ? "lime" : "red";
      ctx39.lineWidth = lineWidth39;
      ctx39.beginPath();
      ctx39.moveTo(x1, y1);
      ctx39.lineTo(x2, y2);
      ctx39.stroke();
    }
    
    numLines39Txt.innerHTML = (numGreater39 + numLess39).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    currRatio39Txt.innerHTML = ((numGreater39 / (numGreater39 + numLess39)) * 100).toFixed(5);
  }
  
  let lastFrame39Time = 0;
  let lastFps39DisplayTime = 1000;
  function frame39() {
    if (Date.now() - lastFps39DisplayTime >= 500) {
      fps39Txt.innerHTML = (1000 / (Date.now() - lastFrame39Time)).toFixed(1);
      lastFps39DisplayTime = Date.now();
    }
    lastFrame39Time = Date.now();
    
    drawRandChord39();
    
    if (canvas39Running) requestAnimationFrame(frame39);
  }
  
  function startCanvas39() {
    if (canvas39Running) canvas39Running = false;
    else {
      canvas39Running = true;
      frame39();
    }
  }
  
  function reset39() {
    ctx39.globalAlpha = 1;
    ctx39.fillStyle = "black";
    ctx39.fillRect(0, 0, canvas39.width, canvas39.height);
    numGreater39 = 0;
    numLess39 = 0;
    drawRandChord39();
  }
  reset39();
  frame39();
</script>
<canvas id = "canvas38" style = "width: 400px; height: 400px"></canvas>
<button onclick = "drawPattern38()">Redraw</button>
<div><b><u>Grid Size:</u></b> <span id = "gridSize38Txt">25&times;25</span></div>
<input type = "range" min = "5" max = "50" step = "5" value = "25" id = "gridSize38Range" oninput = "updateSettings38()">
<div><b><u>Randomness:</u></b> <span id = "randomness38Txt">100</span>%</div>
<input type = "range" min = "0" max = "100" step = "5" value = "100" id = "randomness38Range" oninput = "updateSettings38()">
<div><b><u>Selected Lines:</u></b></div>
<input type = "checkbox" id = "drawnLines38Checkbox1" oninput = "updateSettings38()" CHECKED>
<label for = "drawnLines38Checkbox1">Horizontal</label>
<br>
<input type = "checkbox" id = "drawnLines38Checkbox2" oninput = "updateSettings38()">
<label for = "drawnLines38Checkbox2">Vertical</label>
<br>
<input type = "checkbox" id = "drawnLines38Checkbox3" oninput = "updateSettings38()" CHECKED>
<label for = "drawnLines38Checkbox3"><b>/</b> Diagonal</label>
<br>
<input type = "checkbox" id = "drawnLines38Checkbox4" oninput = "updateSettings38()" CHECKED>
<label for = "drawnLines38Checkbox4"><b>\</b> Diagonal</label>
<div class = "desc"><b><i>(12/9/2021)</i></b> Random Hitomezashi stitch patterns, based on <a href = "https://www.youtube.com/watch?v=JbfhzlMk2eY" target = "_blank">this</a> Numberphile video. I changed the algorithm some to add both sets of diagonal lines across the square.<br><b><i>(12/10/2021)</i></b> Added sliders and settings.<br><b><i>(12/11/2021)</i></b> I realized the way I was drawing the diagonal lines was a bit off, which didn't make a difference unless you turned the randomness down. But now it's fixed and everything is drawing correctly and evenly, even with 0% randomness. The code's an absolute mess and there's definitely a better way to do this algorithm, but somehow it works so I'm not gonna touch it.</div>
<hr><hr>
<script>
  const ctx38 = canvas38.getContext("2d");
  canvas38.width = canvas38.height = 1000;
  
  let gridSize38 = 25;
  let tileSize38 = canvas38.width / gridSize38;
  let randomness38 = 1;
  let lineWidth38 = 5;
  let drawnLines38 = [1, 3, 4];
  
  function drawPattern38() {
    let l1, l2;
    if (Math.random() >= 0.5) {
      l1 = randBetween(20, 40);
      l2 = randBetween(60, 80);
    }
    else {
      l2 = randBetween(20, 40);
      l1 = randBetween(60, 80);
    }
    let h1 = Math.random() * 360;
    let h2 = h1 + (randBetween(60, 180) * randSign());
    h2 = (h2 + 360) % 360;
    ctx38.fillStyle = `hsl(${h1}deg, 100%, ${l1}%)`;
    ctx38.strokeStyle = `hsl(${h2}deg, 100%, ${l2}%)`;
    ctx38.fillRect(0, 0, canvas38.width, canvas38.height);
    
    tileSize38 = canvas38.width / gridSize38;
    
    ctx38.lineWidth = lineWidth38;
    ctx38.lineCap = ctx38.lineJoin = "round";
    
    if (drawnLines38.includes(1)) { // Draw dashed columns
      for (let x = 0; x <= gridSize38; x++) {
        let cy = rand38() ? 1 : 0;
        
        while (cy <= gridSize38) {
          ctx38.beginPath();
          ctx38.moveTo(x * tileSize38, cy * tileSize38);
          ctx38.lineTo(x * tileSize38, (cy + 1) * tileSize38);
          ctx38.stroke();
          ctx38.stroke(); // Draw twice to fix visual blurring
          
          cy += 2;
        }
      }
    }
    
    if (drawnLines38.includes(2)) { // Draw dashed rows
      for (let y = 0; y <= gridSize38; y++) {
        let cx = rand38() ? 1 : 0;
        
        while (cx <= gridSize38) {
          ctx38.beginPath();
          ctx38.moveTo(cx * tileSize38, y * tileSize38);
          ctx38.lineTo((cx + 1) * tileSize38, y * tileSize38);
          ctx38.stroke();
          ctx38.stroke(); // Draw twice to fix visual blurring
          
          cx += 2;
        }
      }
    }
    
    if (drawnLines38.includes(3)) { // Draw BL - TR diagonals ( / )
      // First half
      let offset = false;
      for (let i = 0; i <= gridSize38; i++) {
        offset = !offset;
        let cx = 0;
        let cy = 0;
        if (!offset) {
          cx = rand38() ? 1 : 0;
          cy = i - cx;
        }
        else {
          cx = (rand38() ? 1 : 0) + 1;
          cy = i - cx;
        }
        while (cx <= gridSize38 && cy <= gridSize38) {
          ctx38.beginPath();
          ctx38.moveTo(cx * tileSize38, cy * tileSize38);
          ctx38.lineTo((cx + 1) * tileSize38, (cy - 1) * tileSize38);
          ctx38.stroke();
          ctx38.stroke(); // Draw twice to fix visual blurring
          
          cx += 2;
          cy -= 2;
        }
      }
      // Second half
      for (let i = 1; i <= gridSize38; i++) {
        let r = (rand38() ? 1 : 0) + (offset ? 1 : 0);
        let cy = gridSize38 - r;
        let cx = i + r;
        while (cx <= gridSize38 && cy <= gridSize38) {
          ctx38.beginPath();
          ctx38.moveTo(cx * tileSize38, cy * tileSize38);
          ctx38.lineTo((cx + 1) * tileSize38, (cy - 1) * tileSize38);
          ctx38.stroke();
          ctx38.stroke(); // Draw twice to fix visual blurring
          
          cx += 2;
          cy -= 2;
        }
      }
    }
    
    if (drawnLines38.includes(4)) { // Draw BR - TL diagonals ( \ )
      // First half
      for (let i = 0; i <= gridSize38; i++) {
        let r = rand38() ? 1 : 0;
        let cx = gridSize38 - r;
        let cy = gridSize38 - i - r + 1;
        while (cx >= 0 && cy >= 0) {
          ctx38.beginPath();
          ctx38.moveTo(cx * tileSize38, cy * tileSize38);
          ctx38.lineTo((cx - 1) * tileSize38, (cy - 1) * tileSize38);
          ctx38.stroke();
          ctx38.stroke(); // Draw twice to fix visual blurring
          
          cx -= 2;
          cy -= 2;
        }
      }
      // Second half
      let offset = false;
      for (let i = 1; i <= gridSize38; i++) {
        offset = !offset;
        let r = rand38() ? 1 : 0 - (offset ? 1 : 0)
        let cx = gridSize38 - i - r;
        let cy = gridSize38 - r + 1;
        while (cx >= 0 && cy >= 0) {
          ctx38.beginPath();
          ctx38.moveTo(cx * tileSize38, cy * tileSize38);
          ctx38.lineTo((cx - 1) * tileSize38, (cy - 1) * tileSize38);
          ctx38.stroke();
          ctx38.stroke(); // Draw twice to fix visual blurring
          
          cx -= 2;
          cy -= 2;
        }
      }
    }
  }
  drawPattern38();
  
  function rand38() {
    return Math.random() < (randomness38 * 0.5);
  }
  
  function updateSettings38() {
    drawnLines38 = [];
    if (drawnLines38Checkbox1.checked) drawnLines38.push(1);
    if (drawnLines38Checkbox2.checked) drawnLines38.push(2);
    if (drawnLines38Checkbox3.checked) drawnLines38.push(3);
    if (drawnLines38Checkbox4.checked) drawnLines38.push(4);
    
    gridSize38 = Number(gridSize38Range.value);
    gridSize38Txt.innerHTML = gridSize38 + "&times;" + gridSize38;
    
    randomness38 = Number(randomness38Range.value) / 100;
    randomness38Txt.innerHTML = randomness38Range.value;
    
    drawPattern38();
  }
</script>
<canvas id = "canvas37" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas37()">Start/Stop</button>
<button onclick = "reset37(true)">Reset and Clear</button>
<button onclick = "reset37(false)">Spawn New Walkers</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps37Txt"></span></b></i></div>
<div><b><u>Walker Alignment:</u></b> <span id = "turnRandomlyChance37Txt">50</span>%</div>
<input type = "range" min = "0" max = "100" step = "5" value = "50" id = "turnRandomlyChance37Range" oninput = "updateSettings37(false)">
<div><b><u>Number of Walkers:</u></b> <span id = "numWalkers37Txt">100</span></div>
<input type = "range" min = "0" max = "10" step = "1" value = "0" id = "numWalkers37Range" oninput = "updateSettings37(true)">
<div class = "desc"><b><i>(12/6/2021)</i></b> Aligned random walker generative art - a line of random walkers are spawned at the bottom with alignment towards the top and a chance to walk in a random direction, making colorful streaks across the screen. I could add sliders later but I don't want to right now.<br><b><i>(12/7/2021)</i></b> Added sliders and buttons.</div>
<hr><hr>
<script>
  const ctx37 = canvas37.getContext("2d");
  canvas37.width = canvas37.height = 1000;
  let canvas37Running = false;
  
  let turnRandomlyChance37 = 0.5;
  let lineWidth37 = 1;
  let hue37 = 0;
  let numWalkers37 = 100;
  let stepsPerFrame37 = 25;
  let walker37StepSize = 1;
  let randAngle37 = 5;
  
  function Walker37(x, y, directionBias, color) {
    this.x = x;
    this.y = y;
    this.directionBias = directionBias;
    this.color = color;
  }
  Walker37.prototype.walk = function() {
    let lastX = this.x;
    let lastY = this.y;
    
    let rand = Math.random();
    if (Math.random() >= turnRandomlyChance37) rand *= Math.random(); // Chance to either align, or just turn randomly
    let angle = this.directionBias + (rand * Math.PI * 2 * randSign());
    let vel = walker37StepSize * randBetween(0.5, 1);
    
    this.x += vel * Math.cos(angle);
    this.y += vel * Math.sin(angle);
    
    if (this.x > canvas37.width) this.x = lastX = 0;
    else if (this.x < 0) this.x = lastX = canvas37.width;
    if (this.y > canvas37.height) this.y = canvas37.height;
    
    ctx37.strokeStyle = this.color;
    ctx37.lineWidth = lineWidth37;
    ctx37.lineCap = ctx37.lineJoin = "round";
    ctx37.beginPath();
    ctx37.moveTo(lastX, lastY);
    ctx37.lineTo(this.x, this.y);
    ctx37.stroke();
  };
  let walker37Array = [];
  
  function reset37(clear) {
    if (clear) {
      ctx37.fillStyle = "black";
      ctx37.fillRect(0, 0, canvas37.width, canvas37.height);
    }
    
    hue37 = Math.random() * 360;
    
    walker37Array = [];
    for (let i = 0; i < numWalkers37; i++) {
      let _i = i + randBetween(0.25, 0.75);
      let x = ((_i + 0.5) / numWalkers37) * canvas37.width;
      let color = `hsl(${hue37 + randBetween(-30, 30)}deg, ${randBetween(70, 100)}%, ${randBetween(30, 60)}%)`;
      walker37Array.push(new Walker37(x, canvas37.height, toRad(270 + randBetween(-randAngle37, randAngle37)), color));
    }
  }
  reset37(true);
  
  let lastFrame37Time = 0;
  let lastFps37DisplayTime = 1000;
  function frame37() {
    if (Date.now() - lastFps37DisplayTime >= 500) {
      fps37Txt.innerHTML = (1000 / (Date.now() - lastFrame37Time)).toFixed(1);
      lastFps37DisplayTime = Date.now();
    }
    lastFrame37Time = Date.now();
    
    for (let j = 0; j < stepsPerFrame37; j++) {
      for (let i = 0; i < walker37Array.length; i++) walker37Array[i].walk();
    }
    
    if (canvas37Running) requestAnimationFrame(frame37);
  }
  frame37();
  
  function startCanvas37() {
    if (canvas37Running) canvas37Running = false;
    else {
      canvas37Running = true;
      frame37();
    }
  }
  
  let numWalkers37RangeArray = [1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100, 125, 150, 200, 300];
  numWalkers37Range.max = numWalkers37RangeArray.length - 1;
  numWalkers37Range.value = numWalkers37RangeArray.indexOf(200);
  
  function updateSettings37(reset) {
    turnRandomlyChance37 = 1 - (Number(turnRandomlyChance37Range.value) / 100);
    turnRandomlyChance37Txt.innerHTML = turnRandomlyChance37Range.value;
    
    numWalkers37 = numWalkers37Txt.innerHTML = numWalkers37RangeArray[Number(numWalkers37Range.value)];
    
    if (reset) reset37(true);
  }
</script>
<canvas id = "canvas36" style = "width: 500px; height: 500px"></canvas>
<button onclick = "splitShapes36(1)">Split Corners</button>
<button onclick = "splitShapes36(2)">Split Edges</button>
<button onclick = "splitShapes36(3)">Split Random</button>
<button onclick = "reset36()">Reset</button>
<div><b><u>Splits:</u></b> <span id = "currLevel36Txt">1</span> level<span id = "plural36Txt1"></span></div>
<div class = "desc"><b><i>(12/2/2021)</i></b> Another variation on fracture, this time combining both triangles and quadrilaterals.</div>
<hr><hr>
<script>
  const ctx36 = canvas36.getContext("2d");
  canvas36.width = canvas36.height = 2000;
  
  let currLevel36 = 1;
  let maxLevel36 = 7;
  let hueVariation36 = 0.1;
  let outline36 = true;
  let fill36 = true;
  let lineWidth36 = 2;
  let reverseContrast36 = false;
  
  function Shape36(points, hue) {
    this.points = points;
    this.isTriangle = this.points.length === 3;
    this.hue = hue;
    this.draw();
  }
  Shape36.prototype.draw = function() {
    let color = `hsl(${this.hue}deg, 100%, 50%)`;
    let noColor = reverseContrast36 ? "white" : "black";
    ctx36.fillStyle = fill36 ? color : noColor;
    ctx36.strokeStyle = outline36 ? color : noColor;
    ctx36.lineWidth = lineWidth36;
    
    ctx36.beginPath();
    ctx36.moveTo(this.points[this.points.length - 1].x, this.points[this.points.length - 1].y);
    for (let i = 0; i < this.points.length; i++) {
      ctx36.lineTo(this.points[i].x, this.points[i].y);
    }
    
    if (fill36) ctx36.fill();
    ctx36.stroke();
  };
  Shape36.prototype.split = function(connectCorners) {
    shape36Array.splice(shape36Array.indexOf(this), 1);
    
    if (this.isTriangle) {
      let a = this.points[0];
      let b = this.points[1];
      let c = this.points[2];
      let m = {x: (a.x + b.x + c.x) / 3, y: (a.y + b.y + c.y) / 3};
      if (connectCorners) {
        shape36Array.push(new Shape36([a, b, m], this.randHue()));
        shape36Array.push(new Shape36([b, c, m], this.randHue()));
        shape36Array.push(new Shape36([c, a, m], this.randHue()));
      }
      else {
        let ab = this.midpoint(a, b);
        let bc = this.midpoint(b, c);
        let ca = this.midpoint(c, a);
        shape36Array.push(new Shape36([a, ab, m, ca], this.randHue()));
        shape36Array.push(new Shape36([b, bc, m, ab], this.randHue()));
        shape36Array.push(new Shape36([c, ca, m, bc], this.randHue()));
      }
    }
    else {
      let a = this.points[0];
      let b = this.points[1];
      let c = this.points[2];
      let d = this.points[3];
      let m = {x: (a.x + b.x + c.x + d.x) / 4, y: (a.y + b.y + c.y + d.y) / 4};
      if (connectCorners) {
        shape36Array.push(new Shape36([a, b, m], this.randHue()));
        shape36Array.push(new Shape36([b, c, m], this.randHue()));
        shape36Array.push(new Shape36([c, d, m], this.randHue()));
        shape36Array.push(new Shape36([d, a, m], this.randHue()));
      }
      else {
        let ab = this.midpoint(a, b);
        let bc = this.midpoint(b, c);
        let cd = this.midpoint(c, d);
        let da = this.midpoint(d, a);
        shape36Array.push(new Shape36([a, ab, m, da], this.randHue()));
        shape36Array.push(new Shape36([b, bc, m, ab], this.randHue()));
        shape36Array.push(new Shape36([c, cd, m, bc], this.randHue()));
        shape36Array.push(new Shape36([d, da, m, cd], this.randHue()));
      }
    }
  };
  Shape36.prototype.randHue = function() {
    let hue = this.hue + randBetween(-180 * hueVariation36, 180 * hueVariation36);
    return (hue + 360) % 360;
  };
  Shape36.prototype.midpoint = function(p1, p2) {
    return {x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2};
  };
  let shape36Array = [];
  
  function reset36() {
    ctx36.fillStyle = reverseContrast36 ? "black" : "white";
    ctx36.fillRect(0, 0, canvas36.width, canvas36.height);
    
    shape36Array = [];
    currLevel36 = 1;
    
    let a = {x: 0, y: 0};
    let b = {x: canvas36.width, y: 0};
    let c = {x: canvas36.width, y: canvas36.height};
    let d = {x: 0, y: canvas36.height};
    shape36Array.push(new Shape36([a, b, c, d], Math.random() * 360));
    
    currLevel36Txt.innerHTML = "1";
    plural36Txt1.innerHTML = "";
  }
  reset36();
  
  function splitShapes36(splitMode) {
    if (currLevel36 >= maxLevel36) {
      redrawShapes36();
      return;
    }
    
    ctx36.fillStyle = reverseContrast36 ? "black" : "white";
    ctx36.fillRect(0, 0, canvas36.width, canvas36.height);
    
    currLevel36++;
    
    let copy = [];
    for (let i = 0; i < shape36Array.length; i++) copy.push(shape36Array[i]);
    for (let i = 0; i < copy.length; i++) copy[i].split(splitMode === 1 ? true : splitMode === 2 ? false : Math.random() >= 0.5);
    
    currLevel36Txt.innerHTML = currLevel36;
    plural36Txt1.innerHTML = currLevel36 === 1 ? "" : "s";
  }
  
  function redrawShapes36() {
    ctx36.fillStyle = reverseContrast36 ? "black" : "white";
    ctx36.fillRect(0, 0, canvas36.width, canvas36.height);
    for (let i = 0; i < shape36Array.length; i++) shape36Array[i].draw();
  }
</script>
<canvas id = "canvas35"></canvas>
<button onclick = "startCanvas35()">Start/Stop</button>
<button onclick = "reset35()">Reset</button>
<br>
<input type = "checkbox" id = "turbo35Checkbox" oninput = "updateSettings35()">
<label for = "turbo35Checkbox">Turbo (&times;10)</label>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps35Txt"></span></b></i></div>
<div><b><u>Turn chance:</u></b> <span id = "turnChance35Txt">1</span>%</div>
<input type = "range" min = "0" max = "10" step = "1" value = "0" id = "turnChance35Range" oninput = "updateSettings35()">
<div class = "desc"><b><i>(12/1/2021)</i></b> Another random walker creation I tried, which ended up failing pretty miserably. The way it works is the random walker goes in a straight line until it comes to a square it has already visited, and then it turns to a random direction. I'm not sure what I was expecting, but it's pretty boring.<br><b><i>Update: (Later that day)</i></b> I managed to salvage this project, somewhat. I added colors (that randomize each reset) so that the color drawn is based on the walker's direction (e.g., moving up might mean red, moving right might mean green, etc.). I also added a turn chance variable so that the walker has a chance to turn on newly visited squares as well, giving it more interesting patterns.</div>
<hr><hr>
<script>
  const ctx35 = canvas35.getContext("2d");
  canvas35.width = canvas35.height = 1000;
  let canvas35Running = false;
  
  let gridSize35 = 200;
  let tileSize35 = canvas35.width / gridSize35;
  let grid35 = [];
  let colors35 = [];
  let turnChance35 = 0.01;
  
  let stepsPerFrame35 = 500;
  
  let Walker35 = {
    x: 0,
    y: 0,
    dir: 0
  };
  Walker35.walk = function() {
    if (grid35[this.x][this.y] || Math.random() < turnChance35) this.dir = Math.floor(Math.random() * 4); // If already visited or random chance, turn randomly
    grid35[this.x][this.y] = true; // Set current position to visited
    
    if (this.dir === 0) this.y--; // Up
    else if (this.dir === 1) this.x++; // Right
    else if (this.dir === 2) this.y++; // Down
    else if (this.dir === 3) this.x--; // Left
    
    this.x = (this.x + gridSize35) % gridSize35;
    this.y = (this.y + gridSize35) % gridSize35;
    
    if (!grid35[this.x][this.y]) {
      ctx35.fillStyle = colors35[this.dir];
      ctx35.fillRect(this.x * tileSize35, this.y * tileSize35, tileSize35, tileSize35);
    }  
  };
  
  function reset35() {
    ctx35.fillStyle = "black";
    ctx35.fillRect(0, 0, canvas35.width, canvas35.height);
    
    colors35 = [];
    for (let i = 0; i < 4; i++) colors35.push(`rgb(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255})`);
    
    tileSize35 = canvas35.width / gridSize35;
    grid35 = [];
    for (let x = 0; x < gridSize35; x++) {
      let row = [];
      for (let y = 0; y < gridSize35; y++) {
        row.push(false);
      }
      grid35.push(row);
    }
    
    Walker35.x = Math.floor(Math.random() * gridSize35);
    Walker35.y = Math.floor(Math.random() * gridSize35);
    Walker35.dir = Math.floor(Math.random() * 4);
  }
  reset35();
  
  let lastFrame35Time = 0;
  let lastFps35DisplayTime = 1000;
  function frame35() {
    if (Date.now() - lastFps35DisplayTime >= 500) {
      fps35Txt.innerHTML = (1000 / (Date.now() - lastFrame35Time)).toFixed(1);
      lastFps35DisplayTime = Date.now();
    }
    lastFrame35Time = Date.now();
    
    for (let i = 0; i < stepsPerFrame35; i++) Walker35.walk();
    
    if (canvas35Running) requestAnimationFrame(frame35);
  }
  frame35();
  
  function startCanvas35() {
    if (canvas35Running) canvas35Running = false;
    else {
      canvas35Running = true;
      frame35();
    }
  }
  
  let turnChance35RangeArray = [0, 0.1, 0.25, 0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100];
  turnChance35Range.max = turnChance35RangeArray.length - 1;
  turnChance35Range.value = turnChance35RangeArray.indexOf(1);
  
  function updateSettings35() {
    turnChance35 = turnChance35RangeArray[Number(turnChance35Range.value)] / 100;
    turnChance35Txt.innerHTML = turnChance35RangeArray[Number(turnChance35Range.value)];
    
    stepsPerFrame35 = turbo35Checkbox.checked ? 5000 : 500;
  }
</script>
<canvas id = "canvas34" style = "width: 500px; height: 500px"></canvas>
<button onclick = "splitQuads34()">Split</button>
<button onclick = "reset34()">Reset</button>
<div><b><u>Splits:</u></b> <span id = "currLevel34Txt">1</span> level<span id = "plural34Txt1"></span></div>
<div><b><u>Skew factor:</u></b> <span id = "skew34Txt">50</span>%</div>
<input type = "range" min = "0" max = "100" step = "5" value = "50" id = "skew34Range" oninput = "updateSettings34(false)">
<br>
<input type = "checkbox" id = "fill34Checkbox" oninput = "updateSettings34(true)" CHECKED>
<label for = "fill34Checkbox">Color fill</label>
<br>
<input type = "checkbox" id = "outline34Checkbox" oninput = "updateSettings34(true)" CHECKED>
<label for = "outline34Checkbox">Color outline</label>
<br>
<input type = "checkbox" id = "reverseContrast34Checkbox" oninput = "updateSettings34(true)">
<label for = "reverseContrast34Checkbox">Reverse contrast</label>
<br>
<div><b><u>Hue Variation:</u></b> <span id = "hueVariation34Txt">10</span>%</div>
<input type = "range" min = "0" max = "100" step = "5" value = "10" id = "hueVariation34Range" oninput = "updateSettings34(false)">
<div class = "desc"><b><i>(11/30/2021)</i></b> Quadrilateral frature splitting - I ealized I could use the same code I wrote for triangle fracture and make it work for four-sided shapes. I also was able to add a skew variable that makes the splitting more or less distorted.<br><b><i>(12/1/2021)</i></b> Changed some code and added a slider for skew.</div>
<hr><hr>
<script>
  const ctx34 = canvas34.getContext("2d");
  canvas34.width = canvas34.height = 2000;
  
  let currLevel34 = 1;
  let maxLevel34 = 7;
  let hueVariation34 = 0.1;
  let outline34 = true;
  let fill34 = true;
  let lineWidth34 = 2;
  let reverseContrast34 = false;
  let skew34 = 0.5;
  
  function Quad34(a, b, c, d, hue) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.hue = hue;
    this.draw();
  }
  Quad34.prototype.draw = function() {
    let color = `hsl(${this.hue}deg, 100%, 50%)`;
    let noColor = reverseContrast34 ? "white" : "black";
    ctx34.fillStyle = fill34 ? color : noColor;
    ctx34.strokeStyle = outline34 ? color : noColor;
    ctx34.lineWidth = lineWidth34;
    ctx34.beginPath();
    ctx34.moveTo(this.a.x, this.a.y);
    ctx34.lineTo(this.b.x, this.b.y);
    ctx34.lineTo(this.c.x, this.c.y);
    ctx34.lineTo(this.d.x, this.d.y);
    ctx34.lineTo(this.a.x, this.a.y);
    if (fill34) ctx34.fill();
    ctx34.stroke();
  };
  Quad34.prototype.split = function() {
    quad34Array.splice(quad34Array.indexOf(this), 1);
    
    let ab = lerp34(this.a, this.b, randT34()); // Random point along AB
    let bc = lerp34(this.b, this.c, randT34()); // Random point along BC
    let cd = lerp34(this.c, this.d, randT34()); // Random point along CD
    let da = lerp34(this.d, this.a, randT34()); // Random point along DA
    
    let m = {x: (this.a.x + this.b.x + this.c.x + this.d.x) / 4, y: (this.a.y + this.b.y + this.c.y + this.d.y) / 4}; // Center point
    
    quad34Array.push(new Quad34(this.a, ab, m, da, this.randHue()));
    quad34Array.push(new Quad34(this.b, bc, m, ab, this.randHue()));
    quad34Array.push(new Quad34(this.c, cd, m, bc, this.randHue()));
    quad34Array.push(new Quad34(this.d, da, m, cd, this.randHue()));
  };
  Quad34.prototype.randHue = function() {
    let hue = this.hue + randBetween(-180 * hueVariation34, 180 * hueVariation34);
    return (hue + 360) % 360;
  };
  
  function randT34() {
    return 0.5 + randBetween(-skew34 * 0.5, skew34 * 0.5);
  }
  function lerp34(p1, p2, t) {
    return {x: ((1 - t) * p1.x) + (t * p2.x), y: ((1 - t) * p1.y) + (t * p2.y)};
  }
  
  let quad34Array = [];
  
  function reset34() {
    ctx34.fillStyle = reverseContrast34 ? "black" : "white";
    ctx34.fillRect(0, 0, canvas34.width, canvas34.height);
    
    quad34Array = [];
    currLevel34 = 1;
    
    let a = {x: 0, y: 0};
    let b = {x: canvas34.width, y: 0};
    let c = {x: canvas34.width, y: canvas34.height};
    let d = {x: 0, y: canvas34.height};
    quad34Array.push(new Quad34(a, b, c, d, Math.random() * 360));
    quad34Array[0].split();
  }
  reset34();
  
  function splitQuads34() {
    if (currLevel34 >= maxLevel34) {
      redrawQuads34();
      return;
    }
    ctx34.fillStyle = reverseContrast34 ? "black" : "white";
    ctx34.fillRect(0, 0, canvas34.width, canvas34.height);
    currLevel34++;
    let copy = [];
    for (let i = 0; i < quad34Array.length; i++) copy.push(quad34Array[i]);
    for (let i = 0; i < copy.length; i++) copy[i].split();
    
    currLevel34Txt.innerHTML = currLevel34;
    plural34Txt1.innerHTML = currLevel34 === 1 ? "" : "s";
  }
  
  function redrawQuads34() {
    ctx34.fillStyle = reverseContrast34 ? "black" : "white";
    ctx34.fillRect(0, 0, canvas34.width, canvas34.height);
    for (let i = 0; i < quad34Array.length; i++) quad34Array[i].draw();
  }
  
  function updateSettings34(redraw) {
    outline34 = outline34Checkbox.checked;
    fill34 = fill34Checkbox.checked;
    reverseContrast34 = reverseContrast34Checkbox.checked;
    hueVariation34 = Number(hueVariation34Range.value) / 100;
    hueVariation34Txt.innerHTML = hueVariation34Range.value;
    
    skew34 = Number(skew34Range.value) / 100;
    skew34Txt.innerHTML = skew34Range.value;
    
    if (redraw) redrawQuads34();
  }
</script>
<canvas id = "canvas33" style = "width: 500px; height: 500px"></canvas>
<button onclick = "reset33()">Reset</button>
<button onclick = "splitTriangles33()">Split</button>
<div><b><u>Splits:</u></b> <span id = "currLevel33Txt">1</span> level<span id = "plural33Txt1"></span></div>
<input type = "checkbox" id = "fill33Checkbox" oninput = "updateSettings33()" CHECKED>
<label for = "fill33Checkbox">Color fill</label>
<br>
<input type = "checkbox" id = "outline33Checkbox" oninput = "updateSettings33()" CHECKED>
<label for = "outline33Checkbox">Color outline</label>
<br>
<input type = "checkbox" id = "reverseContrast33Checkbox" oninput = "updateSettings33()">
<label for = "reverseContrast33Checkbox">Reverse contrast</label>
<br>
<div><b><u>Hue Variation:</u></b> <span id = "hueVariation33Txt">5</span>%</div>
<input type = "range" min = "0" max = "100" step = "5" value = "5" id = "hueVariation33Range" oninput = "updateSettings33()">
<div class = "desc"><b><i>(11/28/2021)</i></b> Triangle fracture fractal, based on <a href = "https://geozone.neocities.org/trianglesplit.html" target = "_blank">this</a> Neocities page.</div>
<hr><hr>
<script>
  const ctx33 = canvas33.getContext("2d");
  canvas33.width = canvas33.height = 2000;
  
  let currLevel33 = 1;
  let maxLevel33 = 8;
  let hueVariation33 = 0.05;
  let outline33 = true;
  let fill33 = true;
  let lineWidth33 = 2;
  let reverseContrast33 = false;
  
  function Triangle33(a, b, c, hue) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.hue = hue;
    this.draw();
  }
  Triangle33.prototype.draw = function() {
    let color = `hsl(${this.hue}deg, 100%, 50%)`;
    let noColor = reverseContrast33 ? "white" : "black";
    ctx33.fillStyle = fill33 ? color : noColor;
    ctx33.strokeStyle = outline33 ? color : noColor;
    ctx33.lineWidth = lineWidth33;
    ctx33.beginPath();
    ctx33.moveTo(this.a.x, this.a.y);
    ctx33.lineTo(this.b.x, this.b.y);
    ctx33.lineTo(this.c.x, this.c.y);
    ctx33.lineTo(this.a.x, this.a.y);
    if (fill33) ctx33.fill();
    ctx33.stroke();
  };
  Triangle33.prototype.split = function() {
    triangle33Array.splice(triangle33Array.indexOf(this), 1);
    let m = {x: (this.a.x + this.b.x + this.c.x) / 3, y: (this.a.y + this.b.y + this.c.y) / 3};
    triangle33Array.push(new Triangle33(this.a, this.b, m, this.randHue()));
    triangle33Array.push(new Triangle33(this.b, this.c, m, this.randHue()));
    triangle33Array.push(new Triangle33(this.c, this.a, m, this.randHue()));
  };
  Triangle33.prototype.randHue = function() {
    let hue = this.hue + randBetween(-180 * hueVariation33, 180 * hueVariation33);
    return (hue + 360) % 360;
  }
  let triangle33Array = [];
  
  function reset33() {
    ctx33.fillStyle = reverseContrast33 ? "black" : "white";
    ctx33.fillRect(0, 0, canvas33.width, canvas33.height);
    triangle33Array = [];
    let a = {x: 0, y: 0};
    let b = {x: canvas33.width, y: 0};
    let c = {x: canvas33.width, y: canvas33.height};
    let d = {x: 0, y: canvas33.height};
    let m = {x: canvas33.width * randBetween(0.1, 0.9), y: canvas33.height * randBetween(0.1, 0.9)};
    triangle33Array.push(new Triangle33(a, b, m, Math.random() * 360));
    triangle33Array.push(new Triangle33(b, c, m, Math.random() * 360));
    triangle33Array.push(new Triangle33(c, d, m, Math.random() * 360));
    triangle33Array.push(new Triangle33(a, d, m, Math.random() * 360));
    currLevel33 = 1;
  }
  reset33();
  
  function splitTriangles33() {
    if (currLevel33 >= maxLevel33) {
      redrawTriangles33();
      return;
    }
    ctx33.fillStyle = reverseContrast33 ? "black" : "white";
    ctx33.fillRect(0, 0, canvas33.width, canvas33.height);
    currLevel33++;
    let copy = [];
    for (let i = 0; i < triangle33Array.length; i++) copy.push(triangle33Array[i]);
    for (let i = 0; i < copy.length; i++) copy[i].split();
    currLevel33Txt.innerHTML = currLevel33;
    plural33Txt1.innerHTML = currLevel33 === 1 ? "" : "s";
  }
  
  function updateSettings33() {
    outline33 = outline33Checkbox.checked;
    fill33 = fill33Checkbox.checked;
    reverseContrast33 = reverseContrast33Checkbox.checked;
    hueVariation33 = Number(hueVariation33Range.value) / 100;
    hueVariation33Txt.innerHTML = hueVariation33Range.value;
    
    redrawTriangles33();
  }
  
  function redrawTriangles33() {
    ctx33.fillStyle = reverseContrast33 ? "black" : "white";
    ctx33.fillRect(0, 0, canvas33.width, canvas33.height);
    for (let i = 0; i < triangle33Array.length; i++) triangle33Array[i].draw();
  }
</script>
<canvas id = "canvas32" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas32()">Start/Stop</button>
<button onclick = "reset32()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps32Txt"></span></b></i></div>
<table>
  <tr>
    <td style = "padding: 10px; width: 180px">
      <div><b><u>Grid Size:</u></b> <span id = "gridSize32Txt">100&times;100</span></div>
      <input type = "range" min = "50" max = "200" step = "25" value = "100" id = "gridSize32Range" oninput = "updateSettings32(true)">
    </td>
    <td style = "padding: 10px; width: 180px">
      <input type = "checkbox" id = "blackBackground32Checkbox" oninput = "updateSettings32(true)" CHECKED>
      <label for = "blackBackground32Checkbox">Black Background</label>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Turn Rate:</u></b> ~<span id = "turnAge32Txt">1</span> step<span id = "plural32Txt1"></span></div>
      <input type = "range" min = "1" max = "20" step = "1" value = "1" id = "turnAge32Range" oninput = "updateSettings32(false)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Draw Chance:</u></b> <span id = "drawChance32Txt">100</span>%</div>
      <input type = "range" min = "5" max = "100" step = "5" value = "100" id = "drawChance32Range" oninput = "updateSettings32(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Line Length:</u></b> <span id = "lineLength32Txt">400</span>%</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "lineLength32Range" oninput = "updateSettings32(false)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Line Thickness:</u></b> <span id = "lineThickness32Txt">100</span>%</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "lineThickness32Range" oninput = "updateSettings32(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Line Brightness:</u></b> <span id = "lineBrightness32Txt">70</span>%</div>
      <input type = "range" min = "0" max = "100" step = "10" value = "70" id = "lineBrightness32Range" oninput = "updateSettings32(false)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Line Opacity:</u></b> <span id = "lineOpacity32Txt">5</span>%</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "lineOpacity32Range" oninput = "updateSettings32(false)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Line Color Variation:</u></b> <span id = "hueVariation32Txt">0.5</span>%</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "hueVariation32Range" oninput = "updateSettings32(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px" colspan = "3">
      <div><b><u>Settings Presets:</u></b></div>
      <div id = "presetsDiv32"></div>
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(11/28/2021)</i></b> Generative art made by a random walker, each step it moves either left/right/up/down, and draws a rectangle in the direction it moved, with a set thickness and length and opacity. The hue changes some per step as well, and it creates interesting intricate patterns.<br><b><i>Update: (Later that day)</i></b> Added more settings and sliders, and added settings presets.<br><b><i>(11/29/2021)</i></b> Added draw chance and turn rate settings and sliders, and more presets.</div>
<hr><hr>
<script>
  const ctx32 = canvas32.getContext("2d");
  canvas32.width = canvas32.height = 2000;
  let canvas32Running = false;
  
  let gridSize32 = 100;
  let tileSize32 = canvas32.width / gridSize32;
  let stepsPerFrame32 = 100;
  let lineOpacity32 = 0.05;
  let lineLength32 = 4;
  let lineThickness32 = 1;
  let lineBrightness32 = 70;
  let blackBackground32 = true;
  let hueVariation32 = 0.005;
  let drawChance32 = 1;
  let turnAge32 = 1;
  
  let presets32 = [
    { // Default
      gridSize32: 100,
      lineOpacity32: 5,
      lineLength32: 400,
      lineThickness32: 100,
      lineBrightness32: 70,
      blackBackground32: true,
      hueVariation32: 0.5,
      turnAge32: 1,
      drawChance32: 100
    },
    {
      gridSize32: 50,
      lineOpacity32: 100,
      lineLength32: 80,
      lineThickness32: 15,
      lineBrightness32: 70,
      blackBackground32: true,
      hueVariation32: 2,
      turnAge32: 1,
      drawChance32: 100
    },
    {
      gridSize32: 100,
      lineOpacity32: 3,
      lineLength32: 800,
      lineThickness32: 30,
      lineBrightness32: 70,
      blackBackground32: true,
      hueVariation32: 1,
      turnAge32: 1,
      drawChance32: 100
    },
    {
      gridSize32: 100,
      lineOpacity32: 10,
      lineLength32: 100,
      lineThickness32: 100,
      lineBrightness32: 50,
      blackBackground32: true,
      hueVariation32: 0.5,
      turnAge32: 1,
      drawChance32: 100
    },
    {
      gridSize32: 100,
      lineOpacity32: 10,
      lineLength32: 70,
      lineThickness32: 70,
      lineBrightness32: 50,
      blackBackground32: true,
      hueVariation32: 1,
      turnAge32: 1,
      drawChance32: 100
    },
    {
      gridSize32: 100,
      lineOpacity32: 2,
      lineLength32: 400,
      lineThickness32: 400,
      lineBrightness32: 0,
      blackBackground32: false,
      hueVariation32: 0.5,
      turnAge32: 1,
      drawChance32: 100
    },
    {
      gridSize32: 100,
      lineOpacity32: 100,
      lineLength32: 400,
      lineThickness32: 400,
      lineBrightness32: 40,
      blackBackground32: true,
      hueVariation32: 3,
      turnAge32: 1,
      drawChance32: 100
    },
    {
      gridSize32: 50,
      lineOpacity32: 10,
      lineLength32: 100,
      lineThickness32: 50,
      lineBrightness32: 50,
      blackBackground32: true,
      hueVariation32: 5,
      turnAge32: 1,
      drawChance32: 100
    },
    {
      gridSize32: 100,
      lineOpacity32: 25,
      lineLength32: 100,
      lineThickness32: 100,
      lineBrightness32: 50,
      blackBackground32: true,
      hueVariation32: 1,
      turnAge32: 1,
      drawChance32: 25
    },
    { // Default
      gridSize32: 100,
      lineOpacity32: 100,
      lineLength32: 100,
      lineThickness32: 30,
      lineBrightness32: 50,
      blackBackground32: true,
      hueVariation32: 0.25,
      turnAge32: 5,
      drawChance32: 100
    }
  ];
  function loadPreset32(n) {
    let p = presets32[n];
    gridSize32Range.value = p.gridSize32;
    lineOpacity32Range.value = lineOpacity32RangeArray.indexOf(p.lineOpacity32);
    lineLength32Range.value = line32RangeArray.indexOf(p.lineLength32);
    lineThickness32Range.value = line32RangeArray.indexOf(p.lineThickness32);
    lineBrightness32Range.value = p.lineBrightness32;
    blackBackground32Checkbox.checked = p.blackBackground32;
    hueVariation32Range.value = hueVariation32RangeArray.indexOf(p.hueVariation32);
    turnAge32Range.value = p.turnAge32;
    drawChance32Range.value = p.drawChance32;
    
    updateSettings32(true);
  }
  for (let i = 0; i < presets32.length; i++) {
    let btn = document.createElement("button");
    btn.id = "presetBtn32" + i;
    btn.innerHTML = i + 1;
    btn.onclick = () => {
      loadPreset32(i);
      btn.style.backgroundColor = "gray";
    }
    btn.style.margin = "5px";
    btn.style.borderRadius = "50%";
    btn.style.display = "inline-block";
    
    presetsDiv32.appendChild(btn);
  }
  document.getElementById("presetBtn320").style.backgroundColor = "gray";
  
  let Walker32 = {
    x: 0,
    y: 0,
    hue: 0,
    dir: 0,
    age: 0,
    turnAge: 0
  };
  Walker32.walk = function() {
    if (this.age >= this.turnAge) {
      this.dir = Math.floor(Math.random() * 4);
      this.turnAge = Math.round(turnAge32 * randBetween(0.5, 1));
      this.age = 0;
    }
    this.age++;
    if (this.dir === 0) this.y--; // Top
    else if (this.dir === 1) this.x++; // Right
    else if (this.dir === 2) this.y++; // Bottom
    else this.x--; // Left
    this.x = (this.x + gridSize32) % gridSize32;
    this.y = (this.y + gridSize32) % gridSize32;
    
    if (Math.random() >= drawChance32) return; // Don't draw
    
    this.hue += Math.random() * randSign() * hueVariation32 * 360;
    ctx32.fillStyle = `hsla(${this.hue}deg, 100%, ${lineBrightness32}%, ${lineOpacity32})`;
    if (this.dir === 0 || this.dir === 2) {
      ctx32.fillRectFromCenter(this.x * tileSize32, this.y * tileSize32, tileSize32 * lineThickness32, tileSize32 * lineLength32);
    }
    else {
      ctx32.fillRectFromCenter(this.x * tileSize32, this.y * tileSize32, tileSize32 * lineLength32, tileSize32 * lineThickness32);
    }
  };
  
  function reset32() {
    ctx32.fillStyle = blackBackground32 ? "black" : "white";
    ctx32.fillRect(0, 0, canvas32.width, canvas32.height);
    tileSize32 = canvas32.width / gridSize32;
    Walker32.x = Math.floor(Math.random() * gridSize32);
    Walker32.y = Math.floor(Math.random() * gridSize32);
    Walker32.hue = Math.random() * 360;
    Walker32.dir = Math.floor(Math.random() * 4);
    Walker32.age = 0;
    Walker32.turnAge = Math.round(Math.random() * turnAge32);
  }
  reset32();
  
  let lastFrame32Time = 0;
  let lastFps32DisplayTime = 1000;
  
  function frame32() {
    if (Date.now() - lastFps32DisplayTime >= 500) {
      fps32Txt.innerHTML = (1000 / (Date.now() - lastFrame32Time)).toFixed(1);
      lastFps32DisplayTime = Date.now();
    }
    lastFrame32Time = Date.now();
    
    for (let i = 0; i < stepsPerFrame32; i++) Walker32.walk();
    
    if (canvas32Running) requestAnimationFrame(frame32);
  }
  frame32();
  
  function startCanvas32() {
    if (canvas32Running) canvas32Running = false;
    else {
      canvas32Running = true;
      frame32();
    }
  }
  
  let line32RangeArray = [10, 15, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 125, 150, 175, 200, 300, 400, 500, 600, 800, 1000, 1500, 2000];
  lineLength32Range.max = line32RangeArray.length - 1;
  lineLength32Range.value = line32RangeArray.indexOf(800);
  lineThickness32Range.max = line32RangeArray.length - 1;
  lineThickness32Range.value = line32RangeArray.indexOf(100);
  
  let lineOpacity32RangeArray = [1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 35, 40, 50, 60, 70, 80, 90, 100];
  lineOpacity32Range.max = lineOpacity32RangeArray.length - 1;
  lineOpacity32Range.value = lineOpacity32RangeArray.indexOf(5);
  
  let hueVariation32RangeArray = [0, 0.25, 0.5, 1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100];
  hueVariation32Range.max = hueVariation32RangeArray.length - 1;
  hueVariation32Range.value = hueVariation32RangeArray.indexOf(0.5);
  
  function updateSettings32(reset) {
    gridSize32 = Number(gridSize32Range.value);
    gridSize32Txt.innerHTML = gridSize32 + "&times;" + gridSize32;
    
    lineLength32 = line32RangeArray[Number(lineLength32Range.value)] / 100;
    lineLength32Txt.innerHTML = line32RangeArray[Number(lineLength32Range.value)];
    
    lineThickness32 = line32RangeArray[Number(lineThickness32Range.value)] / 100;
    lineThickness32Txt.innerHTML = line32RangeArray[Number(lineThickness32Range.value)];
    
    blackBackground32 = blackBackground32Checkbox.checked;
    
    lineBrightness32 = lineBrightness32Txt.innerHTML = Number(lineBrightness32Range.value);
    
    lineOpacity32 = lineOpacity32RangeArray[Number(lineOpacity32Range.value)] / 100;
    lineOpacity32Txt.innerHTML = lineOpacity32RangeArray[Number(lineOpacity32Range.value)];
    
    hueVariation32 = hueVariation32RangeArray[Number(hueVariation32Range.value)] / 100;
    hueVariation32Txt.innerHTML = hueVariation32RangeArray[Number(hueVariation32Range.value)];
    
    turnAge32 = turnAge32Txt.innerHTML = Number(turnAge32Range.value);
    plural32Txt1.innerHTML = turnAge32 === 1 ? "" : "s";
    
    drawChance32 = Number(drawChance32Range.value)  / 100;
    drawChance32Txt.innerHTML = drawChance32Range.value;
    
    for (let i = 0; i < presets32.length; i++) {
      document.getElementById("presetBtn32" + i).style.backgroundColor = "white";
    }
    
    if (reset) reset32();
  }
</script>
<canvas id = "canvas31"></canvas>
<button onclick = "startCanvas31()">Start/Stop</button>
<button onclick = "reset31()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps31Txt"></span></b></i></div>
<div class = "desc"><b><i>(11/28/2021)</i></b> Simple color averaging art based on <a href = "https://www.youtube.com/watch?v=xHq4UlJiUaE" target = "_blank">this</a> video.</div>
<hr><hr>
<script>
  const ctx31 = canvas31.getContext("2d");
  canvas31.width = canvas31.height = 1000;
  let canvas31Running = false;
  
  let gridSize31 = 100;
  let tileSize31 = canvas31.width / gridSize31;
  let grid31 = [];
  let hueStep31 = 1;
  let numFixed31 = 0;
  let stepsPerFrame31 = 2;
  
  function reset31() {
    tileSize31 = canvas31.width / gridSize31;
    grid31 = [];
    for (let x = 0; x < gridSize31; x++) {
      let row = [];
      for (let y = 0; y < gridSize31; y++) {
        row.push({hue: Math.random() * 360, fixed: false, brightness: 50});
      }
      grid31.push(row);
    }
    for (let i = 0; i < numFixed31; i++) {
      grid31[Math.floor(Math.random() * gridSize31)][Math.floor(Math.random() * gridSize31)].fixed = true;
    }
    
    drawGrid31();
  }
  reset31();
  
  function getNeighbors31(x, y) {
    let M = grid31[x][y].hue;
    let T = grid31[x][(y - 1 + gridSize31) % gridSize31].hue;
    let TR = grid31[(x + 1) % gridSize31][(y - 1 + gridSize31) % gridSize31].hue;
    let R = grid31[(x + 1) % gridSize31][y].hue;
    let BR = grid31[(x + 1) % gridSize31][(y + 1) % gridSize31].hue;
    let B = grid31[x][(y + 1) % gridSize31].hue;
    let BL = grid31[(x - 1 + gridSize31) % gridSize31][(y + 1) % gridSize31].hue;
    let L = grid31[(x - 1 + gridSize31) % gridSize31][y].hue;
    let TL = grid31[(x - 1 + gridSize31) % gridSize31][(y - 1 + gridSize31) % gridSize31].hue;
    return [M, T, TR, R, BR, B, BL, L, TL];
  }
  
  function averageGrid31() {
    let nextGrid = [];
    for (let x = 0; x < gridSize31; x++) {
      let row = [];
      for (let y = 0; y < gridSize31; y++) {
        row.push({hue: 0, fixed: false, brightness: 50});
      }
      nextGrid.push(row);
    }
    
    for (let x = 0; x < gridSize31; x++) {
      for (let y = 0; y < gridSize31; y++) {
        if (!grid31[x][y].fixed) {
          let neighbors = getNeighbors31(x, y);
          let _x = 0;
          let _y = 0;
          for (let i = 0; i < neighbors.length; i++) {
            let d = 1//Math.random() * 5;
            _x += d * Math.cos(toRad(neighbors[i]));
            _y += d * Math.sin(toRad(neighbors[i]));
          }
          let a = Math.atan2(_y, _x);
          nextGrid[x][y].hue = toDeg(a);
          //let dist = Math.sqrt((_x * _x) + (_y * _y));
          //nextGrid[x][y].brightness = 1000 / (dist * dist);
        }
        else {
          nextGrid[x][y].hue = (grid31[x][y].hue + hueStep31) % 360;
        }
        nextGrid[x][y].fixed = grid31[x][y].fixed;
      }
    }
    
    grid31 = nextGrid;
  }
  function drawGrid31() {
    for (let x = 0; x < gridSize31; x++) {
      for (let y = 0; y < gridSize31; y++) {
         ctx31.fillStyle = `hsl(${grid31[x][y].hue}deg, 100%, ${grid31[x][y].brightness}%)`;
         ctx31.fillRect(x * tileSize31, y * tileSize31, tileSize31, tileSize31);
         if (grid31[x][y].fixed) {
           ctx31.fillStyle = "black";
           ctx31.fillCircle((x + 0.5) * tileSize31, (y + 0.5) * tileSize31, tileSize31 / 4);
         }
      }
    }
  }
  
  let lastFrame31Time = 0;
  let lastFps31DisplayTime = 1000;
  function frame31() {
    if (Date.now() - lastFps31DisplayTime >= 500) {
      fps31Txt.innerHTML = (1000 / (Date.now() - lastFrame31Time)).toFixed(1);
      lastFps31DisplayTime = Date.now();
    }
    lastFrame31Time = Date.now();
    
    ctx31.clearRect(0, 0, canvas31.width, canvas31.height);
    
    for (let j = 0; j < stepsPerFrame31; j++) averageGrid31();
    drawGrid31();
    
    if (canvas31Running) requestAnimationFrame(frame31);
  }
  frame31();
  
  function startCanvas31() {
    if (canvas31Running) canvas31Running = false;
    else {
      canvas31Running = true;
      frame31();
    }
  }
</script>
<canvas id = "canvas30" style = "width: 400px; height: 400px"></canvas>
<button onclick = "drawSquares30()">Reset</button>
<div><b><u>Squares:</u></b> <span id = "numSquares30Txt"></span></div>
<table>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Min Square Size:</u></b> <span id = "minSquare30SizeTxt">5</span>px</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "minSquare30SizeRange" oninput = "updateSettings30(false)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Max Square Size:</u></b> <span id = "maxSquare30SizeTxt">200</span>px</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "maxSquare30SizeRange" oninput = "updateSettings30(false)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Square Visual Size Ratio:</u></b> <span id = "square30SizeRatioTxt">100</span>%</div>
      <input type = "range" min = "50" max = "150" value = "100" step = "10" id = "square30SizeRatioRange" oninput = "updateSettings30(true)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Square Fill Mode:</u></b></div>
      <input type = "radio" name = "fillMode30Radio" id = "fillMode30Radio0" oninput = "updateSettings30(true)" CHECKED>
      <label for = "fillMode30Radio0">Size-based color</label>
      <br>
      <input type = "radio" name = "fillMode30Radio" id = "fillMode30Radio1" oninput = "updateSettings30(true)">
      <label for = "fillMode30Radio1">Random color</label>
      <br>
      <input type = "radio" name = "fillMode30Radio" id = "fillMode30Radio2" oninput = "updateSettings30(true)">
      <label for = "fillMode30Radio2">White</label>
      <br>
      <input type = "radio" name = "fillMode30Radio" id = "fillMode30Radio3" oninput = "updateSettings30(true)">
      <label for = "fillMode30Radio3">Black</label>
      <br>
      <input type = "radio" name = "fillMode30Radio" id = "fillMode30Radio4" oninput = "updateSettings30(true)">
      <label for = "fillMode30Radio4">No fill</label>
    </td>
    <td style = "padding: 10px">
      <div><b><u>Square Outline Mode:</u></b></div>
      <input type = "radio" name = "outlineMode30Radio" id = "outlineMode30Radio0" oninput = "updateSettings30(true)">
      <label for = "outlineMode30Radio0">Size-based color</label>
      <br>
      <input type = "radio" name = "outlineMode30Radio" id = "outlineMode30Radio1" oninput = "updateSettings30(true)">
      <label for = "outlineMode30Radio1">Random color</label>
      <br>
      <input type = "radio" name = "outlineMode30Radio" id = "outlineMode30Radio2" oninput = "updateSettings30(true)">
      <label for = "outlineMode30Radio2">White</label>
      <br>
      <input type = "radio" name = "outlineMode30Radio" id = "outlineMode30Radio3" oninput = "updateSettings30(true)" CHECKED>
      <label for = "outlineMode30Radio3">Black</label>
      <br>
      <input type = "radio" name = "outlineMode30Radio" id = "outlineMode30Radio4" oninput = "updateSettings30(true)">
      <label for = "outlineMode30Radio4">No outline</label>
    </td>
    <td style = "padding: 10px">
      <div><b><u>Settings Presets:</u></b></div>
      <div id = "presetsDiv30"></div>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "blackBackground30Checkbox" oninput = "updateSettings30(true)" CHECKED>
      <label for = "blackBackground30Checkbox">Black background</label>
    </td>
    <td style = "padding: 10px">
      <div><b><u>Outline width:</u></b> <span id = "lineWidth30Txt">5</span>px</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "lineWidth30Range" oninput = "updateSettings30(true)">
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(11/27/2021)</i></b> I finally redid my old square packing algorithm, and it's significantly faster now. I also added settings, sliders, and presets.<br><b><i><mark>Actually finished! (5/20/2022)</mark> Added to <a href = "generative-art-gallery.html" target = "_blank">generative-art-gallery.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx30 = canvas30.getContext("2d");
  canvas30.width = canvas30.height = 2000;
  
  let canvas30Filled = false;
  let minSquare30Size = 5;
  let maxSquare30Size = 200;
  let maxSquares30 = 5000;
  let square30SizeRatio = 1;
  let fillMode30 = 0; // 0: Gradient, 1: Random, 2: White, 3: Black, 4: No fill
  let outlineMode30 = 3; // 0: Gradient, 1: Random, 2: White, 3: Black, 4: No outline
  let hue30 = Math.random() * 360;
  let blackBackground30 = true;
  let lineWidth30 = 5;
  let maxTries30 = 1000;
  
  let presets30 = [
    { // Default
      minSquare30Size: 5,
      maxSquare30Size: 200,
      square30SizeRatio: 100,
      fillMode30: 0,
      outlineMode30: 3,
      blackBackground30: true,
      lineWidth30: 5
    },
    {
      minSquare30Size: 1,
      maxSquare30Size: 200,
      square30SizeRatio: 50,
      fillMode30: 4,
      outlineMode30: 0,
      blackBackground30: true,
      lineWidth30: 5
    },
    {
      minSquare30Size: 20,
      maxSquare30Size: 200,
      square30SizeRatio: 70,
      fillMode30: 1,
      outlineMode30: 4,
      blackBackground30: false,
      lineWidth30: 5
    },
    {
      minSquare30Size: 5,
      maxSquare30Size: 150,
      square30SizeRatio: 120,
      fillMode30: 3,
      outlineMode30: 1,
      blackBackground30: true,
      lineWidth30: 5
    },
    {
      minSquare30Size: 5,
      maxSquare30Size: 200,
      square30SizeRatio: 90,
      fillMode30: 3,
      outlineMode30: 0,
      blackBackground30: false,
      lineWidth30: 5
    },
    {
      minSquare30Size: 1,
      maxSquare30Size: 50,
      square30SizeRatio: 100,
      fillMode30: 0,
      outlineMode30: 4,
      blackBackground30: true,
      lineWidth30: 5
    }
  ];
  for (let i = 0; i < presets30.length; i++) {
    let btn = document.createElement("button");
    btn.innerHTML = i + 1;
    btn.onclick = () => loadPreset30(i);
    btn.style.margin = "5px";
    btn.style.borderRadius = "50%";
    btn.style.display = "inline-block";
    
    presetsDiv30.appendChild(btn);
  }
  function loadPreset30(n) {
    let p = presets30[n];
    minSquare30SizeRange.value = square30SizeRangeArray.indexOf(p.minSquare30Size);
    maxSquare30SizeRange.value = square30SizeRangeArray.indexOf(p.maxSquare30Size);
    square30SizeRatioRange.value = p.square30SizeRatio;
    document.getElementById("fillMode30Radio" + p.fillMode30).checked = true;
    document.getElementById("outlineMode30Radio" + p.outlineMode30).checked = true;
    blackBackground30Checkbox.checked = p.blackBackground30;
    lineWidth30Range.value = lineWidth30RangeArray.indexOf(p.lineWidth30);
    
    updateSettings30(false);
    drawSquares30();
  }
  
  function Square30() {
    let x = Math.random() * canvas30.width;
    let y = Math.random() * canvas30.height;
    let tries = 0;
    
    while (!validatePoint30(x, y)) {
      if (tries > maxTries30) {
        canvas30Filled = true;
        return;
      }
      x = Math.random() * canvas30.width;
      y = Math.random() * canvas30.height;
      tries++;
    }
    
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.grow();
  }
  Square30.prototype.grow = function() {
    let leastDist = Infinity;
    let thisInd = square30Array.indexOf(this);
    let len = square30Array.length;
    for (let i = 0; i < len; i++) {
      if (i !== thisInd) {
        let s = square30Array[i];
        let dx = Math.abs(this.x - s.x) - s.radius;
        let dy = Math.abs(this.y - s.y) - s.radius;
        let dist = Math.max(dx, dy); // Which direction is furthest away
        if (dist < leastDist) leastDist = dist; // Find shortest distance
      }
    }
    
    let distToTop = this.y; // Check distance to edges
    if (distToTop <= leastDist) leastDist = distToTop;
    let distToRight = canvas30.width - this.x;
    if (distToRight <= leastDist) leastDist = distToRight;
    let distToBottom = canvas30.height - this.y;
    if (distToBottom <= leastDist) leastDist = distToBottom;
    let distToLeft = this.x;
    if (distToLeft <= leastDist) leastDist = distToLeft;
    
    if (leastDist > maxSquare30Size) leastDist = maxSquare30Size; // Update size
    this.radius = leastDist;
    
    this.draw();
  };
  Square30.prototype.draw = function() {
    let r = this.radius * square30SizeRatio;
    let hue = ((this.radius - minSquare30Size) / (maxSquare30Size - minSquare30Size)) * 360;
    let colors = [
      ctx30.fillStyle = `hsl(${hue30 + hue}deg, 100%, 40%)`, // Gradient
      ctx30.fillStyle = `hsl(${Math.random() * 360}deg, 100%, 40%)`, // Random
      "white", // White
      "black", // Black
      null // No outline
    ];
    
    ctx30.fillStyle = colors[fillMode30];
    ctx30.strokeStyle = colors[outlineMode30];
    ctx30.lineWidth = lineWidth30;
    ctx30.beginPath();
    ctx30.rect(this.x - r, this.y - r, r * 2, r * 2);
    if (fillMode30 !== 4) ctx30.fill();
    if (outlineMode30 !== 4) ctx30.stroke();
  };
  let square30Array = [];
  
  function validatePoint30(x, y) {
    for (let i = 0; i < square30Array.length; i++) {
      let r = square30Array[i].radius + minSquare30Size;
      let x1 = square30Array[i].x - r;
      let x2 = square30Array[i].x + r;
      let y1 = square30Array[i].y - r;
      let y2 = square30Array[i].y + r;
      if ((x > x1 && x < x2) && (y > y1 && y < y2)) return false; // Too close to a square
    }
    if (x < minSquare30Size || x > canvas30.width - minSquare30Size) return false; // Too close to left/right
    if (y < minSquare30Size || y > canvas30.height - minSquare30Size) return false; // Too close to top/bottom
    return true;
  }
  
  function drawSquares30() {
    ctx30.fillStyle = blackBackground30 ? "black" : "white";
    ctx30.fillRect(0, 0, canvas30.width, canvas30.height);
    canvas30Filled = false;
    hue30 = Math.random() * 360;
    square30Array = [];
    square30Array.push(new Square30());
    while (!canvas30Filled && square30Array.length < maxSquares30) square30Array.push(new Square30());
    
    numSquares30Txt.innerHTML = square30Array.length.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  }
  drawSquares30();
  function recolorSquares30() {
    ctx30.fillStyle = blackBackground30 ? "black" : "white";
    ctx30.fillRect(0, 0, canvas30.width, canvas30.height);
    
    for (let i = 0; i < square30Array.length; i++) square30Array[i].draw();
  }
  
  
  let lineWidth30RangeArray = [1, 2, 3, 4, 5, 10, 15, 20];//, 25, 30, 40, 50];
  lineWidth30Range.max = lineWidth30RangeArray.length - 1;
  lineWidth30Range.value = lineWidth30RangeArray.indexOf(5);
  
  let square30SizeRangeArray = [1, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100, 150, 200, 300, 400, 500];
  minSquare30SizeRange.max = maxSquare30SizeRange.max = square30SizeRangeArray.length - 1;
  minSquare30SizeRange.value = square30SizeRangeArray.indexOf(5);
  maxSquare30SizeRange.value = square30SizeRangeArray.indexOf(200);
  
  function updateSettings30(recolor) {
    maxSquare30Size = maxSquare30SizeTxt.innerHTML = square30SizeRangeArray[Number(maxSquare30SizeRange.value)];
    minSquare30SizeRange.max = square30SizeRangeArray.indexOf(maxSquare30Size);
    minSquare30Size = minSquare30SizeTxt.innerHTML = square30SizeRangeArray[Number(minSquare30SizeRange.value)];
    
    if (fillMode30Radio0.checked) fillMode30 = 0;
    else if (fillMode30Radio1.checked) fillMode30 = 1;
    else if (fillMode30Radio2.checked) fillMode30 = 2;
    else if (fillMode30Radio3.checked) fillMode30 = 3;
    else if (fillMode30Radio4.checked) fillMode30 = 4;
    
    if (outlineMode30Radio0.checked) outlineMode30 = 0;
    else if (outlineMode30Radio1.checked) outlineMode30 = 1;
    else if (outlineMode30Radio2.checked) outlineMode30 = 2;
    else if (outlineMode30Radio3.checked) outlineMode30 = 3;
    else if (outlineMode30Radio4.checked) outlineMode30 = 4;
    
    blackBackground30 = blackBackground30Checkbox.checked;
    
    lineWidth30 = lineWidth30Txt.innerHTML = lineWidth30RangeArray[Number(lineWidth30Range.value)];
    
    square30SizeRatio = Number(square30SizeRatioRange.value) / 100;
    square30SizeRatioTxt.innerHTML = square30SizeRatioRange.value;
    
    if (recolor) recolorSquares30();
  }
</script>
<canvas id = "canvas29" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas29()">Start/Stop</button>
<button onclick = "stackCards29()">Stack Cards</button>
<button onclick = "randomizeCards29()">Randomize Cards</button>
<button onclick = "fanCards29()">Fan Cards</button>
<button onclick = "spreadCards29()">Spread Cards</button>
<button onclick = "trailing29 = !trailing29; this.innerHTML = 'Trailing: ' + trailing29">Trailing: false</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps29Txt"></span></b></i></div>
<div class = "desc"><b><i>(11/26/2021)</i></b> I'm wanting this to be a simple card table, where you can drag the cards around and slide them, right now I have the cards working but not the dragging or sliding yet.<br><b><i>Update: (Later that day)</i></b> I got the dragging hitboxes working properly after a lot of Googling and messing with dot products, so the dragging mechanic works. I took out sliding the cards across the table, and I'm not sure what else I want to do with it right now.<br><b><i>(11/27/2021)</i></b> Added animation buttons for the cards, and a trailing option.</div>
<hr><hr>
<script>
  const ctx29 = canvas29.getContext("2d");
  canvas29.width = canvas29.height = 1000;
  let canvas29Running = false;
  let canvas29Ratio = canvas29.width / 500;
  let canvas29Rect = canvas29.getBoundingClientRect();
  
  let Mouse29 = {
    down: false,
    x: 0,
    y: 0,
    draggingCard: false,
    dragIndex: null,
    offsetX: 0,
    offsetY: 0
  };
  
  let card29Img = new Image();
  card29Img.src = "images/card-sheet.png";
  let background29Img = new Image();
  background29Img.src = "images/card-table-background.jpg";
  let card29ImgWidth = 71;
  let card29ImgHeight = 96;
  let card29Width = card29ImgWidth * 2;
  let card29Height = card29ImgHeight * 2;
  let numCards29 = 52;
  let card29SlideSpeed = 15;
  let card29TurnSpeed = 0.2;
  let trailing29 = false;
  
  function Card29(index) {
    this.x = Math.random() * canvas29.width;
    this.y = Math.random() * canvas29.height;
    this.a = Math.random() * Math.PI * 2;
    this.vx = 0;
    this.vy = 0;
    this.va = 0;
    this.sx = (index % 4) * card29ImgWidth;
    this.sy = (index % 13) * card29ImgHeight;
    this.dragging = false;
    this.sliding = false;
    this.destination = {x: this.x, y: this.y, a: this.a};
    this.turnDir = 1;
  }
  Card29.prototype.render = function() {
    let lastX = this.x;
    let lastY = this.y;
    this.x += this.vx;
    this.y += this.vy;
    this.a += this.va;
    if (this.dragging) {
      this.vx = 0;
      this.vy = 0;
      this.x = Mouse29.x - Mouse29.offsetX;
      this.y = Mouse29.y - Mouse29.offsetY;
    }
    else if (this.sliding) {
      this.destination.a = (this.destination.a + (Math.PI * 2)) % (Math.PI * 2);
      let dx = this.destination.x - this.x;
      let dy = this.destination.y - this.y;
      let distSq = (dx * dx) + (dy * dy);
      let posClose = false;
      if (distSq <= card29SlideSpeed * card29SlideSpeed) {
        posClose = true;
        this.x = this.destination.x;
        this.y = this.destination.y;
      }
      else {
        let a = Math.atan2(dy, dx);
        this.x += card29SlideSpeed * Math.cos(a);
        this.y += card29SlideSpeed * Math.sin(a);
      }
      let da = this.destination.a - this.a;
      this.a += this.turnDir * card29TurnSpeed;
      let angClose = Math.abs(da) <= card29TurnSpeed;
      if (angClose) this.a = this.destination.a;
      if (angClose && posClose) {
        this.destination = {x: this.x, y: this.y, a: this.a};
        this.sliding = false;
      }
    }
    this.x = (this.x + canvas29.width) % canvas29.width;
    this.y = (this.y + canvas29.height) % canvas29.height;
    this.a = (this.a + (Math.PI * 2)) % (Math.PI * 2);
    ctx29.shadowBlur = this.dragging ? 25 : 0;
    ctx29.shadowColor = "black";
    ctx29.save();
    ctx29.translate(this.x, this.y);
    ctx29.rotate(this.a);
    ctx29.drawImage(card29Img, this.sx, this.sy, card29ImgWidth, card29ImgHeight, -card29Width / 2, -card29Height / 2, card29Width, card29Height);
    if (this.dragging) ctx29.drawImage(card29Img, this.sx, this.sy, card29ImgWidth, card29ImgHeight, -card29Width / 2, -card29Height / 2, card29Width, card29Height);
    ctx29.restore();
    ctx29.shadowBlur = 0;
  };
  Card29.prototype.getCorners = function() {
    let normCorners = [];
    let w2 = card29Width / 2;
    let h2 = card29Height / 2;
    normCorners.push({x: this.x - w2, y: this.y - h2}); // Top left
    normCorners.push({x: this.x + w2, y: this.y - h2}); // Top right
    normCorners.push({x: this.x + w2, y: this.y + h2}); // Bottom right
    normCorners.push({x: this.x - w2, y: this.y + h2}); // Bottom left
    let rotatedCorners = [];
    for (let i = 0; i < normCorners.length; i++) {
      let n = normCorners[i];
      let tx = n.x - this.x;
      let ty = n.y - this.y;
      let rotX = (tx * Math.cos(this.a)) - (ty * Math.sin(this.a));
      let rotY = (tx * Math.sin(this.a)) + (ty * Math.cos(this.a));
      rotatedCorners.push({x: rotX + this.x, y: rotY + this.y});
    }
    return rotatedCorners;
  };
  Card29.prototype.stack = function() {
    this.setDestination(canvas29.width / 2, canvas29.height / 2, 0);
  };
  Card29.prototype.randomize = function() {
    this.setDestination(Math.random() * canvas29.width, Math.random() * canvas29.width, Math.random() * Math.PI * 2);
  };
  Card29.prototype.setDestination = function(_x, _y, _a) {
    this.destination = {x: _x, y: _y, a: _a};
    this.sliding = true;
    this.turnDir = Math.sign(this.destination.a - this.a);//Math.random() >= 0.5 ? 1 : -1;
    if (this.turnDir === 0) this.turnDir = 1;
  };
  let card29Array = [];
  function reset29() {
    ctx29.drawImage(background29Img, 0, 0, canvas29.width, canvas29.height);
    card29Array = [];
    let cards = [];
    for (let i = 0; i < Math.ceil(numCards29 / 52) * 52; i++) cards.push(i);
    for (let i = 0; i < numCards29; i++) card29Array.push(new Card29(cards.splice(Math.floor(Math.random() * cards.length), 1)));
  }
  reset29();
  function stackCards29() {
    for (let i = 0; i < card29Array.length; i++) card29Array[i].stack();
  }
  function randomizeCards29() {
    shuffleCard29Array();
    for (let i = 0; i < card29Array.length; i++) card29Array[i].randomize();
  }
  function shuffleCard29Array() {
    let result = [];
    while (card29Array.length > 0) result.push(card29Array.splice(Math.floor(Math.random() * card29Array.length), 1));
    card29Array = result.flat(1);
  }
  function fanCards29() {
    //shuffleCard29Array();
    let r = canvas29.width * 0.4;
    let offset = card29Array[card29Array.length - 1].a + toRad(90);//Math.random() * Math.PI * 2;
    for (let i = 0; i < card29Array.length; i++) {
      let a = ((i / card29Array.length) * Math.PI * 2) + offset;
      let c = card29Array[i];
      let dx = (canvas29.width / 2) + (r * Math.cos(a));
      let dy = (canvas29.height / 2) + (r * Math.sin(a));
      let da = a + (Math.PI / 2);
      c.setDestination(dx, dy, da);
    }
  }
  function spreadCards29() {
    for (let i = 0; i < card29Array.length; i++) {
      card29Array[i].setDestination(((i / card29Array.length) * canvas29.width * 0.8) + (canvas29.width * 0.1), canvas29.height / 2, 0);
    }
  }
  
  function dotProduct29(a, b) {
    return (a.x * b.x) + (a.y * b.y);
  }
  
  let lastFrame29Time = 0;
  let lastFps29DisplayTime = 1000;
  function frame29() {
    if (Date.now() - lastFps29DisplayTime >= 500) {
      fps29Txt.innerHTML = (1000 / (Date.now() - lastFrame29Time)).toFixed(1);
      lastFps29DisplayTime = Date.now();
    }
    lastFrame29Time = Date.now();
    
    ctx29.globalAlpha = trailing29 ? 0.1 : 1;
    ctx29.drawImage(background29Img, 0, 0, canvas29.width, canvas29.height);
    ctx29.globalAlpha = 1;
    
    for (let i = 0; i < card29Array.length; i++) card29Array[i].render();
    
    if (canvas29Running) requestAnimationFrame(frame29);
  }
  frame29();
  
  function startCanvas29() {
    if (canvas29Running) canvas29Running = false;
    else {
      canvas29Running = true;
      frame29();
    }
  }
  
  canvas29.addEventListener("mousedown", e => {
    if (!canvas29Running) return;
    e.preventDefault();
    canvas29Rect = canvas29.getBoundingClientRect();
    Mouse29.x = (e.clientX - canvas29Rect.left) * canvas29Ratio;
    Mouse29.y = (e.clientY - canvas29Rect.top) * canvas29Ratio;
    for (let i = card29Array.length - 1; i >= 0; i--) {
      let c = card29Array[i];
      let corners = c.getCorners();
      let AM = {x: Mouse29.x - corners[0].x, y: Mouse29.y - corners[0].y};
      let AB = {x: corners[1].x - corners[0].x, y: corners[1].y - corners[0].y};
      let BM = {x: Mouse29.x - corners[1].x, y: Mouse29.y - corners[1].y};
      let BC = {x: corners[2].x - corners[1].x, y: corners[2].y - corners[1].y};
      let AMAB = dotProduct29(AM, AB);
      let ABAB = dotProduct29(AB, AB);
      let BMBC = dotProduct29(BM, BC);
      let BCBC = dotProduct29(BC, BC);
      let touching = ((0 < AMAB) && (AMAB < ABAB)) && ((0 < BMBC) && (BMBC < BCBC));
      if (touching) {
        let dx = Mouse29.x - c.x;
        let dy = Mouse29.y - c.y;
        Mouse29.offsetX = dx;
        Mouse29.offsetY = dy;
        Mouse29.draggingCard = true;
        c.dragging = true;
        Mouse29.dragIndex = i;
        card29Array.splice(i, 1);
        card29Array.push(c);
        return;
      }
    }
  });
  canvas29.addEventListener("mousemove", e => {
    if (!canvas29Running) return;
    e.preventDefault();
    canvas29Rect = canvas29.getBoundingClientRect();
    Mouse29.x = (e.clientX - canvas29Rect.left) * canvas29Ratio;
    Mouse29.y = (e.clientY - canvas29Rect.top) * canvas29Ratio;
  });
  window.addEventListener("mouseup", e => {
    Mouse29.down = false;
    Mouse29.draggingCard = false;
    Mouse29.dragIndex = null;
    for (let i = 0; i < card29Array.length; i++) card29Array[i].dragging = false;
  });
</script>
<canvas id = "canvas28"></canvas>
<button onclick = "startCanvas28()">Start/Stop</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps28Txt"></span></b></i></div>
<div class = "desc"><b><i>(11/24/2021)</i></b> I'm trying to make a (probably pretty lame) version of Cow Evolution, using blobs. Right now I have the wandering down, and the dragging works, but I haven't added points or merging. I have a class set up with different layers for different stages of evolution but currently it only has one item, the first layer. I'm probably never going to finish this so it'll probably stay as just random blobs walking around.</div>
<hr><hr>
<script>
  const ctx28 = canvas28.getContext("2d");
  canvas28.width = canvas28.height = 1000;
  let canvas28Running = false;
  let canvas28Ratio = canvas28.width / 300;
  let canvas28Rect = canvas28.getBoundingClientRect();
  
  let blob28StepDist = 80;
  let blob28StepSpeed = 2;
  let blob28StepInterval = 100;
  
  let Mouse28 = {
    x: 0,
    y: 0,
    down: false,
    draggingBlob: false,
    dragOffsetX: 0,
    dragOffsetY: 0
  };
  
  let layers28 = [
    { // Layer 0
      width: 80,
      height: 80,
      PPS: 1,
      draw: function(x, y, ratio, dragging) {
        ctx28.fillStyle = `hsl(240deg, 100%, ${dragging ? 70 : 50}%)`;
        ctx28.strokeStyle = "black";
        ctx28.lineWidth = 3;
        ctx28.shadowColor = "black";
        ctx28.shadowBlur = dragging ? 15 : 0;
        ctx28.beginPath();
        ctx28.arc(x, y, this.width * 0.5 * ratio * (dragging ? 1.2 : 1), 0, Math.PI * 2);
        ctx28.fill();
        ctx28.stroke();
        ctx28.shadowBlur = 0;
      }
    }
  ];
  
  function Blob28(x, y, layer) {
    this.x = x;
    this.y = y;
    this.layer = layers28[layer];
    this.willStep = Math.round(blob28StepInterval * randBetween(0.2, 1));
    this.stepAge = Math.floor(Math.random() * this.willStep);
    this.destination = {x: this.x, y: this.y};
    this.stepping = false;
    this.sizeRatio = randBetween(0.8, 1);
    this.stepSpeed = blob28StepSpeed * randBetween(0.75, 1);
    this.dragging = false;
  }
  Blob28.prototype.render = function() {
    if (this.dragging) {
      this.x = Mouse28.x + Mouse28.dragOffsetX;
      this.y = Mouse28.y + Mouse28.dragOffsetY;
      this.destination.x = this.x;
      this.destination.y = this.y;
      this.stepping = false;
      this.stepAge = 0;
    }
    
    if (!this.stepping) this.stepAge++;
    if (this.stepAge >= this.willStep) {
      this.stepAge = 0;
      this.willStep = Math.round(blob28StepInterval * randBetween(0.2, 1));
      this.stepSpeed = blob28StepSpeed * randBetween(0.75, 1);
      let a = Math.random() * Math.PI * 2;
      let v = blob28StepDist * randBetween(0.75, 1);
      this.destination.x = this.x + (v * Math.cos(a));
      this.destination.y = this.y + (v * Math.sin(a));
    }
    
    let dx = this.destination.x - this.x;
    let dy = this.destination.y - this.y;
    let distSq = (dx * dx) + (dy * dy);
    if (distSq <= 100) {
      this.destination.x = this.x;
      this.destination.y = this.y;
      this.stepping = false;
    }
    else {
      let a = Math.atan2(dy, dx);
      this.x += this.stepSpeed * Math.cos(a);
      this.y += this.stepSpeed * Math.sin(a);
      this.stepping = true;
    }
    
    this.destination.x = this.destination.x.clamp(0, canvas28.width);
    this.destination.y = this.destination.y.clamp(0, canvas28.height);
    
    this.layer.draw(this.x, this.y, this.sizeRatio, this.dragging);
  };
  let blob28Array = [];
  
  function reset28() {
    blob28Array = [];
    for (let i = 0; i < 25; i++) blob28Array.push(new Blob28(Math.random() * canvas28.width, Math.random() * canvas28.height, 0));
  }
  reset28();
  
  let lastFrame28Time = 0;
  let lastFps28DisplayTime = 1000;
  
  function frame28() {
    if (Date.now() - lastFps28DisplayTime >= 500) {
      fps28Txt.innerHTML = (1000 / (Date.now() - lastFrame28Time)).toFixed(1);
      lastFps28DisplayTime = Date.now();
    }
    lastFrame28Time = Date.now();
    
    ctx28.clearRect(0, 0, canvas28.width, canvas28.height);
    
    for (let i = 0; i < blob28Array.length; i++) blob28Array[i].render();
    
    if (canvas28Running) requestAnimationFrame(frame28);
  }
  frame28();
  
  function startCanvas28() {
    if (canvas28Running) canvas28Running = false;
    else {
      canvas28Running = true;
      frame28();
    }
  }
  
  canvas28.addEventListener("mousedown", e => {
    if (!canvas28Running) return;
    Mouse28.down = true;
    canvas28Rect = canvas28.getBoundingClientRect();
    Mouse28.x = (e.clientX - canvas28Rect.left) * canvas28Ratio;
    Mouse28.y = (e.clientY - canvas28Rect.top) * canvas28Ratio;
    for (let i = 0; i < blob28Array.length; i++) {
      let b = blob28Array[i];
      let w = b.layer.width * b.sizeRatio;
      let h = b.layer.height * b.sizeRatio;
      let _x = b.x - (w / 2);
      let _y = b.y - (h / 2);
      let topBottom = Mouse28.x > _x && Mouse28.x < _x + w;
      let leftRight = Mouse28.y > _y && Mouse28.y < _y + h;
      if (topBottom && leftRight) {
        Mouse28.draggingBlob = true;
        Mouse28.dragOffsetX = b.x - Mouse28.x;
        Mouse28.dragOffsetY = b.y - Mouse28.y;
        b.dragging = true;
        blob28Array.splice(i, 1);
        blob28Array.push(b);
        return;
      }
    }
  });
  canvas28.addEventListener("mousemove", e => {
    if (!canvas28Running) return;
    canvas28Rect = canvas28.getBoundingClientRect();
    Mouse28.x = (e.clientX - canvas28Rect.left) * canvas28Ratio;
    Mouse28.y = (e.clientY - canvas28Rect.top) * canvas28Ratio;
  });
  window.addEventListener("mouseup", e => {
    Mouse28.down = false;
    Mouse28.draggingBlob = false;
    for (let i = 0; i < blob28Array.length; i++) blob28Array[i].dragging = false;
  });
</script>
<canvas id = "canvas27" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas27()">Start/Stop</button>
<button onclick = "reset27()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps27Txt"></span></b></i></div>
<div><b><u>Number of Pixels:</u></b> <span id = "numPixels27Txt">0</span></div>
<div><b><u>Grid Size:</u></b> <span id = "gridSize27Txt">500&times;500</span></div>
<input type = "range" min = "0" max = "10" step = "1" value = "0" id = "gridSize27Range" oninput = "updateSettings27(true)">
<div><b><u>Stickiness:</u></b> <span id = "stickiness27Txt">100</span>%</div>
<input type = "range" min = "0" max = "10" step = "1" value = "0" id = "stickiness27Range" oninput = "updateSettings27(false)">
<div><b><u>Turn Chance:</u></b> <span id = "turnChance27Txt">5</span>%</div>
<input type = "range" min = "0" max = "10" step = "1" value = "0" id = "turnChance27Range" oninput = "updateSettings27(false)">
<div><b><u>Hue Step:</u></b> <span id = "hueStep27Txt">0.01</span>&deg;</div>
<input type = "range" min = "0" max = "10" step = "1" value = "0" id = "hueStep27Range" oninput = "updateSettings27(false)">
<div><b><u>Initial Shape:</u></b></div>
<input type = "radio" name = "spawnMode27Radio" id = "spawnMode27Radio1" oninput = "updateSettings27(true)" CHECKED>
<label for = "spawnMode27Radio1">Dot in middle</label>
<br>
<input type = "radio" name = "spawnMode27Radio" id = "spawnMode27Radio2" oninput = "updateSettings27(true)">
<label for = "spawnMode27Radio2">Line at bottom</label>
<div class = "desc"><b><i>(11/18/2021)</i></b> I redid my old DLA aligned to a grid project, this time using a cached array keeping track of the states of all the pixels, instead of manually checking every pixel every step, making it ridiculously faster. Like, a 100x100 grid would take 10,000 steps EVERY time the Walker moved, whereas this one only checks its current position. I also added colors, and a turn chance setting (currently set to 5%), so that the walker only has a X% chance to turn each step, instead of definitely turning every step, which makes it reach the pixels faster (since it spends less time wandering aimlessly), and still makes a really interesting coral-like pattern. Interestingly, the resulting pattern with a low turn chance is basically just a denser version of the classic one, which I think looks better actually.<br><b><i>Update: (Later that day)</i></b> Added a stickiness setting, for the chance of a pixel sticking versus continuing to wander when it touches something (currently set to 100%).<br><b><i>(11/22/2021)</i></b> Added a tracker for the current number of pixels, different spawning modes, and more sliders.</div>
<hr><hr>
<script>
  const ctx27 = canvas27.getContext("2d");
  canvas27.width = canvas27.height = 1000;
  let canvas27Running = false;
  
  let grid27 = [];
  let gridSize27 = 500;
  let tileSize27 = canvas27.width / gridSize27;
  let stepsPerFrame27 = 250000;
  let turnChance27 = 0.05;
  let hueStep27 = 0.01;
  let stickiness27 = 1;
  let drawMode27 = 1;
  let numPixels27 = 0;
  let spawnMode27 = 1;
  
  let Walker27 = {};
  Walker27.newPos = function() {
    if (spawnMode27 === 1) {
      let side = Math.floor(Math.random() * 4);
      if (side === 0) { // Left
        this.x = 0;
        this.y = Math.floor(Math.random() * gridSize27);
        this.dir = 1;
      }
      else if (side === 1) { // Top
        this.x = Math.floor(Math.random() * gridSize27);
        this.y = 0;
        this.dir = 2;
      }
      else if (side === 2) { // Right
        this.x = gridSize27 - 1;
        this.y = Math.floor(Math.random() * gridSize27);
        this.dir = 3;
      }
      else { // Bottom
        this.x = Math.floor(Math.random() * gridSize27);
        this.y = gridSize27 - 1;
        this.dir = 0;
      }
    }
    else if (spawnMode27 === 2) {
      this.x = Math.floor(Math.random() * gridSize27);
      this.y = 0;
      this.dir = 2;
    }
    if (grid27[this.x][this.y]) this.running = false;
  };
  Walker27.walk = function() {
    if (!this.running) return;
    if (Math.random() < turnChance27) this.dir = Math.floor(Math.random() * 4);
    if (this.dir === 0) this.y--; // Up
    else if (this.dir === 1) this.x++; // Right
    else if (this.dir === 2) this.y++; // Down
    else this.x--; // Left
    this.x = (this.x + gridSize27) % gridSize27;
    if (spawnMode27 === 2) {
      if (this.y < 0) this.y = 0;
    }
    this.y = (this.y + gridSize27) % gridSize27;
    
    let middle = grid27[this.x][this.y];
    let top = grid27[this.x][(this.y - 1 + gridSize27) % gridSize27];
    if (spawnMode27 === 2) {
      if (this.y === 0) top = false;
    }
    let right = grid27[(this.x + 1) % gridSize27][this.y];
    let bottom = grid27[this.x][(this.y + 1) % gridSize27];
    let left = grid27[(this.x - 1 + gridSize27) % gridSize27][this.y];
    
    if ((middle || top || right || bottom || left) && Math.random() < stickiness27) {
      if (!middle) {
        grid27[this.x][this.y] = true;
        ctx27.fillStyle = `hsl(${this.hue}deg, 100%, 50%)`;
        if (drawMode27 === 1) ctx27.fillRect(this.x * tileSize27, this.y * tileSize27, tileSize27, tileSize27);
        else if (drawMode27 === 2) {
          ctx27.globalAlpha = 0.1;
          ctx27.fillCircle(this.x * tileSize27, this.y * tileSize27, tileSize27 * 3);
          ctx27.globalAlpha = 1;
        }
        this.hue += hueStep27;
        numPixels27++;
      }
      this.newPos();
    }
  };
  function reset27() {
    ctx27.fillStyle = "black";
    ctx27.fillRect(0, 0, canvas27.width, canvas27.height);
    
    tileSize27 = canvas27.width / gridSize27;
    grid27 = [];
    for (let x = 0; x < gridSize27; x++) {
      let row = [];
      for (let y = 0; y < gridSize27; y++) {
        row.push(false);
      }
      grid27.push(row);
    }
    
    numPixels27 = 0;
    Walker27.hue = Math.random() * 360;
    ctx27.fillStyle = `hsl(${Walker27.hue}deg, 100%, 50%)`;
    
    let _x = 0;
    let _y = 0;
    if (spawnMode27 === 1) {
      _x = Math.floor(gridSize27 / 2);
      _y = Math.floor(gridSize27 / 2);
      grid27[_x][_y] = true;
      ctx27.fillRect(_x * tileSize27, _y * tileSize27, tileSize27, tileSize27);
      numPixels27++;
    }
    else if (spawnMode27 === 2) {
      for (let x = 0; x < gridSize27; x++) {
        grid27[x][gridSize27 - 1] = true;
        Walker27.hue += hueStep27;
        ctx27.fillStyle = `hsl(${Walker27.hue}deg, 100%, 50%)`;
        ctx27.fillRect(x * tileSize27, (gridSize27 - 1) * tileSize27, tileSize27, tileSize27);
        numPixels27++;
      }
    }
    
    numPixels27Txt.innerHTML = numPixels27.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    
    Walker27.running = true;
    Walker27.newPos();
  }
  reset27();
  
  let lastFrame27Time = 0;
  let lastFps27DisplayTime = 1000;
  
  function frame27() {
    if (Date.now() - lastFps27DisplayTime >= 500) {
      fps27Txt.innerHTML = (1000 / (Date.now() - lastFrame27Time)).toFixed(1);
      lastFps27DisplayTime = Date.now();
    }
    lastFrame27Time = Date.now();
    
    for (let i = 0; i < stepsPerFrame27; i++) Walker27.walk();
    
    numPixels27Txt.innerHTML = numPixels27.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    
    if (canvas27Running) requestAnimationFrame(frame27);
  }
  frame27();
  
  function startCanvas27() {
    if (canvas27Running) canvas27Running = false;
    else {
      canvas27Running = true;
      frame27();
    }
  }
  
  let turnChance27RangeArray = [1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100];
  turnChance27Range.max = turnChance27RangeArray.length - 1;
  turnChance27Range.value = turnChance27RangeArray.indexOf(5);
  
  let hueStep27RangeArray = [0.005, 0.01, 0.02, 0.03, 0.04, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.4, 0.5, 0.75, 1];
  hueStep27Range.max = hueStep27RangeArray.length - 1;
  hueStep27Range.value = hueStep27RangeArray.indexOf(0.01);
  
  let gridSize27RangeArray = [25, 50, 75, 100, 150, 200, 250, 300, 400, 500];
  gridSize27Range.max = gridSize27RangeArray.length - 1;
  gridSize27Range.value = gridSize27RangeArray.indexOf(500);
  
  let stickiness27RangeArray = [1, 2, 3, 4, 5, 10, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100];
  stickiness27Range.max = stickiness27RangeArray.length - 1;
  stickiness27Range.value = stickiness27RangeArray.indexOf(100);
  
  function updateSettings27(reset) {
    stickiness27Txt.innerHTML = stickiness27RangeArray[Number(stickiness27Range.value)];
    stickiness27 = stickiness27RangeArray[Number(stickiness27Range.value)] / 100;
    
    turnChance27Txt.innerHTML = turnChance27RangeArray[Number(turnChance27Range.value)];
    turnChance27 = turnChance27RangeArray[Number(turnChance27Range.value)] / 100;
    
    hueStep27 = hueStep27Txt.innerHTML = hueStep27RangeArray[Number(hueStep27Range.value)];
    
    if (spawnMode27Radio1.checked) spawnMode27 = 1;
    else if (spawnMode27Radio2.checked) spawnMode27 = 2;
    
    gridSize27 = gridSize27RangeArray[Number(gridSize27Range.value)];
    gridSize27Txt.innerHTML = gridSize27 + "&times;" + gridSize27;
    
    if (reset) reset27();
  }
</script>
<canvas id = "canvas26"></canvas>
<button onclick = "drawTree26()">Redraw</button>
<table>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Recursion layers:</u></b> <span id = "maxLayers26Txt">15</span></div>
      <input type = "range" min = "1" max = "15" step = "1" value = "15" id = "maxLayers26Range" oninput = "updateSettings26()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Initial triangle size:</u></b> <span id = "startSize26Txt">400</span>px</div>
      <input type = "range" min = "50" max = "600" step = "50" value = "400" id = "startSize26Range" oninput = "updateSettings26()">
    </td>
    <td style = "padding: 10px; width: 150px" rowspan = "5">
      <div><b><u>Presets:</u></b></div>
      <div id = "presetsDiv26"></div>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Triangle left angle:</u></b> <span id = "sideAngle26Txt">60</span>&deg;</div>
      <input type = "range" min = "5" max = "85" step = "1" value = "60" id = "sideAngle26Range" oninput = "updateSettings26()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Triangle top angle:</u></b> <span id = "topAngle26Txt">90</span>&deg;</div>
      <input type = "range" min = "60" max = "120" step = "1" value = "90" id = "topAngle26Range" oninput = "updateSettings26()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "fill26Checkbox" oninput = "updateSettings26()">
      <label for = "fill26Checkbox">Fill triangles</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "stroke26Checkbox" oninput = "updateSettings26()" CHECKED>
      <label for = "stroke26Checkbox">Outline triangles</label>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Triangle hue:</u></b> <span id = "hue26Txt">180</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "15" value = "180" id = "hue26Range" oninput = "updateSettings26()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Hue variation:</u></b> <span id = "hueVariation26Txt">0</span>%</div>
      <input type = "range" min = "0" max = "100" step = "5" value = "0" id = "hueVariation26Range" oninput = "updateSettings26()">
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(11/16/2021)</i></b> Nested triangle tree generator, based on <a href = "https://turtletoy.net/turtle/77a93d1394" target = "_blank">this</a> Turtletoy project.<br><b><i>(11/17/2021)</i></b> Added more settings and sliders, as well as a few presets.</div>
<hr><hr>
<script>
  const ctx26 = canvas26.getContext("2d");
  canvas26.width = canvas26.height = 1000;
  
  let sideAngle26 = 60; // Left angle
  let topAngle26 = 90;
  let maxLayers26 = 15;
  let startX26 = canvas26.width / 2;
  let startY26 = 700;
  let startSize26 = 400;
  let fill26 = false;
  let stroke26 = true;
  let hue26 = 180;
  let hueVariation26 = 0;
  
  let presetsArray26 = [
    {
      sideAngle26: 60,
      topAngle26: 90,
      maxLayers26: 15,
      fill26: false,
      stroke26: true,
      hue26: 180,
      hueVariation26: 0,
      startSize26: 400
    },
    {
      sideAngle26: 45,
      topAngle26: 90,
      maxLayers26: 11,
      fill26: true,
      stroke26: true,
      hue26: 0,
      hueVariation26: 20,
      startSize26: 450
    },
    {
      sideAngle26: 50,
      topAngle26: 80,
      maxLayers26: 12,
      fill26: true,
      stroke26: false,
      hue26: 60,
      hueVariation26: 0,
      startSize26: 300
    },
    {
      sideAngle26: 40,
      topAngle26: 100,
      maxLayers26: 15,
      fill26: true,
      stroke26: false,
      hue26: 315,
      hueVariation26: 0,
      startSize26: 600
    },
    {
      sideAngle26: 60,
      topAngle26: 60,
      maxLayers26: 15,
      fill26: true,
      stroke26: false,
      hue26: 210,
      hueVariation26: 30,
      startSize26: 150
    }
  ];
  function loadPreset26(n) {
    let p = presetsArray26[n];
    sideAngle26Range.value = p.sideAngle26;
    topAngle26Range.value = p.topAngle26;
    maxLayers26Range.value = p.maxLayers26;
    fill26Checkbox.checked = p.fill26;
    stroke26Checkbox.checked = p.stroke26;
    hue26Range.value = p.hue26;
    hueVariation26Range.value = p.hueVariation26;
    startSize26Range.value = p.startSize26;
    
    updateSettings26();
  }
  for (let i = 0; i < presetsArray26.length; i++) {
    let btn = document.createElement("button");
    btn.innerHTML = i + 1;
    btn.onclick = () => loadPreset26(i);
    btn.style.borderRadius = "50%";
    btn.style.margin = "5px";
    
    presetsDiv26.appendChild(btn);
  }
  
  function drawTriangle26(x, y, angle, lenBase, layer) {
    if (layer > maxLayers26) return;
    //sideAngle26 = randBetween(Number(sideAngle26Range.min) + 10, Number(sideAngle26Range.max) - 10);
    let angleLeft = 180 - (sideAngle26 + topAngle26);
    let lenLeft = (lenBase / Math.sin(toRad(topAngle26))) * Math.sin(toRad(angleLeft));
    let lenRight = (lenBase / Math.sin(toRad(topAngle26))) * Math.sin(toRad(sideAngle26));
    let currX = x;
    let currY = y;
    let currAngle = angle;
    ctx26.beginPath();
    ctx26.moveTo(currX, currY);
    currAngle -= sideAngle26;
    currX += lenLeft * Math.cos(toRad(currAngle));
    currY += lenLeft * Math.sin(toRad(currAngle));
    let top = {x: currX, y: currY};
    ctx26.lineTo(currX, currY);
    currAngle += 180 - topAngle26;
    currX += lenRight * Math.cos(toRad(currAngle));
    currY += lenRight * Math.sin(toRad(currAngle));
    ctx26.lineTo(currX, currY);
    ctx26.lineTo(x, y);
    let hue = hue26 + randBetween(-180 * hueVariation26, 180 * hueVariation26);
    ctx26.fillStyle = `hsla(${hue}deg, 100%, 50%, 0.5)`;
    ctx26.strokeStyle = `hsl(${hue}deg, 100%, 50%)`;
    if (fill26) ctx26.fill();
    if (stroke26) ctx26.stroke();
    
    drawTriangle26(x, y, angle - sideAngle26, lenLeft, layer + 1);
    drawTriangle26(top.x, top.y, angle + (180 - (topAngle26 + sideAngle26)), lenRight, layer + 1);
  }
  
  function drawTree26() {
    ctx26.fillStyle = "black";
    ctx26.fillRect(0, 0, canvas26.width, canvas26.height);
    
    drawTriangle26(startX26 - (startSize26 / 2), startY26, 0, startSize26, 1);
  }
  drawTree26();
  
  function updateSettings26() {
    topAngle26 = topAngle26Txt.innerHTML = Number(topAngle26Range.value);
    sideAngle26Range.max = 175 - topAngle26;
    sideAngle26 = sideAngle26Txt.innerHTML = Number(sideAngle26Range.value);
    maxLayers26 = maxLayers26Txt.innerHTML = Number(maxLayers26Range.value);
    fill26 = fill26Checkbox.checked;
    stroke26 = stroke26Checkbox.checked;
    hue26 = hue26Txt.innerHTML = Number(hue26Range.value);
    hueVariation26Txt.innerHTML = hueVariation26Range.value;
    hueVariation26 = Number(hueVariation26Range.value) / 100;
    startSize26 = startSize26Txt.innerHTML = Number(startSize26Range.value);
    
    drawTree26();
  }
</script>
<canvas id = "canvas25"></canvas>
<button onclick = "startCanvas25()">Start/Stop</button>
<button onclick = "resetWalkers25()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps25Txt"></span></b></i></div>
<div class = "desc"><b><i>(11/10/2021)</i></b> I tried to replicate the pattern in <a href = "https://www.onirom.fr/get/compart/chaos/050.png" target = "_blank">this</a> image, using Curlicue fractals, but I couldn't get it to quite look right.</div>
<hr><hr>
<script>
  const ctx25 = canvas25.getContext("2d");
  canvas25.width = canvas25.height = 2000;
  let canvas25Running = false;
  
  let stepsPerFrame25 = 100;
  let numWalkers25 = 25//50;
  let walker25Speed = 2;
  
  function Walker25() {
    this.x = Math.random() * canvas25.width;
    this.y = Math.random() * canvas25.height;
    this.theta = Math.random() * Math.PI * 2;
    this.phi = Math.random() * Math.PI * 2;
    this.step = Math.random();//Math.PI * randBetween(0.5, 1.5);
    this.color = `hsl(${randBetween(100, 140)}deg, ${randBetween(80, 100)}%, ${randBetween(30, 60)}%)`;
  }
  Walker25.prototype.walk = function() {
    let lastX = this.x;
    let lastY = this.y;
    this.theta = (this.theta + (this.step * Math.PI * 2)) % (Math.PI * 2);
    this.phi = (this.phi + this.theta) % (Math.PI * 2);
    
    this.x += walker25Speed * Math.cos(this.phi);
    this.y += walker25Speed * Math.sin(this.phi);
    
    if (this.x > canvas25.width) this.x = lastX = 0;
    if (this.x < 0) this.x = lastX = canvas25.width;
    if (this.y > canvas25.height) this.y = lastY = 0;
    if (this.y < 0) this.y = lastY = canvas25.height;
    
    ctx25.strokeStyle = this.color;
    ctx25.beginPath();
    ctx25.moveTo(lastX, lastY);
    ctx25.lineTo(this.x, this.y);
    ctx25.stroke();
  };
  let walker25Array = [];
  function resetWalkers25() {
    ctx25.fillStyle = "black";
    ctx25.fillRect(0, 0, canvas25.width, canvas25.height);
    walker25Array = [];
    for (let i = 0; i < numWalkers25; i++) walker25Array.push(new Walker25());
  }
  resetWalkers25();
  
  let lastFrame25Time = 0;
  let lastFps25DisplayTime = 1000;
  
  function frame25() {
    if (Date.now() - lastFps25DisplayTime >= 500) {
      fps25Txt.innerHTML = (1000 / (Date.now() - lastFrame25Time)).toFixed(1);
      lastFps25DisplayTime = Date.now();
    }
    lastFrame25Time = Date.now();
    
    for (let j = 0; j < stepsPerFrame25; j++) {
      for (let i = 0; i < walker25Array.length; i++) walker25Array[i].walk();
    }
    
    if (canvas25Running) requestAnimationFrame(frame25);
  }
  frame25();
  
  function startCanvas25() {
    if (canvas25Running) canvas25Running = false;
    else {
      canvas25Running = true;
      frame25();
    }
  }
</script>
<canvas id = "canvas24"></canvas>
<button onclick = "startCanvas24()">Start/Stop</button>
<button onclick = "resetWalkers24()">Reset</button>
<button onclick = "rainbow24 = !rainbow24">Rainbow On/Off</button>
<button onclick = "mode24 = mode24 === 1 ? 2 : 1; resetWalkers24()">Switch Circle/Spiral</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps24Txt"></span></b></i></div>
<div class = "desc"><b><i>(11/5/2021)</i></b> An experiment with giving random walkers a direction bias, which actually worked the first try. Now they all crawl out in more of a circle formation, instead of randomly walking clumped in the middle, or in a spiral shape. This can be used for lots of different designs and shapes.</div>
<hr><hr>
<script>
  const ctx24 = canvas24.getContext("2d");
  canvas24.width = canvas24.height = 1000;
  let canvas24Running = false;
  
  let numWalkers24 = 200;
  let walker24Speed = 1;
  let stepsPerFrame24 = 15;
  let walker24Alignment = 2;
  let rainbow24 = false;
  let mode24 = 1;
  
  function Walker24(x, y, directionBias) {
    this.x = x;
    this.y = y;
    this.directionBias = directionBias;
    this.color = `hsl(${toDeg(this.directionBias)}deg, 100%, 40%)`;
  }
  Walker24.prototype.walk = function() {
    let lastX = this.x;
    let lastY = this.y;
    let r = 1;
    //r = Math.pow(Math.random(), walker24Alignment);
    for (let i = 0; i < walker24Alignment; i++) r *= Math.random();
    //r = Math.random() % Math.random();
    let a = this.directionBias + (r * Math.PI * 2 * randSign());
    //this.directionBias += Math.random() * 0.05 * randSign();
    let m = Math.random() * walker24Speed;
    this.x += m * Math.cos(a);
    this.y += m * Math.sin(a);
    ctx24.strokeStyle = rainbow24 ? this.color : "black";
    ctx24.beginPath();
    ctx24.moveTo(lastX, lastY);
    ctx24.lineTo(this.x, this.y);
    ctx24.stroke();
  };
  let walker24Array = [];
  function resetWalkers24() {
    ctx24.clearRect(0, 0, canvas24.width, canvas24.height);
    walker24Array = [];
    if (mode24 === 1) { // Circle
      for (let i = 0; i < numWalkers24; i++) {
        let a = (i / numWalkers24) * Math.PI * 2;
        let x = (canvas24.width / 2) + (100 * Math.cos(a));
        let y = (canvas24.height / 2) + (100 * Math.sin(a));
        walker24Array.push(new Walker24(x, y, a));
      }
    }
    else if (mode24 === 2) { // Spiral
      for (let i = 0; i < numWalkers24; i++) {
        let a = (i / numWalkers24) * Math.PI * 4;
        let r = (i / numWalkers24) * 200;
        let x = (canvas24.width / 2) + (r * Math.cos(a));
        let y = (canvas24.height / 2) + (r * Math.sin(a));
        walker24Array.push(new Walker24(x, y, a + (Math.PI / 2)));
      }
    }
  }
  resetWalkers24();
  
  let lastFrame24Time = 0;
  let lastFps24DisplayTime = 1000;
  
  function frame24() {
    if (Date.now() - lastFps24DisplayTime >= 500) {
      fps24Txt.innerHTML = (1000 / (Date.now() - lastFrame24Time)).toFixed(1) + (canvas24Running ? "" : " (PAUSED)");;
      lastFps24DisplayTime = Date.now();
    }
    lastFrame24Time = Date.now();
    
    for (let j = 0; j < stepsPerFrame24; j++) {
      for (let i = 0; i < walker24Array.length; i++) walker24Array[i].walk();
    }
    
    if (canvas24Running) requestAnimationFrame(frame24);
  }
  frame24();
  
  function startCanvas24() {
    if (canvas24Running) canvas24Running = false;
    else {
      canvas24Running = true;
      frame24();
    }
  }
</script>
<canvas id = "canvas23"></canvas>
<button onclick = "startCanvas23()">Start/Stop</button>
<button onclick = "Walker23.reset()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps23Txt"></span></b></i></div>
<div style = "font-weight: bold; font-style: italic; margin: 5px" id = "running23Txt"></div>
<input type = "checkbox" id = "reverseContrast23Checkbox" oninput = "updateSettings23(true)">
<label for = "reverseContrast23Checkbox">Reverse Contrast</label>
<div><b><u>Grid Size:</u></b> <span id = "gridSize23Txt">50&times;50</span></div>
<input type = "range" min = "0" max = "10" step = "1" value = "0" id = "gridSize23Range" oninput = "updateSettings23(true)">
<div><b><u>Density:</u></b> <span id = "density23Txt">30</span>%</div>
<input type = "range" min = "5" max = "100" step = "5" value = "30" id = "density23Range" oninput = "updateSettings23(false)">
<div><b><u>Turn Chance:</u></b> <span id = "turnChance23Txt">20</span>%</div>
<input type = "range" min = "0" max = "100" step = "5" value = "20" id = "turnChance23Range" oninput = "updateSettings23(false)">
<div class = "desc"><b><i>(11/4/2021)</i></b> An attempt to replicate the self-playing snake game from <a href = "https://www.reddit.com/r/PlotterArt/comments/mk18km/plotter_playing_snake_against_itself" target = "_blank">this</a> Reddit post, but I spent ages trying to get it to turn and could not figure it out to save my life. Right now it just randomly turns, but it doesn't steer away from it's own body like I was trying to get it to do.<br><b><i>(11/5/2021)</i></b> Modified the code some so that there's adjustable density and each new path is a different color, and I like how it turned out. Now it reminds me of subway maps and it actually looks interesting.<br><b><i>Update: (Later that day)</i></b> Added settings and sliders for everything.</div>
<hr><hr>
<script>
  const ctx23 = canvas23.getContext("2d");
  canvas23.width = canvas23.height = 2000;
  let canvas23Running = false;
  
  let gridSize23 = 50;
  let tileSize23 = canvas23.width / gridSize23;
  let stepsPerFrame23 = 50;
  let minHeadLength23 = 2;
  let density23 = 0.3;
  let reverseContrast23 = false;
  let turnChance23 = 0.2;
  
  let Walker23 = {};
  Walker23.reset = function() {
    this.stopped = false;
    ctx23.fillStyle = reverseContrast23 ? "black" : "white";
    ctx23.fillRect(0, 0, canvas23.width, canvas23.height);
    tileSize23 = canvas23.width / gridSize23;
    this.pointsLeft = [];
    for (let x = 0; x < gridSize23; x++) {
      for (let y = 0; y < gridSize23; y++) {
        this.pointsLeft.push({x: x, y: y});
      }
    }
    this.globalAge = 0;
    this.newPos();
    if (!canvas23Running) frame23();
  };
  Walker23.splicePoint = function(x, y) {
    if (this.stopped) return;
    for (let i = 0; i < this.pointsLeft.length; i++) {
      if (this.pointsLeft[i].x === x && this.pointsLeft[i].y === y) {
        this.pointsLeft.splice(i, 1);
        return;
      }
    }
    if (this.pointsLeft.length <= (gridSize23 * gridSize23) * (1 - density23)) this.stopped = true;
  };
  Walker23.validatePoint = function(x, y) {
    if (this.stopped) return;
    for (let i = 0; i < this.pointsLeft.length; i++) {
      if (this.pointsLeft[i].x === x && this.pointsLeft[i].y === y) {
        return true;
      }
    }
    return false;
  }
  Walker23.newPos = function() {
    if (this.stopped || this.pointsLeft.length <= (gridSize23 * gridSize23) * (1 - density23)) {
      this.stopped = true;
      return;
    }
    let i = Math.floor(Math.random() * this.pointsLeft.length);
    let pos = this.pointsLeft[i];
    this.x = pos.x;
    this.y = pos.y;
    this.splicePoint(this.x, this.y);
    this.dir = Math.floor(Math.random() * 4);
    this.turns = 0;
    this.age = 0;
    this.color = `hsl(${Math.random() * 360}deg, 100%, ${reverseContrast23 ? 60 : 40}%)`;
  };
  Walker23.checkDir = function(dir) {
    if (dir === 0) return this.validatePoint(this.x - 1, this.y);
    else if (dir === 1) return this.validatePoint(this.x + 1, this.y);
    else if (dir === 2) return this.validatePoint(this.x, this.y - 1);
    else return this.validatePoint(this.x, this.y + 1);
  };
  Walker23.walk = function() {
    if (this.stopped || this.pointsLeft.length <= (gridSize23 * gridSize23) * (1 - density23)) {
      this.stopped = true;
      return;
    }
    this.globalAge++;
    this.age++;
    let lastX = this.x;
    let lastY = this.y;
    if (this.dir === 0) this.x--;
    else if (this.dir === 1) this.x++;
    else if (this.dir === 2) this.y--;
    else this.y++;
    if (Math.random() < turnChance23) this.dir = Math.floor(Math.random() * 4);
    //if (this.age % 4 === 0) this.dir = Math.floor(Math.random() * 4);
    if (this.validatePoint(this.x, this.y)) {
      ctx23.lineWidth = tileSize23 * 0.3;
      ctx23.lineCap = ctx23.lineJoin = "round";
      ctx23.strokeStyle = this.color//`hsl(${this.globalAge / 4}deg, 100%, 40%)`;
      ctx23.beginPath();
      ctx23.moveTo((lastX + 0.5) * tileSize23, (lastY + 0.5) * tileSize23);
      ctx23.lineTo((this.x + 0.5) * tileSize23, (this.y + 0.5) * tileSize23);
      ctx23.stroke();
      this.splicePoint(this.x, this.y);
    }
    else {
      ctx23.fillStyle = this.color//`hsl(${this.globalAge / 4}deg, 100%, 40%)`;
      if (this.age > minHeadLength23) ctx23.fillCircle((lastX + 0.5) * tileSize23, (lastY + 0.5) * tileSize23, tileSize23 * 0.45);
      this.newPos();
    }
  };
  
  let lastFrame23Time = 0;
  let lastFps23DisplayTime = 1000;
  
  function frame23() {
    if (Date.now() - lastFps23DisplayTime >= 500) {
      fps23Txt.innerHTML = (1000 / (Date.now() - lastFrame23Time)).toFixed(1) + (canvas23Running ? "" : " (PAUSED)");
      lastFps23DisplayTime = Date.now();
    }
    lastFrame23Time = Date.now();
    
    for (let i = 0; i < stepsPerFrame23; i++) Walker23.walk();
    
    if (Walker23.stopped) {
      running23Txt.style.color = "hsl(120deg, 50%, 40%)";
      running23Txt.innerHTML = "Done!";
    }
    else {
      running23Txt.style.color = "hsl(0deg, 50%, 40%)";
      running23Txt.innerHTML = "Running...";
    }
    
    if (canvas23Running) requestAnimationFrame(frame23);
  }
  Walker23.reset();
  frame23();
  
  function startCanvas23() {
    if (canvas23Running) canvas23Running = false;
    else {
      canvas23Running = true;
      frame23();
    }
  }
  
  let gridSize23RangeArray = [3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90, 100, 125, 150, 175, 200];
  gridSize23Range.max = gridSize23RangeArray.length - 1;
  gridSize23Range.value = gridSize23RangeArray.indexOf(50);
  
  function updateSettings23(reset) {
    gridSize23 = gridSize23RangeArray[Number(gridSize23Range.value)];
    gridSize23Txt.innerHTML = gridSize23 + "&times;" + gridSize23;
    
    density23 = Number(density23Range.value) / 100;
    density23Txt.innerHTML = density23Range.value;
    
    turnChance23 = Number(turnChance23Range.value) / 100;
    turnChance23Txt.innerHTML = turnChance23Range.value;
    
    reverseContrast23 = reverseContrast23Checkbox.checked;
    
    Walker23.stopped = false;
    if (reset) Walker23.reset();
  }
</script>
<canvas id = "canvas22" style = "width: 500px; height: 500px"></canvas>
<button onclick = "drawCircles22()">Regenerate</button>
<table>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Min Circle Radius:</u></b> <span id = "minCircle22SizeTxt">10</span>px</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "minCircle22SizeRange" oninput = "updateSettings22()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Max Circle Radius:</u></b> <span id = "maxCircle22SizeTxt">200</span>px</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "maxCircle22SizeRange" oninput = "updateSettings22()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Circle Visual Size Ratio:</u></b> <span id = "circle22SizeRatioTxt">120</span>%</div>
      <input type = "range" min = "50" max = "150" step = "5" value = "120" id = "circle22SizeRatioRange" oninput = "updateSettings22()">
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "reverseContrast22Checkbox" oninput = "updateSettings22()">
      <label for = "reverseContrast22Checkbox">Reverse contrast</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "yellowMode22Checkbox" oninput = "updateSettings22()" CHECKED>
      <label for = "yellowMode22Checkbox">Rainbow</label>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "outline22Checkbox" oninput = "updateSettings22()" CHECKED>
      <label for = "outline22Checkbox">Outline circles</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "fill22Checkbox" oninput = "updateSettings22()" CHECKED>
      <label for = "fill22Checkbox">Fill circles</label>
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(11/3/2021)</i></b> Variation on the circle packing project I did awhile ago, where it generates all at once (which speeds things up a lot) and also draws little smiley faces on each circle.</div>
<hr><hr>
<script>
  const ctx22 = canvas22.getContext("2d");
  canvas22.width = canvas22.height = 2000;
  
  let maxCircles22 = 2000;
  let canvas22Filled = false;
  let minCircle22Size = 10;
  let maxCircle22Size = 200;
  let outline22 = true;
  let fill22 = true;
  let circle22SizeRatio = 1.2;
  let reverseContrast22 = false;
  let yellowMode22 = false;
  let opacity22 = 1;
  
  function Circle22() {
    let x = Math.random() * canvas22.width;
    let y = Math.random() * canvas22.height;
    let tries = 0;
    while (!validatePoint22(x, y)) {
      if (tries > 1000) {
        canvas22Filled = true;
        return;
      }
      x = Math.random() * canvas22.width;
      y = Math.random() * canvas22.height;
      tries++;
    }
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.grow();
  }
  Circle22.prototype.grow = function() {
    let smallestDist = Infinity;
    for (let i = 0; i < circle22Array.length; i++) {
      if (i != circle22Array.indexOf(this)) {
        let dx = this.x - circle22Array[i].x;
        let dy = this.y - circle22Array[i].y;
        let distSq = (dx * dx) + (dy * dy);
        let dist = Math.sqrt(distSq) - circle22Array[i].radius;
        if (dist <= smallestDist) smallestDist = dist;
      }
    }
    let distToTop = this.y;
    if (distToTop <= smallestDist) smallestDist = distToTop;
    let distToRight = canvas22.width - this.x;
    if (distToRight <= smallestDist) smallestDist = distToRight;
    let distToBottom = canvas22.height - this.y;
    if (distToBottom <= smallestDist) smallestDist = distToBottom;
    let distToLeft = this.x;
    if (distToLeft <= smallestDist) smallestDist = distToLeft;
    this.radius = Math.min(smallestDist, maxCircle22Size);
    drawFace22(this.x, this.y, this.radius * circle22SizeRatio);
  };
  
  function drawFace22(x, y, radius) {
    ctx22.fillStyle = `hsl(${Math.random() * 360}deg, ${randBetween(80, 100)}%, ${randBetween(40, 60)}%)`;
    if (yellowMode22) ctx22.fillStyle = reverseContrast22 ? "blue" : "yellow";
    ctx22.strokeStyle = reverseContrast22 ? "white" : "black";
    ctx22.lineWidth = Math.min(radius / 5, 5);//5;
    ctx22.beginPath();
    ctx22.arc(x, y, radius, 0, Math.PI * 2);
    if (fill22) ctx22.fill();
    if (outline22) ctx22.stroke();
    
    ctx22.fillStyle = reverseContrast22 ? "white" : "black";
    ctx22.fillCircle(x - (radius * randBetween(0.3, 0.5)), y - (radius * randBetween(0.1, 0.3)), radius * 0.1);
    ctx22.fillCircle(x + (radius * randBetween(0.3, 0.5)), y - (radius * randBetween(0.1, 0.3)), radius * 0.1);
    
    ctx22.lineWidth = radius / 12;
    ctx22.lineCap = ctx22.lineJoin = "round";
    ctx22.beginPath();
    ctx22.ellipse(
      x + (radius * randBetween(-0.1, 0.1)), // x
      y + (radius * randBetween(0.1, 0.3)), // y
      radius * randBetween(0.5, 0.7), // radiusX
      radius * randBetween(0.3, 0.5), // radiusY
      toRad(randBetween(-5, 5)), // rotation
      randBetween(0.3, 0.7), // startAngle
      Math.PI - randBetween(0.3, 0.7) // endAngle
    );
    ctx22.stroke();
  }
  let circle22Array = [];
  
  function validatePoint22(x, y) {
    for (let i = 0; i < circle22Array.length; i++) {
      let dx = circle22Array[i].x - x;
      let dy = circle22Array[i].y - y;
      let distSq = (dx * dx) + (dy * dy);
      let r = circle22Array[i].radius + minCircle22Size;
      if (distSq <= r * r) return false; // Too close to a circle
    }
    if (x < minCircle22Size || x > canvas22.width - minCircle22Size) return false; // Too close to left/right
    if (y < minCircle22Size || y > canvas22.height - minCircle22Size) return false; // Too close to top/bottom
    return true;
  }
  
  function drawCircles22() {
    ctx22.globalAlpha = 1;
    ctx22.fillStyle = reverseContrast22 ? "black" : "white";
    ctx22.fillRect(0, 0, canvas22.width, canvas22.height);
    ctx22.globalAlpha = opacity22;
    canvas22Filled = false;
    circle22Array = [];
    while (circle22Array.length < maxCircles22 && !canvas22Filled) circle22Array.push(new Circle22());
  }
  drawCircles22();
  
  let minCircle22SizeRangeArray = [1, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100, 150, 200, 300, 400];
  minCircle22SizeRange.max = minCircle22SizeRangeArray.length - 1;
  minCircle22SizeRange.value = minCircle22SizeRangeArray.indexOf(10);
  minCircle22SizeRange.max = minCircle22SizeRangeArray.indexOf(maxCircle22Size);
  
  let maxCircle22SizeRangeArray = [1, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100, 150, 200, 300, 400];
  maxCircle22SizeRange.max = maxCircle22SizeRangeArray.length - 1;
  maxCircle22SizeRange.value = maxCircle22SizeRangeArray.indexOf(200);
  
  function updateSettings22() {
    maxCircle22Size = maxCircle22SizeTxt.innerHTML = maxCircle22SizeRangeArray[Number(maxCircle22SizeRange.value)];
    minCircle22SizeRange.max = minCircle22SizeRangeArray.indexOf(maxCircle22Size);
    minCircle22Size = minCircle22SizeTxt.innerHTML = minCircle22SizeRangeArray[Number(minCircle22SizeRange.value)];
    circle22SizeRatio = Number(circle22SizeRatioRange.value) / 100;
    circle22SizeRatioTxt.innerHTML = circle22SizeRatioRange.value;
    outline22 = outline22Checkbox.checked;
    fill22 = fill22Checkbox.checked;
    reverseContrast22 = reverseContrast22Checkbox.checked;
    yellowMode22 = !yellowMode22Checkbox.checked;
  }
</script>
<canvas id = "canvas21"></canvas>
<button onclick = "drawRocks21()">Regenerate</button>
<div class = "desc"><b><i>(11/2/2021)</i></b> Messing around with generating random rock-like shapes, it's not the best but I like how it turned out.</div>
<hr><hr>
<script>
  const ctx21 = canvas21.getContext("2d");
  canvas21.width = canvas21.height = 1000;
  
  let gridSize21 = 10;
  let tileSize21 = canvas21.width / gridSize21;
  
  function drawOneRock21(x, y, size) {
    let points = Math.round(randBetween(3, 10));
    let offsetAngle = Math.random() * Math.PI * 2;
    ctx21.lineWidth = 3;
    ctx21.lineCap = ctx21.lineJoin = "round";
    ctx21.fillStyle = `hsl(0deg, 0%, ${randBetween(30, 70)}%)`;
    ctx21.beginPath();
    for (let i = 0; i < points; i++) {
      let a1 = toRad(((i / points) * 360) + randBetween(-10, 10) + offsetAngle);
      let r1 = size * randBetween(0.8, 1);
      let a2 = toRad((((i + randBetween(0.4, 0.6)) / points) * 360) + randBetween(-10, 10) + offsetAngle);
      let r2 = size * randBetween(0.8, 1);
      ctx21.quadraticCurveTo(x + (r1 * Math.cos(a1)), y + (r1 * Math.sin(a1)), x + (r2 * Math.cos(a2)), y + (r2 * Math.sin(a2)));
      /*let a = toRad(((i / points) * 360) + randBetween(-10, 10) + offsetAngle);
      let r = size * randBetween(0.8, 1);
      ctx21.lineTo(x + (r * Math.cos(a)), y + (r * Math.sin(a)));*/
    }
    ctx21.closePath();
    ctx21.fill();
    ctx21.stroke();
  }
  
  function drawRocks21() {
    ctx21.fillStyle = "#4b371c";
    ctx21.fillRect(0, 0, canvas21.width, canvas21.height);
    
    tileSize21 = canvas21.width / gridSize21;
    
    for (let x = 0; x < gridSize21; x++) {
      for (let y = 0; y < gridSize21; y++) {
        drawOneRock21((x + randBetween(0.4, 0.6)) * tileSize21, (y + randBetween(0.4, 0.6)) * tileSize21, tileSize21 * randBetween(0.3, 0.45));
      }
    }
  }
  drawRocks21();
</script>
<canvas id = "canvas20"></canvas>
<button onclick = "startCanvas20()">Start/Stop</button>
<button onclick = "resetSquares20()">Reset</button>
<button onclick = "reverseContrast20 = !reverseContrast20; if (!canvas20Running) frame20()">Switch Contrast</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps20Txt"></span></b></i></div>
<div class = "desc"><b><i>(11/1/2021)</i></b> Square animation I was messing around with: each square grows at the same speed and if there's 9 touching squares that are all at their max size, they all get their sizes reset (to a random value below 0, so that they don't stay aligned).</div>
<hr><hr>
<script>
  const ctx20 = canvas20.getContext("2d");
  canvas20.width = canvas20.height = 1000;
  let canvas20Running = false;
  
  let growSpeed20 = 0.4;
  let reverseContrast20 = false;
  let resetChance20 = 1//0.8;
  let gridSize20 = 25;
  let tileSize20 = canvas20.width / gridSize20;
  
  function Square20(x, y, growSpeed, maxSize, hue) {
    this.x = x;
    this.y = y;
    this.growSpeed = growSpeed;//randBetween(0.2, 0.8);
    this.maxSize = maxSize;
    this.size = randBetween(-this.maxSize / 2, 0);//0
    this.stopped = false;
    this.hue = hue;
    this.willStart = false;
  }
  Square20.prototype.render = function() {
    if (!this.stopped) this.size += this.growSpeed;
    if (this.size >= this.maxSize) {
      this.size = this.maxSize;
      this.stopped = true;
    }
    let size = this.stopped ? this.size : Math.max(this.size, 0);
    let brightness = reverseContrast20 ? (size / this.maxSize) * 100 : (1 - (size / this.maxSize)) * 100;
    let stoppedColor = reverseContrast20 ? "white" : "black";
    ctx20.fillStyle = this.stopped ? stoppedColor : `hsl(${this.hue}deg, 40%, ${brightness}%)`;
    ctx20.fillRectFromCenter(this.x, this.y, size, size);
    //ctx20.fillCircle(this.x, this.y, Math.max(this.size / 2, 0));
  };
  let square20Array = [];
  function resetSquares20() {
    tileSize20 = canvas20.width / gridSize20;
    square20Array = [];
    ctx20.clearRect(0, 0, canvas20.width, canvas20.height);
    for (let x = 0; x < gridSize20; x++) {
      let row = [];
      for (let y = 0; y < gridSize20; y++) {
        row.push(new Square20((x + 0.5) * tileSize20, (y + 0.5) * tileSize20, growSpeed20, tileSize20, Math.random() * 360));
      }
      square20Array.push(row);
    }
  }
  resetSquares20();
  
  let lastFrame20Time = 0;
  let lastFps20DisplayTime = 1000;
  
  function frame20() {
    if (Date.now() - lastFps20DisplayTime >= 500) {
      fps20Txt.innerHTML = (1000 / (Date.now() - lastFrame20Time)).toFixed(1);
      lastFps20DisplayTime = Date.now();
    }
    lastFrame20Time = Date.now();
    
    ctx20.fillStyle = reverseContrast20 ? "black" : "white";
    ctx20.fillRect(0, 0, canvas20.width, canvas20.height);
    
    for (let x = 0; x < gridSize20; x++) {
      for (let y = 0; y < gridSize20; y++) {
        square20Array[x][y].render();
        let M = square20Array[x][y];
        let T = square20Array[x][(y - 1 + gridSize20) % gridSize20];
        let TR = square20Array[(x + 1) % gridSize20][(y - 1 + gridSize20) % gridSize20];
        let R = square20Array[(x + 1) % gridSize20][y];
        let BR = square20Array[(x + 1) % gridSize20][(y + 1) % gridSize20];
        let B = square20Array[x][(y + 1) % gridSize20];
        let BL = square20Array[(x - 1 + gridSize20) % gridSize20][(y + 1) % gridSize20];
        let L = square20Array[(x - 1 + gridSize20) % gridSize20][y];
        let TL = square20Array[(x - 1 + gridSize20) % gridSize20][(y - 1 + gridSize20) % gridSize20];
        if (M.stopped && T.stopped && R.stopped && B.stopped && L.stopped && TR.stopped && BR.stopped && BL.stopped && TL.stopped) {
          M.willStart = T.willStart = R.willStart = B.willStart = L.willStart = TR.willStart = BR.willStart = BL.willStart = TL.willStart = true;
        }
      }
    }
    for (let x = 0; x < gridSize20; x++) {
      for (let y = 0; y < gridSize20; y++) {
        if (square20Array[x][y].willStart) {
          square20Array[x][y].willStart = false;
          if (Math.random() < resetChance20) {
            square20Array[x][y].stopped = false;
            //square20Array[x][y].growSpeed *= -1;
            square20Array[x][y].size = randBetween(-square20Array[x][y].maxSize / 2, 0);//0
          }
        }
      }
    }
    
    if (canvas20Running) requestAnimationFrame(frame20);
  }
  frame20();
  
  function startCanvas20() {
    if (canvas20Running) canvas20Running = false;
    else {
      canvas20Running = true;
      frame20();
    }
  }
</script>
<canvas id = "canvas19"></canvas>
<button onclick = "drawSkyline19()">Regenerate</button>
<div class = "desc"><b><i>(11/1/2021)</i></b> Another unsuccessful generative art attempt, this time I was trying to make a generative city skyline to mimic the skyline in <a href = "https://www.reddit.com/r/generative/comments/qkfojk/skylines_generator" target = "_blank">this</a> Reddit post, but mine looks pretty boring.</div>
<hr><hr>
<script>
  const ctx19 = canvas19.getContext("2d");
  canvas19.width = canvas19.height = 1000;
  
  let hue19 = 0;
  
  function drawBuilding19(x, height, size) {
    let ratio = randBetween(0.2, 0.8);
    ctx19.lineWidth = 2;
    ctx19.fillStyle = `hsl(${hue19 + randBetween(-30, 30)}deg, ${randBetween(80, 90)}%, ${randBetween(30, 50)}%)`;
    ctx19.beginPath();
    ctx19.rect(x, canvas19.height - height, size * ratio, height);
    ctx19.fill();
    ctx19.stroke();
    
    ctx19.fillStyle = `hsl(${hue19 + randBetween(-30, 30)}deg, ${randBetween(80, 90)}%, ${randBetween(70, 90)}%)`;
    ctx19.beginPath();
    ctx19.rect(x + (size * ratio), canvas19.height - height, size * (1 - ratio), height);
    ctx19.fill();
    ctx19.stroke();
  }
  
  function drawSkyline19() {
    ctx19.clearRect(0, 0, canvas19.width, canvas19.height);
    
    hue19 = Math.random() * 360;
    let maxHeight = randBetween(300, 600);
    let num = Math.round(randBetween(10, 20));
    for (let i = 0; i < num; i++) {
      drawBuilding19(randBetween(canvas19.width * 0.2, canvas19.width * 0.8), randBetween(50, maxHeight), randBetween(25, 50));
    }
  }
  drawSkyline19();
</script>
<canvas id = "canvas18" style = "width: 500px; height: 500px"></canvas>
<button onclick = "drawCubes18()">Regenerate</button>
<div class = "desc"><b><i>(10/31/2021)</i></b> Generative art of 3D rectangular prisms, but it's honestly pretty dull.<br><b><i>(11/1/2021)</i></b> Messed with the generation some more, but I still don't feel like it's particularly interesting.</div>
<hr><hr>
<script>
  const ctx18 = canvas18.getContext("2d");
  canvas18.width = canvas18.height = 1000;
  
  let hue18 = 240;
  
  function drawOneCube18(x, y, size, sizeZ, angle, angleZ) {
    let backLeft = {x: x + ((sizeZ * Math.cos(angle)) * Math.cos(angleZ)), y: y + ((sizeZ * Math.sin(angle)) * Math.sin(angleZ))};
    let backRight = {x: backLeft.x + size, y: backLeft.y};
    let backBottom = {x: backRight.x, y: backRight.y + size};
    
    ctx18.lineWidth = 1;
    ctx18.lineCap = ctx18.lineJoin = "round";
    ctx18.fillStyle = `hsl(${hue18 + randBetween(-40, 40)}deg, ${randBetween(80, 100)}%, ${randBetween(60, 80)}%)`;
    ctx18.beginPath();
    ctx18.moveTo(x, y);
    ctx18.lineTo(backLeft.x, backLeft.y);
    ctx18.lineTo(backRight.x, backRight.y);
    ctx18.lineTo(backBottom.x, backBottom.y);
    ctx18.lineTo(x + size, y + size);
    ctx18.lineTo(x, y + size);
    ctx18.lineTo(x, y);
    ctx18.fill();
    
    ctx18.beginPath();
    ctx18.rect(x, y, size, size);
    ctx18.moveTo(x, y);
    ctx18.lineTo(backLeft.x, backLeft.y);
    ctx18.lineTo(backRight.x, backRight.y);
    ctx18.lineTo(x + size, y);
    ctx18.moveTo(backRight.x, backRight.y);
    ctx18.lineTo(backBottom.x, backBottom.y);
    ctx18.lineTo(x + size, y + size);
    ctx18.stroke();
  }
  
  function drawCubes18() {
    ctx18.globalAlpha = 1;
    ctx18.fillStyle = "white";//`hsl(${Math.random() * 360}deg, 30%, 90%)`;
    ctx18.fillRect(0, 0, canvas18.width, canvas18.height);
    ctx18.globalAlpha = 1//0.5;
    
    
    hue18 = Math.random() * 360;
    
    let gridSize = Math.round(randBetween(10, 15));
    let tileSize = canvas18.width / gridSize;
    let maxLen = randBetween(1, 3);
    let density = randBetween(0.5, 0.8);
    
    for (let x = 0; x <= gridSize; x++) {
      for (let y = 0; y <= gridSize; y++) {
        let size = tileSize * randBetween(0.25, 0.75);
        let _x = (randBetween(x - 0.2, x + 0.2) * tileSize);
        let _y = (randBetween(y - 0.2, y + 0.2) * tileSize);
        //if (Math.random() < density) drawOneCube18(_x - (size / 2), _y - (size / 2), size, size * randBetween(maxLen / 3, maxLen), toRad(315 + (25 * Math.random() * randSign())), toRad(45 + (Math.random() * 25 * randSign())));
        if (Math.random() < density) drawOneCube18(_x - (size / 2), _y - (size / 2), size, size * randBetween(maxLen / 3, maxLen), toRad(315), toRad(45));
      }
    }
    
    /*ctx18.fillStyle = "white";
    for (let i = 0; i < 1000; i++) {
      ctx18.fillCircle(Math.random() * canvas18.width, Math.random() * canvas18.height, randBetween(3, 6));
    }*/
  }
  drawCubes18();
</script>
<canvas id = "canvas17"></canvas>
<button onclick = "startCanvas17()">Start/Stop</button>
<button onclick = "reset17()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps17Txt"></span></b></i></div>
<div class = "desc"><b><i>(10/30/2021)</i></b> Clifford Attractor visualizer based on the tutorial from <a href = "https://medium.com/@bit101/flow-fields-part-i-3ebebc688fd8" target = "_blank">this</a> article.</div>
<hr><hr>
<script>
  const ctx17 = canvas17.getContext("2d");
  canvas17.width = canvas17.height = 1000;
  let canvas17Running = false;
  
  let Attractor17 = {
    a: randBetween(-2, 2),
    b: randBetween(-2, 2),
    c: randBetween(-2, 2),
    d: randBetween(-2, 2)
  };
  Attractor17.getValue = function(x, y) {
    let x1 = (x - (canvas17.width / 2)) * 0.01;
    let y1 = (y - (canvas17.height / 2)) * 0.01;
    
    let x2 = Math.sin(this.a * y1) + (this.c * Math.cos(this.a * x1));
    let y2 = Math.sin(this.b * x1) + (this.d * Math.cos(this.b * y1));
    
    return Math.atan2(y2 - y1, x2 - x1);
  };
  
  function Point17(x, y) {
    this.x = x;
    this.y = y;
    this.vx = 0;
    this.vy = 0;
  }
  Point17.prototype.render = function() {
    let lastX = this.x;
    let lastY = this.y;
    
    let angle = Attractor17.getValue(this.x, this.y);
    this.vx += Math.cos(angle) / 3;
    this.vy += Math.sin(angle) / 3;
    
    this.x += this.vx;
    this.y += this.vy;
    
    this.vx *= 0.99;
    this.vy *= 0.99;
    
    ctx17.lineWidth = 0.05;
    ctx17.lineCap = ctx17.lineJoin = "round";
    ctx17.beginPath();
    ctx17.moveTo(lastX, lastY);
    ctx17.lineTo(this.x, this.y);
    ctx17.stroke();
  };
  let point17Array = [];
  
  let lastFrame17Time = 0;
  let lastFps17DisplayTime = 1000;
  
  function frame17() {
    if (Date.now() - lastFps17DisplayTime >= 500) {
      fps17Txt.innerHTML = (1000 / (Date.now() - lastFrame17Time)).toFixed(1);
      lastFps17DisplayTime = Date.now();
    }
    lastFrame17Time = Date.now();
    
    for (let i = 0; i < point17Array.length; i++) point17Array[i].render();
    
    if (canvas17Running) requestAnimationFrame(frame17);
  }
  frame17();
  
  function reset17() {
    ctx17.clearRect(0, 0, canvas17.width, canvas17.height);
    Attractor17.a = randBetween(-2, 2);
    Attractor17.b = randBetween(-2, 2);
    Attractor17.c = randBetween(-2, 2);
    Attractor17.d = randBetween(-2, 2);
    point17Array = [];
    for (let i = 0; i < 2000; i++) {
      point17Array.push(new Point17(0, i / 2));
    }
  }
  reset17();
  
  function startCanvas17() {
    if (canvas17Running) canvas17Running = false;
    else {
      canvas17Running = true;
      frame17();
    }
  }
</script>
<canvas id = "canvas16" style = "width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas16()">Start/Stop</button>
<button onclick = "reset16()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps16Txt"></span></b></i></div>
<div><b>Total Points Drawn:</b> <span id = "totalPoints16Txt">0</span></div>
<div><b><u>Settings Presets:</u></b></div>
<div id = "presets16Div" style = "width: 600px"></div>
<table>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Flow Field Size:</u></b> <span id = "gridSize16Txt">25&times;25</span></div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "gridSize16Range" oninput = "updateSettings16(true)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Flow Field Smoothness:</u></b> <span id = "smoothIterations16Txt">3</span> iterations</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "3" id = "smoothIterations16Range" oninput = "updateSettings16(true)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Flow Field Strength:</u></b> &times;<span id = "fieldStrength16Txt">1.0</span></div>
      <input type = "range" min = "50" max = "500" step = "50" value = "100" id = "fieldStrength16Range" oninput = "updateSettings16(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Max Point Age:</u></b> <span id = "maxAge16Txt">50</span> steps</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "maxAge16Range" oninput = "updateSettings16(false)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Friction:</u></b> <span id = "friction16Txt">10</span>%</div>
      <input type = "range" min = "0" max = "50" step = "5" value = "10" id = "friction16Range" oninput = "updateSettings16(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Path Hue:</u></b> <span id = "hue16Txt">120</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "5" value = "120" id = "hue16Range" oninput = "updateSettings16(false)">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Path Opacity:</u></b> <span id = "opacity16Txt">5</span>%</div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "opacity16Range" oninput = "updateSettings16(false)">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Path Hue Variation:</u></b> <span id = "hueVariation16Txt">50</span>%</div>
      <input type = "range" min = "0" max = "100" step = "5" value = "50" id = "hueVariation16Range" oninput = "updateSettings16(false)">
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "edgeSpawning16Checkbox" oninput = "updateSettings16(false)">
      <label for = "edgeSpawning16Checkbox">Points start at edges</label>
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(10/30/2021)</i></b> An unsuccessful attempt to simulate a flow field, by having a grid of random vectors that are averaged together. For some reason, there is a strong bias towards angles around 120&deg; and 240&deg;, with little to no other angles, meaning there's something wrong with my averaging function, but I don't know what. The field is visualized with magnitude being brightness and angle being hue.<br><b><i>Update: (A few minutes later)</i></b> I realized I was going about the averaging completely wrong, I had been just averaging up the magnitudes and averaging up the angles and calling it good, but that's not how vector addition works. What I should have been doing is adding the vectors x and y components and dividing that resulting magnitude by 9 (the number of neighbors). I added that, and also added a Point16 class that moves around the flow field, tracing its path. Each point only lasts a set number of frames, and then it is replaced with a new point at a random position. Now everything works perfectly and it looks really cool. I also added more settings and sliders for everything, as well as presets.<br><b><i>(10/31/2021)</i></b> Slightly modified the code so that instead of 500 points moving 5 times per frame, there's one point moving 5000 times per frame, which is less laggy and almost twice as fast.</div>
<hr><hr>
<script>
  const ctx16 = canvas16.getContext("2d");
  canvas16.width = canvas16.height = 1000;
  let canvas16Running = false;
  
  let gridSize16 = 25;
  let tileSize16 = canvas16.width / gridSize16;
  let maxPoints16 = 1//500;
  let maxAge16 = 50;
  let stepsPerFrame16 = 5000//5;
  let friction16 = 0.1;
  let opacity16 = 0.05;
  let smoothIterations16 = 3;
  let hue16 = 120;
  let totalPoints16 = 0;
  let edgeSpawning16 = false;
  let hueVariation16 = 0.5;
  let fieldStrength16 = 1;
  
  // Maybe later add: points spawn near mouse position?
  
  let presets16 = [
    {
      name: "Default",
      gridSize16: 25,
      smoothIterations16: 3,
      fieldStrength16: 1,
      maxAge16: 50,
      friction16: 0.1,
      hue16: 120,
      opacity16: 0.05,
      hueVariation16: 0.5,
      edgeSpawning16: false
    },
    {
      name: "Checkerboard",
      gridSize16: 8,
      smoothIterations16: 0,
      fieldStrength16: 1,
      maxAge16: 5,
      friction16: 0,
      hue16: 240,
      opacity16: 0.1,
      hueVariation16: 0,
      edgeSpawning16: false
    },
    {
      name: "Circuits",
      gridSize16: 25,
      smoothIterations16: 0,
      fieldStrength16: 2,
      maxAge16: 50,
      friction16: 0.5,
      hue16: 120,
      opacity16: 0.1,
      hueVariation16: 0,
      edgeSpawning16: false
    },
    {
      name: "Crimson Growth",
      gridSize16: 50,
      smoothIterations16: 0,
      fieldStrength16: 1.5,
      maxAge16: 200,
      friction16: 0.1,
      hue16: 0,
      opacity16: 0.1,
      hueVariation16: 0,
      edgeSpawning16: true
    },
    {
      name: "Coiling Tendrils",
      gridSize16: 100,
      smoothIterations16: 2,
      fieldStrength16: 1,
      maxAge16: 50,
      friction16: 0.25,
      hue16: 120,
      opacity16: 0.05,
      hueVariation16: 1,
      edgeSpawning16: false
    },
    {
      name: "Tropical Branches",
      gridSize16: 25,
      smoothIterations16: 3,
      fieldStrength16: 5,
      maxAge16: 10,
      friction16: 0,
      hue16: 120,
      opacity16: 0.05,
      hueVariation16: 0.5,
      edgeSpawning16: true
    }
  ];
  for (let i = 0; i < presets16.length; i++) {
    let btn = document.createElement("button");
    btn.innerHTML = presets16[i].name;
    btn.onclick = () => loadPreset16(i);
    btn.style.borderRadius = "8px";
    btn.style.margin = "5px";
    btn.style.fontWeight = "bold";
    
    presets16Div.appendChild(btn);
  }
  
  let field16 = [];
  
  function initField16() {
    field16 = [];
    for (let x = 0; x < gridSize16; x++) {
      let row = [];
      for (let y = 0; y < gridSize16; y++) {
        row.push({magnitude: 1, angle: Math.random() * Math.PI * 2});
      }
      field16.push(row);
    }
  }
  function smoothField16(steps) {
    for (let j = 0; j < steps; j++) {
      let nextField = [];
      for (let x = 0; x < gridSize16; x++) {
        let row = [];
        for (let y = 0; y < gridSize16; y++) {
          row.push({magnitude: 0, angle: 0});
        }
        nextField.push(row);
      }
      for (let x = 0; x < gridSize16; x++) {
        for (let y = 0; y < gridSize16; y++) {
          let vecs = [];
          vecs.push(field16[x][(y - 1 + gridSize16) % gridSize16]);
          vecs.push(field16[(x + 1) % gridSize16][(y - 1 + gridSize16) % gridSize16]);
          vecs.push(field16[(x + 1) % gridSize16][y]);
          vecs.push(field16[(x + 1) % gridSize16][(y + 1) % gridSize16]);
          vecs.push(field16[x][(y + 1) % gridSize16]);
          vecs.push(field16[(x - 1 + gridSize16) % gridSize16][(y + 1) % gridSize16]);
          vecs.push(field16[(x - 1 + gridSize16) % gridSize16][y]);
          vecs.push(field16[(x - 1 + gridSize16) % gridSize16][(y - 1 + gridSize16) % gridSize16]);
          vecs.push(field16[x][y]);
          
          let currX = 0;
          let currY = 0;
          for (let i = 0; i < vecs.length; i++) {
            currX += Math.cos(vecs[i].angle);
            currY += Math.sin(vecs[i].angle);
          }
          let avgAngle = Math.atan2(currY, currX);
          nextField[x][y].magnitude = 1;
          nextField[x][y].angle = avgAngle;
        }
      }
      for (let x = 0; x < gridSize16; x++) {
        for (let y = 0; y < gridSize16; y++) {
          field16[x][y] = nextField[x][y];
        }
      }
    }
  }
  function drawField16() {
    ctx16.clearRect(0, 0, canvas16.width, canvas16.height);
    tileSize16 = canvas16.width / gridSize16;
    for (let x = 0; x < gridSize16; x++) {
      for (let y = 0; y < gridSize16; y++) {
        let hue = toDeg(field16[x][y].angle);
        let brightness = 40;
        ctx16.fillStyle = `hsl(${hue}deg, 100%, ${brightness}%)`;
        ctx16.fillRect(x * tileSize16, y * tileSize16, tileSize16, tileSize16);
      }
    }
  }
  
  function randCanvas16EdgePos() {
    let r = Math.floor(Math.random() * 4);
    if (r === 0) return {x: Math.random() * canvas16.width, y: 0};
    else if (r === 1) return {x: canvas16.width, y: Math.random() * canvas16.height};
    else if (r === 2) return {x: Math.random() * canvas16.width, y: canvas16.height};
    else return {x: 0, y: Math.random() * canvas16.height};
  }
  
  function Point16() {
    let P = randCanvas16EdgePos();
    this.x = edgeSpawning16 ? P.x : Math.random() * canvas16.width;
    this.y = edgeSpawning16 ? P.y : Math.random() * canvas16.height;
    this.vx = 0;
    this.vy = 0;
    this.age = 0;
    let hue = hue16 + randBetween(-180 * hueVariation16, 180 * hueVariation16);
    this.color = `hsl(${hue}deg, 100%, 50%)`;
  }
  Point16.prototype.render = function() {
    this.age++;
    let fieldX = Math.floor(this.x / tileSize16);
    let fieldY = Math.floor(this.y / tileSize16);
    fieldX = fieldX.clamp(0, gridSize16 - 1);
    fieldY = fieldY.clamp(0, gridSize16 - 1);
    let lastX = this.x;
    let lastY = this.y;
    this.x += this.vx;
    this.y += this.vy;
    if (this.x > canvas16.width + 2) this.x = lastX = -2;
    if (this.x < -2) this.x = lastX = canvas16.width + 2;
    if (this.y > canvas16.height + 2) this.y = lastY = -2;
    if (this.y < -2) this.y = lastY = canvas16.height + 2;
    this.vx += fieldStrength16 * Math.cos(field16[fieldX][fieldY].angle);
    this.vy += fieldStrength16 * Math.sin(field16[fieldX][fieldY].angle);
    this.vx *= 1 - friction16;
    this.vy *= 1 - friction16;
    ctx16.globalAlpha = opacity16;
    ctx16.strokeStyle = this.color;
    ctx16.beginPath();
    ctx16.moveTo(lastX, lastY);
    ctx16.lineTo(this.x, this.y);
    ctx16.stroke();
  };
  Point16.prototype.resetPos = function() {
    let P = randCanvas16EdgePos();
    this.x = edgeSpawning16 ? P.x : Math.random() * canvas16.width;
    this.y = edgeSpawning16 ? P.y : Math.random() * canvas16.height;
    this.vx = 0;
    this.vy = 0;
    this.age = 0;
    let hue = hue16 + randBetween(-180 * hueVariation16, 180 * hueVariation16);
    this.color = `hsl(${hue}deg, 100%, 50%)`;
    totalPoints16++;
  };
  let point16Array = [];
  function initPoints16() {
    point16Array = [];
    for (let i = 0; i < maxPoints16; i++) {
      totalPoints16++;
      point16Array.push(new Point16());
    }
  }
  
  let lastFrame16Time = 0;
  let lastFps16DisplayTime = 1000;
  
  function frame16() {
    if (Date.now() - lastFps16DisplayTime >= 500) {
      fps16Txt.innerHTML = (1000 / (Date.now() - lastFrame16Time)).toFixed(1);
      lastFps16DisplayTime = Date.now();
    }
    lastFrame16Time = Date.now();
    
    for (let j = 0; j < stepsPerFrame16; j++) {
      let newPoints = 0;
      for (let i = 0; i < point16Array.length; i++) {
        point16Array[i].render();
        if (point16Array[i].age > maxAge16) {
          point16Array[i].resetPos();
          /*point16Array.splice(i, 1);
          i--;
          newPoints++;*/
        }
      }
      /*for (let i = 0; i < newPoints; i++) {
        totalPoints16++;
        point16Array.push(new Point16());
      }*/
    }
    
    totalPoints16Txt.innerHTML = totalPoints16.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    
    if (canvas16Running) requestAnimationFrame(frame16);
  }
  
  function reset16() {
    ctx16.globalAlpha = 1;
    ctx16.fillStyle = "black";
    ctx16.fillRect(0, 0, canvas16.width, canvas16.height);
    tileSize16 = canvas16.width / gridSize16;
    totalPoints16 = 0;
    initField16();
    smoothField16(smoothIterations16);
    initPoints16();
    if (!canvas16Running) frame16();
  }
  
  ctx16.lineCap = ctx16.lineJoin = "round";
  reset16();
  
  function startCanvas16() {
    if (canvas16Running) canvas16Running = false;
    else {
      canvas16Running = true;
      frame16();
    }
  }
  
  let gridSize16RangeArray = [5, 8, 10, 15, 20, 25, 50, 100];
  gridSize16Range.max = gridSize16RangeArray.length - 1;
  gridSize16Range.value = gridSize16RangeArray.indexOf(25);
  let maxAge16RangeArray = [5, 10, 15, 20, 25, 50, 75, 100, 200];
  maxAge16Range.max = maxAge16RangeArray.length - 1;
  maxAge16Range.value = maxAge16RangeArray.indexOf(50);
  let opacity16RangeArray = [1, 2, 3, 4, 5, 10, 15, 20, 25, 50, 75, 100];
  opacity16Range.max = opacity16RangeArray.length - 1;
  opacity16Range.value = opacity16RangeArray.indexOf(5);
  
  function updateSettings16(reset) {
    gridSize16 = gridSize16RangeArray[Number(gridSize16Range.value)];
    gridSize16Txt.innerHTML = gridSize16 + "&times;" + gridSize16;
    
    smoothIterations16 = smoothIterations16Txt.innerHTML = Number(smoothIterations16Range.value);
    
    fieldStrength16 = Number(fieldStrength16Range.value) / 100;
    fieldStrength16Txt.innerHTML = fieldStrength16.toFixed(1);
    
    maxAge16 = maxAge16Txt.innerHTML = maxAge16RangeArray[Number(maxAge16Range.value)];
    
    friction16 = Number(friction16Range.value) / 100;
    friction16Txt.innerHTML = friction16Range.value;
    
    hue16 = hue16Txt.innerHTML = Number(hue16Range.value);
    
    opacity16 = opacity16RangeArray[Number(opacity16Range.value)] / 100;
    opacity16Txt.innerHTML = opacity16RangeArray[Number(opacity16Range.value)];
    
    hueVariation16 = Number(hueVariation16Range.value) / 100;
    hueVariation16Txt.innerHTML = hueVariation16Range.value;
    
    edgeSpawning16 = edgeSpawning16Checkbox.checked;
    
    if (reset) reset16();
  }
  
  function loadPreset16(n) {
    gridSize16Range.value = gridSize16RangeArray.indexOf(presets16[n].gridSize16);
    smoothIterations16Range.value = presets16[n].smoothIterations16;
    fieldStrength16Range.value = presets16[n].fieldStrength16 * 100;
    maxAge16Range.value = maxAge16RangeArray.indexOf(presets16[n].maxAge16);
    friction16Range.value = presets16[n].friction16 * 100;
    opacity16Range.value = opacity16RangeArray.indexOf(presets16[n].opacity16 * 100);
    hue16Range.value = presets16[n].hue16;
    hueVariation16Range.value = presets16[n].hueVariation16 * 100;
    edgeSpawning16Checkbox.checked = presets16[n].edgeSpawning16;
    
    updateSettings16(true);
  }
</script>
<canvas id = "canvas15"></canvas>
<div><b><i>How random are you? Start typing random numbers below...</i></b></div>
<input type = "text" id = "rand15Txt" oninput = "addRandNumbers15()">
<div><b>Random Numbers Submitted:</b> <span id = "randNumbers15LengthTxt">0</span></div>
<div class = "desc"><b><i>(10/29/2021)</i></b> An idea I had for showing how not random humans are, where you type "random" numbers that get fed into a program as psuedorandom numbers, and it shows you some vizualization of how not random those numbers actually are. It works well enough, but it's kinda dull and takes ages to type out a reasonable amount of numbers to get a feel for it.</div>
<hr><hr>
<script>
  const ctx15 = canvas15.getContext("2d");
  canvas15.width = canvas15.height = 1000;
  
  let randNumbers15 = [];
  let currIndex15 = 0;
  
  let gridSize15 = 25;
  let tileSize15 = canvas15.width / gridSize15;
  
  function rand15() {
    let num = "0.";
    let j = currIndex15;
    for (let i = j; i < j + 5; i++) {
      currIndex15++;
      if (randNumbers15.length > i) num += String(randNumbers15[i]);
    }
    if (currIndex15 >= randNumbers15.length) currIndex15 = 0;
    return Number(num);
  }
  function addRandNumbers15() {
    let num = rand15Txt.value.replace(/\D/g,"");
    for (let i = 0; i < num.length; i++) {
      randNumbers15.push(Number(num[i]));
    }
    rand15Txt.value = "";
    randNumbers15LengthTxt.innerHTML = randNumbers15.length;
    //drawRandomWalk15();
    drawRandomPixels15();
  }
  
  function drawRandomPixels15() {
    ctx15.clearRect(0, 0, canvas15.width, canvas15.height);
    
    currIndex15 = 0;
    tileSize15 = canvas15.width / gridSize15;
    for (let x = 0; x < gridSize15; x++) {
      for (let y = 0; y < gridSize15; y++) {
        ctx15.fillStyle = `rgb(${rand15() * 255}, ${rand15() * 255}, ${rand15() * 255})`;
        ctx15.fillRect(x * tileSize15, y * tileSize15, tileSize15, tileSize15);
      }
    }
  }
  drawRandomPixels15();
  
  function drawRandomWalk15() {
    ctx15.clearRect(0, 0, canvas15.width, canvas15.height);
    
    currIndex15 = 0;
    let x = canvas15.width / 2;
    let y = canvas15.height / 2;
    for (let i = 0; i < 100; i++) {
      let lastX = x;
      let lastY = y;
      let a = rand15() * Math.PI * 2;
      let v = (rand15() * 15) + 15;
      x += v * Math.cos(a);
      y += v * Math.sin(a);
      if (x > canvas15.width) x = lastX = 0;
      if (x < 0) x = lastX = canvas15.width;
      if (y > canvas15.height) y = lastY = 0;
      if (y < 0) y = lastY = canvas15.height;
      ctx15.lineWidth = 3;
      ctx15.beginPath();
      ctx15.moveTo(lastX, lastY);
      ctx15.lineTo(x, y);
      ctx15.stroke();
    }
  }
</script>
<canvas id = "canvas14" style = "width: 400px; height: 400px"></canvas>
<button onclick = "drawTiles14()">Redraw</button>
<div><b><u>Grid Size:</u></b> <span id = "gridSize14Txt">10x10</span></div>
<input type = "range" min = "1" max = "20" step = "1" value = "10" id = "gridSize14Range" oninput = "updateSettings14()">
<div><b><u>Outline Thickness:</u></b> <span id = "lineWidth14Txt">3</span>px</div>
<input type = "range" min = "0" max = "10" step = "1" value = "3" id = "lineWidth14Range" oninput = "updateSettings14()">
<div><b><u>Selected Tiles:</u></b></div>
<table>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox1" oninput = "toggleTile14(this.checked, 1)" CHECKED>
      <label for  = "selectedTiles14Checkbox1">Full Square</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox12" oninput = "toggleTile14(this.checked, 12)" CHECKED>
      <label for  = "selectedTiles14Checkbox12">Small Square</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox2" oninput = "toggleTile14(this.checked, 2)" CHECKED>
      <label for  = "selectedTiles14Checkbox2">Half Rectangle</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox11" oninput = "toggleTile14(this.checked, 11)" CHECKED>
      <label for  = "selectedTiles14Checkbox11">Stripe</label>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox3" oninput = "toggleTile14(this.checked, 3)" CHECKED>
      <label for  = "selectedTiles14Checkbox3">Diagonal</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox5" oninput = "toggleTile14(this.checked, 5)" CHECKED>
      <label for  = "selectedTiles14Checkbox5">Full Circle</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox4" oninput = "toggleTile14(this.checked, 4)" CHECKED>
      <label for  = "selectedTiles14Checkbox4">Small Circle</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox6" oninput = "toggleTile14(this.checked, 6)" CHECKED>
      <label for  = "selectedTiles14Checkbox6">Half Circle</label>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox10" oninput = "toggleTile14(this.checked, 10)" CHECKED>
      <label for  = "selectedTiles14Checkbox10">Double Half Circle</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox7" oninput = "toggleTile14(this.checked, 7)" CHECKED>
      <label for  = "selectedTiles14Checkbox7">Quarter Circle</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox8" oninput = "toggleTile14(this.checked, 8)" CHECKED>
      <label for  = "selectedTiles14Checkbox8">Double Quarter Circle</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox9" oninput = "toggleTile14(this.checked, 9)" CHECKED>
      <label for  = "selectedTiles14Checkbox9">Ring</label>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox13" oninput = "toggleTile14(this.checked, 13)" CHECKED>
      <label for  = "selectedTiles14Checkbox13">Diamond</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox14" oninput = "toggleTile14(this.checked, 14)" CHECKED>
      <label for  = "selectedTiles14Checkbox14">Cross</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox15" oninput = "toggleTile14(this.checked, 15)" CHECKED>
      <label for  = "selectedTiles14Checkbox15">Side Triangle</label>
    </td>
    <td style = "padding: 10px">
      <input type = "checkbox" id = "selectedTiles14Checkbox16" oninput = "toggleTile14(this.checked, 16)" CHECKED>
      <label for  = "selectedTiles14Checkbox16">Double Side Triangle</label>
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <button onclick = "selectAllTiles14()">Select All</button>
      <br><br>
      <button onclick = "deselectAllTiles14()">Deselect All</button>
      <br><br>
      <button onclick = "selectRandomTiles14()">Select Random</button>
    </td>
    <td colspan = "3">
      <div><b><u>Tile Presets:</u></b></div>
      <div id = "presetsDiv14"></div>
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(10/29/2021)</i></b> Generative tile art generator, based on the idea from <a href = "https://generated.space/sketch/tilework" target = "_blank">https://generated.space/sketch/tilework</a>. I also added some more tiles of my own.<br><b><i>Update: (Later that day)</i></b> Added more tiles and line width around each tile, as well as more settings, sliders, and buttons.<br><b><i>(10/30/2021)</i></b> Added presets and added more tiles.</div>
<hr><hr>
<script>
  const ctx14 = canvas14.getContext("2d");
  canvas14.width = canvas14.height = 1000;
  
  let palette14 = ["yellow", "pink", "rgb(120, 120, 255)", "rgb(255, 50, 50)", "white"];
  function shufflePalette14() {
    let result = [];
    while (palette14.length > 0) result.push(palette14.splice(Math.floor(Math.random() * palette14.length), 1));
    palette14 = result.flat(1);
  }
  
  let gridSize14 = 10;
  let tileSize14 = canvas14.width / gridSize14;
  let lineWidth14 = 3;
  let numTiles14 = 16;
  
  let selectedTiles14 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
  // 1: Filled | 2: Half | 3: Diagonal | 4: Small circle | 5: Full circle | 6: Half circle | 7: Quarter circle | 8: Double quarter circle | 9: Ring
  // 10: Double half circle | 11: Stripe | 12: Small square | 13: Diamond | 14: Cross | 15: Side triangle | 16: Double side triangle
  
  function selectTile14(n) {
    if (!selectedTiles14.includes(n)) selectedTiles14.push(n);
    drawTiles14();
  }
  function deselectTile14(n) {
    if (selectedTiles14.includes(n)) selectedTiles14.splice(selectedTiles14.indexOf(n), 1);
    drawTiles14();
  }
  function toggleTile14(select, n) {
    if (select) selectTile14(n);
    else deselectTile14(n);
  }
  function deselectAllTiles14() {
    selectedTiles14 = [];
    updateSettings14();
  }
  function selectAllTiles14() {
    selectedTiles14 = [];
    for (let i = 1; i <= numTiles14; i++) selectedTiles14.push(i);
    updateSettings14();
  }
  function selectRandomTiles14() {
    selectedTiles14 = [];
    for (let i = 1; i <= numTiles14; i++) {
      if (Math.random() >= 0.5) selectedTiles14.push(i);
    }
    updateSettings14();
  }
  let presets14 = [
    {
      name: "Triangular",
      tiles: [3, 15, 16]
    },
    {
      name: "Rectangular",
      tiles: [1, 2, 11, 12]
    },
    {
      name: "Circular",
      tiles: [6, 7, 8, 10]
    },
    {
      name: "Simplistic",
      tiles: [1, 4, 12]
    }
  ];
  for (let i = 0; i < presets14.length; i++) {
    let btn = document.createElement("button");
    btn.innerHTML = "<i>" + presets14[i].name + "</i>";
    btn.style.borderRadius = "8px";
    btn.style.border = "2px solid black";
    btn.style.margin = "5px";
    btn.onclick = () => loadPreset14(i);
    
    presetsDiv14.appendChild(btn);
  }
  function loadPreset14(n) {
    selectedTiles14 = presets14[n].tiles;
    updateSettings14();
  }
  
  function drawOneTile14(x, y, size) {
    let n = selectedTiles14[Math.floor(Math.random() * selectedTiles14.length)]; // Get tile type
    
    shufflePalette14(); // Get colors
    let color1 = palette14[0];
    let color2 = palette14[1];
    
    ctx14.fillStyle = color1;
    ctx14.fillRect(x, y, size, size);
    
    ctx14.fillStyle = color2;
    ctx14.lineWidth = lineWidth14;
    ctx14.lineCap = ctx14.lineJoin = "round";
    let stroke = lineWidth14 !== 0;
    
    
    if (n === 2) { // Half
      if (Math.random() >= 0.5) { // Horizontal
        ctx14.fillRect(x, y, size, size / 2);
        if (stroke) ctx14.strokeRect(x, y, size, size / 2);
      }
      else { // Vertical
        ctx14.fillRect(x, y, size / 2, size);
        if (stroke) ctx14.strokeRect(x, y, size / 2, size);
      }
    }
    
    else if (n === 3) { // Diagonal
      if (Math.random() >= 0.5) { // Top left
        ctx14.beginPath();
        ctx14.moveTo(x, y);
        ctx14.lineTo(x + size, y);
        ctx14.lineTo(x, y + size);
        ctx14.lineTo(x, y);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
      else { // Bottom left
        ctx14.beginPath();
        ctx14.moveTo(x, y + size);
        ctx14.lineTo(x + size, y + size);
        ctx14.lineTo(x, y);
        ctx14.lineTo(x, y + size);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
    }
    
    else if (n === 4) { // Small circle
      ctx14.fillCircle(x + (size / 2), y + (size / 2), size / 4);
      if (stroke) ctx14.strokeCircle(x + (size / 2), y + (size / 2), size / 4);
    }
    
    else if (n === 5) { // Full circle
      ctx14.fillCircle(x + (size / 2), y + (size / 2), size / 2);
      if (stroke) ctx14.strokeCircle(x + (size / 2), y + (size / 2), size / 2);
    }
    
    else if (n === 6) { // Half circle
      let side = Math.floor(Math.random() * 4);
      if (side === 0) { // Top
        ctx14.beginPath();
        ctx14.arc(x + (size / 2), y, size / 2, 0, Math.PI);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
      else if (side === 1) { // Right
        ctx14.beginPath();
        ctx14.arc(x + size, y + (size / 2), size / 2, Math.PI / 2, (3 * Math.PI) / 2);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
      else if (side === 2) { // Bottom
        ctx14.beginPath();
        ctx14.arc(x + (size / 2), y + size, size / 2, 0, Math.PI, true);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
      else if (side === 3) { // Left
        ctx14.beginPath();
        ctx14.arc(x, y + (size / 2), size / 2, Math.PI / 2, (3 * Math.PI) / 2, true);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
    }
    
    else if (n === 7) { // Quarter circle
      let side = Math.floor(Math.random() * 4);
      if (side === 0) { // Top right
        ctx14.beginPath();
        ctx14.moveTo(x, y);
        ctx14.lineTo(x + size, y);
        ctx14.lineTo(x + size, y + size);
        ctx14.arc(x + size, y, size, Math.PI / 2, Math.PI);
        ctx14.fill();
        if (stroke) {
          ctx14.beginPath();
          ctx14.arc(x + size, y, size, Math.PI / 2, Math.PI);
          ctx14.stroke();
        }
      }
      else if (side === 1) { // Bottom right
        ctx14.beginPath();
        ctx14.moveTo(x, y + size);
        ctx14.lineTo(x + size, y + size);
        ctx14.lineTo(x + size, y);
        ctx14.arc(x + size, y + size, size, (3 * Math.PI) / 2, Math.PI, true);
        ctx14.fill();
        if (stroke) {
          ctx14.beginPath();
          ctx14.arc(x + size, y + size, size, (3 * Math.PI) / 2, Math.PI, true);
          ctx14.stroke();
        }
      }
      else if (side === 2) { // Bottom left
        ctx14.beginPath();
        ctx14.moveTo(x + size, y + size);
        ctx14.lineTo(x, y + size);
        ctx14.lineTo(x, y);
        ctx14.arc(x, y + size, size, 0, (3 * Math.PI) / 2, true);
        ctx14.fill();
        if (stroke) {
          ctx14.beginPath();
          ctx14.arc(x, y + size, size, 0, (3 * Math.PI) / 2, true);
          ctx14.stroke();
        }
      }
      else if (side === 3) { // Top left
        ctx14.beginPath();
        ctx14.moveTo(x + size, y);
        ctx14.lineTo(x, y);
        ctx14.lineTo(x, y + size);
        ctx14.arc(x, y, size, 0, Math.PI / 2);
        ctx14.fill();
        if (stroke) {
          ctx14.beginPath();
          ctx14.arc(x, y, size, 0, Math.PI / 2);
          ctx14.stroke();
        }
      }
    }
    
    else if (n === 8) { // Double quarter circle
      if (Math.random() >= 0.5) { // Top left and bottom right
        ctx14.beginPath(); // Top left
        ctx14.moveTo(x + (size / 2), y);
        ctx14.lineTo(x, y);
        ctx14.lineTo(x, y + (size / 2));
        ctx14.arc(x, y, size / 2, 0, Math.PI / 2);
        ctx14.fill();
        if (stroke) {
          ctx14.beginPath();
          ctx14.arc(x, y, size / 2, 0, Math.PI / 2);
          ctx14.stroke();
        }
        
        ctx14.beginPath(); // Bottom right
        ctx14.moveTo(x + (size / 2), y + size);
        ctx14.lineTo(x + size, y + size);
        ctx14.lineTo(x + size, y + (size / 2));
        ctx14.arc(x + size, y + size, size / 2, (3 * Math.PI) / 2, Math.PI, true);
        ctx14.fill();
        if (stroke) {
          ctx14.beginPath();
          ctx14.arc(x + size, y + size, size / 2, (3 * Math.PI) / 2, Math.PI, true);
          ctx14.stroke();
        }
      }
      else { // Top right and bottom left
        ctx14.beginPath(); // Top right
        ctx14.moveTo(x + (size / 2), y);
        ctx14.lineTo(x + size, y);
        ctx14.lineTo(x + size, y + (size / 2));
        ctx14.arc(x + size, y, size / 2, Math.PI / 2, Math.PI);
        ctx14.fill();
        if (stroke) {
          ctx14.beginPath();
          ctx14.arc(x + size, y, size / 2, Math.PI / 2, Math.PI);
          ctx14.stroke();
        }
        
        ctx14.beginPath(); // Bottom left
        ctx14.moveTo(x + (size / 2), y + size);
        ctx14.lineTo(x, y + size);
        ctx14.lineTo(x, y + (size / 2));
        ctx14.arc(x, y + size, size / 2, 0, (3 * Math.PI) / 2, true);
        ctx14.fill();
        if (stroke) {
          ctx14.beginPath();
          ctx14.arc(x, y + size, size / 2, 0, (3 * Math.PI) / 2, true);
          ctx14.stroke();
        }
      }
    }
    
    else if (n === 9) { // Ring
      ctx14.fillStyle = color2;
      ctx14.fillCircle(x + (size / 2), y + (size / 2), size / 2);
      if (stroke) ctx14.strokeCircle(x + (size / 2), y + (size / 2), size / 2);
      ctx14.fillStyle = color1;
      ctx14.fillCircle(x + (size / 2), y + (size / 2), size / 4);
      if (stroke) ctx14.strokeCircle(x + (size / 2), y + (size / 2), size / 4);
      ctx14.fillStyle = color2;
    }
    
    else if (n === 10) { // Double half circle
      if (Math.random() >= 0.5) { // Left and right
        ctx14.beginPath(); // Left
        ctx14.arc(x, y + (size / 2), size / 2, Math.PI / 2, (3 * Math.PI) / 2, true);
        ctx14.fill();
        if (stroke) ctx14.stroke();
        
        ctx14.beginPath(); // Right
        ctx14.arc(x + size, y + (size / 2), size / 2, Math.PI / 2, (3 * Math.PI) / 2);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
      else { // Top and bottom
        ctx14.beginPath(); // Top
        ctx14.arc(x + (size / 2), y, size / 2, 0, Math.PI);
        ctx14.fill();
        if (stroke) ctx14.stroke();
        
        ctx14.beginPath(); // Bottom
        ctx14.arc(x + (size / 2), y + size, size / 2, 0, Math.PI, true);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
    }
    
    else if (n === 11) { // Stripe
      if (Math.random() >= 0.5) { // Horizontal
        ctx14.fillRect(x, y + (size / 4), size, size / 2);
        if (stroke) ctx14.strokeRect(x, y + (size / 4), size, size / 2);
      }
      else { // Vertical
        ctx14.fillRect(x + (size / 4), y, size / 2, size);
        if (stroke) ctx14.strokeRect(x + (size / 4), y, size / 2, size);
      }
    }
    
    else if (n === 12) { // Small square
      ctx14.fillRect(x + (size / 4), y + (size / 4), size / 2, size / 2);
      if (stroke) ctx14.strokeRect(x + (size / 4), y + (size / 4), size / 2, size / 2);
    }
    
    else if (n === 13) { // Diamond
      ctx14.beginPath();
      ctx14.moveTo(x + (size / 2), y);
      ctx14.lineTo(x + size, y + (size / 2));
      ctx14.lineTo(x + (size / 2), y + size);
      ctx14.lineTo(x, y + (size / 2));
      ctx14.lineTo(x + (size / 2), y);
      ctx14.fill();
      if (stroke) ctx14.stroke();
    }
    
    else if (n === 14) { // Cross
      ctx14.beginPath();
      ctx14.moveTo(x + (size / 4), y);
      ctx14.lineTo(x + (size * 0.75), y);
      ctx14.lineTo(x + (size * 0.75), y + (size / 4));
      ctx14.lineTo(x + size, y + (size / 4));
      ctx14.lineTo(x + size, y + (size * 0.75));
      ctx14.lineTo(x + (size * 0.75), y + (size * 0.75));
      ctx14.lineTo(x + (size * 0.75), y + size);
      ctx14.lineTo(x + (size / 4), y + size);
      ctx14.lineTo(x + (size / 4), y + (size * 0.75));
      ctx14.lineTo(x, y + (size * 0.75));
      ctx14.lineTo(x, y + (size / 4));
      ctx14.lineTo(x + (size / 4), y + (size / 4));
      ctx14.lineTo(x + (size / 4), y);
      ctx14.fill();
      if (stroke) ctx14.stroke();
    }
    
    else if (n === 15) { // Side triangle
      let side = Math.floor(Math.random() * 4);
      if (side === 0) { // Top
        ctx14.beginPath();
        ctx14.moveTo(x, y);
        ctx14.lineTo(x + (size / 2), y + (size / 2));
        ctx14.lineTo(x + size, y);
        ctx14.lineTo(x, y);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
      else if (side === 1) { // Right
        ctx14.beginPath();
        ctx14.moveTo(x + size, y);
        ctx14.lineTo(x + (size / 2), y + (size / 2));
        ctx14.lineTo(x + size, y + size);
        ctx14.lineTo(x + size, y);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
      else if (side === 2) { // Bottom
        ctx14.beginPath();
        ctx14.moveTo(x, y + size);
        ctx14.lineTo(x + (size / 2), y + (size / 2));
        ctx14.lineTo(x + size, y + size);
        ctx14.lineTo(x, y + size);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
      else if (side === 3) { // Left
        ctx14.beginPath();
        ctx14.moveTo(x, y);
        ctx14.lineTo(x + (size / 2), y + (size / 2));
        ctx14.lineTo(x, y + size);
        ctx14.lineTo(x, y);
        ctx14.fill();
        if (stroke) ctx14.stroke();
      }
    }
    
    else if (n === 16) {
      ctx14.beginPath(); // Top
      ctx14.moveTo(x, y);
      ctx14.lineTo(x + (size / 2), y + (size / 2));
      ctx14.lineTo(x + size, y);
      ctx14.lineTo(x, y);
      ctx14.fill();
      if (stroke) ctx14.stroke();
      
      ctx14.beginPath(); // Bottom
      ctx14.moveTo(x, y + size);
      ctx14.lineTo(x + (size / 2), y + (size / 2));
      ctx14.lineTo(x + size, y + size);
      ctx14.lineTo(x, y + size);
      ctx14.fill();
      if (stroke) ctx14.stroke();
    }
    
    if (stroke) ctx14.strokeRect(x, y, size, size);
  }
  
  function drawTiles14() {
    ctx14.clearRect(0, 0, canvas14.width, canvas14.height);
    
    tileSize14 = canvas14.width / gridSize14;
    
    for (let x = 0; x < gridSize14; x++) {
      for (let y = 0; y < gridSize14; y++) {
        drawOneTile14(x * tileSize14, y * tileSize14, tileSize14);
      }
    }
  }
  drawTiles14();
  
  function updateSettings14() {
    gridSize14 = Number(gridSize14Range.value);
    gridSize14Txt.innerHTML = gridSize14Range.value + "x" + gridSize14Range.value;
    lineWidth14 = lineWidth14Txt.innerHTML = Number(lineWidth14Range.value);
    
    for (let i = 1; i <= numTiles14; i++) {
      document.getElementById("selectedTiles14Checkbox" + i).checked = selectedTiles14.includes(i);
    }
    
    drawTiles14();
  }
</script>
<canvas id = "canvas13" style = "width: 500px; height: 500px"></canvas>
<button onclick = "drawSquares13()">Redraw</button>
<div class = "desc"><b><i>(10/28/2021)</i></b> Random square subdivision faces, based on the image from <a href = "https://www.reddit.com/r/creativecoding/comments/dvjubb/random_faces" target = "_blank">this</a> Reddit post. I also added random eyebrows for more expressions.</div>
<hr><hr>
<script>
  const ctx13 = canvas13.getContext("2d");
  canvas13.width = canvas13.height = 2000;
  
  let maxLayers13 = 7;
  let splitsPerDraw13 = 200;
  
  function Square13(x, y, size, layer) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.layer = layer;
  }
  Square13.prototype.draw = function() {
    ctx13.lineWidth = 3;
    drawFace13(this.x + 2, this.y + 2, this.size - 4);
    //ctx13.strokeRect(this.x, this.y, this.size, this.size);
  };
  Square13.prototype.split = function() {
    if (this.layer > maxLayers13) return; // Don't go too deep
    let halfSize = this.size / 2;
    square13Array.push(new Square13(this.x, this.y, halfSize, this.layer + 1)); // Replace self with 4 new squares
    square13Array.push(new Square13(this.x + halfSize, this.y, halfSize, this.layer + 1));
    square13Array.push(new Square13(this.x, this.y + halfSize, halfSize, this.layer + 1));
    square13Array.push(new Square13(this.x + halfSize, this.y + halfSize, halfSize, this.layer + 1));
    square13Array.splice(square13Array.indexOf(this), 1);
  };
  let square13Array = [];
  
  function drawFace13(x, y, size) {
    // Head
    ctx13.lineWidth = 1;
    ctx13.fillStyle = ctx13.strokeStyle = `hsl(${Math.random() * 360}deg, ${randBetween(80, 100)}%, ${randBetween(40, 60)}%)`;
    ctx13.fillRect(x, y, size, size);
    ctx13.strokeRect(x, y, size, size);
    
    // Eyes
    let eyeSize = size * 0.1;
    let pupilSize = eyeSize * randBetween(0.3, 0.8);
    let lEyeX = x + (size * 0.25);
    let rEyeX = x + (size * 0.75);
    let eyeY = y + (size / 2);
    ctx13.fillStyle = "white";
    ctx13.fillCircle(lEyeX, eyeY, eyeSize);
    ctx13.fillCircle(rEyeX, eyeY, eyeSize);
    ctx13.fillStyle = "black";
    ctx13.fillCircle(lEyeX, eyeY, pupilSize);
    ctx13.fillCircle(rEyeX, eyeY, pupilSize);
    
    if (Math.random() >= 0.5) {
      // Eyebrows
      let eyebrowY = y + (size * randBetween(0.3, 0.4));
      let eyebrowXOffset = size * randBetween(0.02, 0.05);
      let eyebrowAngle = randBetween(-0.25, 0.25);
      ctx13.strokeStyle = "black";
      ctx13.lineCap = ctx13.lineJoin = "round";
      ctx13.lineWidth = size * 0.02;
      ctx13.beginPath();
      ctx13.ellipse(lEyeX - eyebrowXOffset, eyebrowY, eyeSize * randBetween(0.9, 1.1), eyeSize * randBetween(0.5, 0.9), eyebrowAngle, -randBetween(0.25, 0.5), Math.PI + randBetween(0.25, 0.5), true);
      ctx13.stroke();
      if (Math.random() >= 0.5) eyebrowAngle = randBetween(-0.25, 0.25); // 50% change eyebrows are asymmetric
      else eyebrowAngle *= -1;
      ctx13.beginPath();
      ctx13.ellipse(rEyeX + eyebrowXOffset, eyebrowY, eyeSize * randBetween(0.9, 1.1), eyeSize * randBetween(0.5, 0.9), eyebrowAngle, -randBetween(0.25, 0.5), Math.PI + randBetween(0.25, 0.5), true);
      ctx13.stroke();
    }
    
    // Mouth
    let mouthRadX = size * randBetween(0.05, 0.1);
    let mouthRadY = size * randBetween(0.05, 0.1);
    let mouthY = y + (size * randBetween(0.6, 0.7));
    ctx13.fillStyle = "black";
    ctx13.beginPath();
    ctx13.ellipse(x + (size / 2), mouthY, mouthRadX, mouthRadY, 0, 0, Math.PI, Math.random() >= 0.5);
    ctx13.fill();
  }
  
  function drawSquares13() {
    ctx13.clearRect(0, 0, canvas13.width, canvas13.height);
    square13Array = [];
    square13Array.push(new Square13(0, 0, canvas13.width, 1));
    for (let i = 0; i < splitsPerDraw13; i++) {
      square13Array[Math.floor(Math.random() * square13Array.length)].split();
    }
    for (let i = 0; i < square13Array.length; i++) square13Array[i].draw();
  }
  drawSquares13();
</script>
<canvas id = "canvas12" style = "background-color: black"></canvas>
<button onclick = "startCanvas12()">Start/Stop</button>
<button onclick = "reset12()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps12Txt"></span></b></i></div>
<div class = "desc"><b><i>(10/28/2021)</i></b> Simple colorful interlocking rings animation, I might add settings later but for now this is all there is to it.</div>
<hr><hr>
<script>
  const ctx12 = canvas12.getContext("2d");
  canvas12.width = canvas12.height = 1000;
  let canvas12Running = false;
  
  function Ring12(startAngle, radius, arcLength, sign, color) {
    this.x = canvas12.width / 2;
    this.y = canvas12.height / 2;
    this.radius = radius;
    this.arcLength = toRad(arcLength);
    this.sign = sign;
    this.speed = this.sign === 1 ? 0.03 : 0.015;
    this.angle = toRad(startAngle) - (this.speed * this.sign);
    this.color = color;
  }
  Ring12.prototype.render = function() {
    this.angle += this.speed * this.sign;
    ctx12.strokeStyle = this.color;
    ctx12.globalAlpha = 1//0.25;
    ctx12.lineWidth = 15// * 4;
    ctx12.lineCap = ctx12.lineJoin = "round";
    ctx12.beginPath();
    ctx12.arc(this.x, this.y, this.radius, this.angle, this.angle + this.arcLength);
    ctx12.stroke();
  };
  let ring12Array = [];
  for (let i = 0; i < 25; i++) ring12Array.push(new Ring12(-i * 10, i * 20, 90 + (i * 5), i % 2 === 0 ? 1 : -1, `hsl(${(i / 25) * 360}deg, 100%, 50%)`));
  function reset12() {
    ring12Array = [];
    for (let i = 0; i < 25; i++) ring12Array.push(new Ring12(-i * 10, i * 20, 90 + (i * 5), i % 2 === 0 ? 1 : -1, `hsl(${(i / 25) * 360}deg, 100%, 50%)`));
    
    if (!canvas12Running) frame12();
  }
  
  let lastFrame12Time = 0;
  let lastFps12DisplayTime = 1000;
  
  function frame12() {
    if (Date.now() - lastFps12DisplayTime >= 500) {
      fps12Txt.innerHTML = (1000 / (Date.now() - lastFrame12Time)).toFixed(1);
      lastFps12DisplayTime = Date.now();
    }
    lastFrame12Time = Date.now();
    
    ctx12.clearRect(0, 0, canvas12.width, canvas12.height);
    
    for (let i = 0; i < ring12Array.length; i++) ring12Array[i].render();
    
    if (canvas12Running) requestAnimationFrame(frame12);
  }
  frame12();
  
  function startCanvas12() {
    if (canvas12Running) canvas12Running = false;
    else {
      canvas12Running = true;
      frame12();
    }
  }
</script>
<canvas id = "canvas11" style = "width: 600px; height: 300px"></canvas>
<button onclick = "drawMountains11()">Regenerate</button>
<div class = "desc"><b><i>(10/28/2021)</i></b> Generative mountain range with fog, based on <a href = "https://www.reddit.com/r/creativecoding/comments/ndsrfl/randomly_generated_mountains_with_fog_based_on_a" target = "_blank">this</a> Reddit post. Basically, each mountain starts at a certain level and a random walker traces the peaks of the mountain by moving along and varying the y-coordinate. Each time it's redrawn, there's a random fog level (brightness contrast between closest mountain and furthest mountain), random height ratio (how high up the tallest mountains can start), and random number of mountains. Each mountain is given a random steepness (how much the random walker tracing the mountain moves vertically per step) and a random ratio offset for starting height and coloring, to give more variation.</div>
<hr><hr>
<script>
  const ctx11 = canvas11.getContext("2d");
  canvas11.width = 1000;
  canvas11.height = 500;
  
  function drawMountains11() {
    ctx11.clearRect(0, 0, canvas11.width, canvas11.height);
    
    let heightRatio = randBetween(0.1, 0.3); // How high the tallest mountains can start
    let numLayers = Math.round(randBetween(5, 15)); // Number of mountains
    let fog = randBetween(0.6, 1); // Brightness contrast between closest and furthest mountains
    let invFog = 1 - fog;
    
    for (let i = 0; i < numLayers; i++) {
      let steepness = randBetween(3, 8); // How much the random walker tracing the mountain moves each time
      let ratio = (i + randBetween(-0.5, 0.5)) / numLayers;
      let invRatio = 1 - ratio;
      ctx11.fillStyle = `hsl(0deg, 0%, ${(invRatio * 100 * fog) + (50 * invFog)}%)`; // Color it based on what mountain we're on
      let currY = (canvas11.height * heightRatio) + ratio * canvas11.height * (1 - heightRatio);
      ctx11.beginPath();
      ctx11.moveTo(0, currY);
      for (let j = 0; j <= canvas11.width; j += 2) { // Move the random walker along the x-axis
        currY += steepness * Math.random() * randSign(); // Move the random walker up or down the y-axis randomly
        ctx11.lineTo(j, currY);
      }
      ctx11.lineTo(canvas11.width, canvas11.height); // Close up the path
      ctx11.lineTo(0, canvas11.height);
      ctx11.lineTo(0, ratio * canvas11.height);
      ctx11.fill();
    }
  }
  drawMountains11();
</script>
<canvas id = "canvas10"></canvas>
<button onclick = "startCanvas10()">Start/Stop</button>
<button onclick = "reset10()">Reset</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps10Txt"></span></b></i></div>
<div class = "desc"><b><i>(10/28/2021)</i></b> Simple random walker art with 200 random walkers of different colors drawing along the canvas, with their brightness being determined by their starting y-position, and their hue determined by their starting x-position.</div>
<hr><hr>
<script>
  const ctx10 = canvas10.getContext("2d");
  canvas10.width = canvas10.height = 1000;
  let canvas10Running = false;
  
  let gridSize10 = 20;
  let tileSize10 = canvas10.width / gridSize10;
  let stepsPerFrame10 = 25;
  let walkerSpeed10 = 2;
  
  function Walker10() {
    this.x = Math.random() * canvas10.width;
    this.y = Math.random() * canvas10.height;
    this.color = `hsl(${(this.x / canvas10.width) * 360}deg, 50%, ${(this.y / canvas10.height) * 100}%)`;//`rgb(${(this.x / canvas10.width) * 255}, ${(this.y / canvas10.height) * 255}, ${((this.x * this.y) / (canvas10.width * canvas10.height)) * 255})`;
  }
  Walker10.prototype.walk = function() {
    for (let i = 0; i < stepsPerFrame10; i++) {
      let lastX = this.x;
      let lastY = this.y;
      let a = Math.random() * Math.PI * 2;
      this.x += walkerSpeed10 * Math.cos(a);
      this.y += walkerSpeed10 * Math.sin(a);
      
      // Wrap around sides, and update lastX and lastY so it doesn't draw a line across the whole canvas
      if (this.x > canvas10.width) {
        this.x = lastX = 0;
      }
      if (this.x < 0) {
        this.x = lastX = canvas10.width;
      }
      if (this.y > canvas10.height) {
        this.y = lastY = 0;
      }
      if (this.y < 0) {
        this.y = lastY = canvas10.height;
      }
      ctx10.strokeStyle = this.color;
      ctx10.beginPath();
      ctx10.moveTo(lastX, lastY);
      ctx10.lineTo(this.x, this.y);
      ctx10.stroke();
    }
  };
  let walker10Array = [];
  for (let i = 0; i < 200; i++) walker10Array.push(new Walker10());
  function reset10() {
    ctx10.clearRect(0, 0, canvas10.width, canvas10.height);
    walker10Array = [];
    for (let i = 0; i < 200; i++) walker10Array.push(new Walker10());
    if (!canvas10Running) frame10();
  }
  
  let lastFrame10Time = 0;
  let lastFps10DisplayTime = 1000;
  
  function frame10() {
    if (Date.now() - lastFps10DisplayTime >= 500) {
      fps10Txt.innerHTML = (1000 / (Date.now() - lastFrame10Time)).toFixed(1);
      lastFps10DisplayTime = Date.now();
    }
    lastFrame10Time = Date.now();
    
    for (let i = 0; i < walker10Array.length; i++) walker10Array[i].walk();
    
    if (canvas10Running) requestAnimationFrame(frame10);
  }
  frame10();
  
  function startCanvas10() {
    if (canvas10Running) canvas10Running = false;
    else {
      canvas10Running = true;
      frame10();
    }
  }
</script>
<canvas id = "canvas9" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas9()">Start/Stop</button>
<button onclick = "resetClocks9()">Reset</button>
<button onclick = "randomizeClock9Times()">Randomize Times</button>
<button onclick = "resetClock9Times()">Reset Times to 12:00</button>
<div><b><u>Pixel Mode:</u></b></div>
<input type = "checkbox" id = "pixelMode9Checkbox" oninput = "updateSettings9(false)">
<div><b><u>Alternative Pixel Coloring:</u></b></div>
<input type = "checkbox" id = "pixelColoringMode9Checkbox" oninput = "updateSettings9(false)">
<div><b><u>Number of Real-Time Clocks:</u></b> <span id = "numRealTimeClocks9Txt">4</span></div>
<input type = "range" min = "0" max = "10" step = "1" value = "4" id = "numRealTimeClocks9Range" oninput = "updateSettings9(true)">
<div><b><u>Real-Time Clock Speed:</u></b> <span id = "clockSpeed9Txt">100</span>%</div>
<input type = "range" min = "0" max = "300" step = "10" value = "100" id = "clockSpeed9Range" oninput = "updateSettings9(false)">
<div><b><u>Clock Averaging Weight:</u></b> <span id = "weight9Txt">80</span>%</div>
<input type = "range" min = "0" max = "100" step = "10" value = "80" id = "weight9Range" oninput = "updateSettings9(false)">
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps9Txt"></span></b></i></div>
<div class = "desc"><b><i>(10/27/2021)</i></b> Cool clock animation, where each clock takes the average of its neighbors time, but some of them show their actual time, based on <a href = "https://www.reddit.com/r/generative/comments/kbvau2/oc_each_clock_shows_average_time_of_its_neighbors" target = "_blank">this</a> Reddit post (I actually didn't copy the code, I just used the idea and made it myself). I wanted to constantly modulus each clock's time so that it never goes past 720, but for some reason that throws the whole system off and you get these weird pulsations each time one of the real time clocks sets back to zero. Sadly this means the times are constantly counting up, but that's not really a huge deal. I also added pixel mode, based off an idea from a comment on that post, where each clock is rendered as a pixel with its hue being based on the hour hand's angle, and its brightness being based on the minute hand's angle.<br><b><i>(10/28/2021)</i></b> Added a setting and checkbox for aternative pixel coloring, so that the hue is based on the minute hand, and the brightness based on the hour hand, instead of vice versa.</div>
<hr><hr>
<script>
  const ctx9 = canvas9.getContext("2d");
  canvas9.width = canvas9.height = 1000;
  let canvas9Running = false;
  
  let gridSize9 = 30;
  let tileSize9 = canvas9.width / gridSize9;
  let weight9 = 0.2;
  let pixelMode9 = false;
  let numRealTimeClocks9 = 4;
  let clockSpeed9 = 1;
  let pixelColoringMode9 = 1;
  
  function Clock9(x, y, radius, indexX, indexY) {
    this.x = x;
    this.y = y;
    this.indexX = indexX;
    this.indexY = indexY;
    this.radius = radius;
    this.time = Math.random() * 720;
    this.hours = ((this.time / 60) + 12) % 12;
    this.minutes = (this.time + 60) % 60;
    this.realTime = false;
  }
  Clock9.prototype.updateTime = function() {
    //this.time = (this.time + 720) % 720;
    this.hours = ((this.time / 60) + 12) % 12;
    this.minutes = (this.time + 60) % 60;
  };
  Clock9.prototype.tick = function() {
    this.time += clockSpeed9;
    this.updateTime();
  };
  Clock9.prototype.draw = function() {
    if (pixelMode9) {
      let hourRatio = this.hours / 12;
      let minuteRatio = this.minutes / 60;
      if (pixelColoringMode9 === 1) ctx9.fillStyle = ctx9.strokeStyle = `hsl(${hourRatio * 360}deg, 100%, ${minuteRatio * 100}%)`;
      else ctx9.fillStyle = ctx9.strokeStyle = `hsl(${minuteRatio * 360}deg, 100%, ${hourRatio * 100}%)`;
      if (this.realTime) {
        ctx9.fillStyle = ctx9.strokeStyle = "white";
      }
      ctx9.lineWidth = 2;
      ctx9.fillRectFromCenter(this.x, this.y, tileSize9, tileSize9);
      ctx9.strokeRectFromCenter(this.x, this.y, tileSize9, tileSize9);
    }
    else {
      ctx9.lineCap = ctx9.lineJoin = "round";
      ctx9.lineWidth = 3;
      ctx9.strokeStyle = this.realTime ? "blue" : "white";
      
      let aH = ((this.hours / 12) * Math.PI * 2) - (Math.PI / 2);
      let rH = this.radius * 0.8;
      ctx9.beginPath();
      ctx9.moveTo(this.x, this.y);
      ctx9.lineTo(this.x + (rH * Math.cos(aH)), this.y + (rH * Math.sin(aH)));
      ctx9.stroke();
      
      let aM = ((this.minutes / 60) * Math.PI * 2) - (Math.PI / 2);
      let rM = this.radius;
      ctx9.beginPath();
      ctx9.moveTo(this.x, this.y);
      ctx9.lineTo(this.x + (rM * Math.cos(aM)), this.y + (rM * Math.sin(aM)));
      ctx9.stroke();
    }
  };
  Clock9.prototype.averageNeighbors = function() {
    let w = (1 - weight9) / 4;
    let T = clock9Array[this.indexX][(this.indexY - 1 + gridSize9) % gridSize9].time * w;
    let R = clock9Array[(this.indexX + 1) % gridSize9][this.indexY].time * w;
    let B = clock9Array[this.indexX][(this.indexY + 1) % gridSize9].time * w;
    let L = clock9Array[(this.indexX - 1 + gridSize9) % gridSize9][this.indexY].time * w;
    let M = this.time * weight9;
    this.time = M + T + R + B + L;
    this.updateTime();
  };
  let clock9Array = [];
  function resetClocks9() {
    clock9Array = [];
    tileSize9 = canvas9.width / gridSize9;
    for (let x = 0; x < gridSize9; x++) {
      let row = [];
      for (let y = 0; y < gridSize9; y++) {
        row.push(new Clock9((x + 0.5) * tileSize9, (y + 0.5) * tileSize9, tileSize9 * 0.4, x, y));
      }
      clock9Array.push(row);
    }
    
    for (let i = 0; i < numRealTimeClocks9; i++) {
      let x = Math.floor(Math.random() * gridSize9);
      let y = Math.floor(Math.random() * gridSize9);
      clock9Array[x][y].realTime = true;
    }
  }
  function randomizeClock9Times() {
    for (let x = 0; x < gridSize9; x++) {
      for (let y = 0; y < gridSize9; y++) {
        clock9Array[x][y].time = Math.random() * 720;
        clock9Array[x][y].updateTime();
      }
    }
  }
  function resetClock9Times() {
    for (let x = 0; x < gridSize9; x++) {
      for (let y = 0; y < gridSize9; y++) {
        clock9Array[x][y].time = 0;
        clock9Array[x][y].updateTime();
      }
    }
  }
  
  let lastFrame9Time = 0;
  let lastFps9DisplayTime = 1000;
  
  function frame9() {
    if (Date.now() - lastFps9DisplayTime >= 500) {
      fps9Txt.innerHTML = (1000 / (Date.now() - lastFrame9Time)).toFixed(1);
      lastFps9DisplayTime = Date.now();
    }
    lastFrame9Time = Date.now();
    
    ctx9.clearRect(0, 0, canvas9.width, canvas9.height);
    
    for (let x = 0; x < gridSize9; x++) {
      for (let y = 0; y < gridSize9; y++) {
        clock9Array[x][y].updateTime();
        if (clock9Array[x][y].realTime) clock9Array[x][y].tick();
        else clock9Array[x][y].averageNeighbors();
        clock9Array[x][y].draw();
      }
    }
    
    if (canvas9Running) requestAnimationFrame(frame9);
  }
  resetClocks9();
  frame9();
  
  function startCanvas9() {
    if (canvas9Running) canvas9Running = false;
    else {
      canvas9Running = true;
      frame9();
    }
  }
  
  function updateSettings9(reset) {
    numRealTimeClocks9 = numRealTimeClocks9Txt.innerHTML = Number(numRealTimeClocks9Range.value);
    pixelMode9 = pixelMode9Checkbox.checked;
    weight9 = 1 - (Number(weight9Range.value) / 100);
    weight9Txt.innerHTML = weight9Range.value;
    clockSpeed9 = Number(clockSpeed9Range.value) / 100;
    clockSpeed9Txt.innerHTML = clockSpeed9Range.value;
    
    pixelColoringMode9 = pixelColoringMode9Checkbox.checked ? 2 : 1;
    
    if (reset) resetClocks9();
    
    if (!canvas9Running) frame9();
  }
</script>
<canvas id = "canvas8" style = "width: 400px; height: 400px"></canvas>
<button onclick = "resetLines8()">Reset</button>
<table>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Mesh Size:</u></b> <span id = "gridSize8Txt">10x10</span></div>
      <input type = "range" min = "1" max = "25" step = "1" value = "10" id = "gridSize8Range" oninput = "updateSettings8()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Mesh Crumple:</u></b> <span id = "jitter8Txt">25</span>%</div>
      <input type = "range" min = "0" max = "50" step = "5" value = "25" id = "jitter8Range" oninput = "updateSettings8()">
    </td>
    <td>
      <div><b><u>Extra Crumple:</u></b></div>
      <input type = "checkbox" id = "superJitter8Checkbox" oninput = "updateSettings8()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Drawing Mode:</u></b></div>
      <input type = "radio" name = "drawMode8Radio" id = "drawMode8Radio1" oninput = "updateSettings8()">
      <label for = "drawMode8Radio1">Outline</label>
      <br>
      <input type = "radio" name = "drawMode8Radio" id = "drawMode8Radio2" oninput = "updateSettings8()">
      <label for = "drawMode8Radio2">Fill</label>
      <br>
      <input type = "radio" name = "drawMode8Radio" id = "drawMode8Radio3" oninput = "updateSettings8()" CHECKED>
      <label for = "drawMode8Radio3">Outline + Fill</label>
    </td>
    <td style = "padding: 10px">
      <div><b><u>Grayscale Fill:</u></b></div>
      <input type = "checkbox" id = "grayscale8Checkbox" oninput = "updateSettings8()">
      <br><br>
      <div><b><u>White Outline:</u></b></div>
      <input type = "checkbox" id = "whiteOutline8Checkbox" oninput = "updateSettings8()">
      <!--<div><b><u>Color Mode:</u></b></div>
      <input type = "radio" name = "colorMode8Radio" id = "colorMode8Radio1" oninput = "updateSettings8()">
      <label for = "colorMode8Radio1">Grayscale</label>
      <br>
      <input type = "radio" name = "colorMode8Radio" id = "colorMode8Radio2" oninput = "updateSettings8()">
      <label for = "colorMode8Radio2">Single Color</label>
      <br>
      <input type = "radio" name = "colorMode8Radio" id = "colorMode8Radio3" oninput = "updateSettings8()">
      <label for = "colorMode8Radio3">Rainbow</label>-->
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Outline Width:</u></b> <span id = "lineWidth8Txt">3</span>px</div>
      <input type = "range" min = "1" max = "15" step = "1" value = "3" id = "lineWidth8Range" oninput = "updateSettings8()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Fill Hue:</u></b> <span id = "hue8Txt">240</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "5" value = "240" id = "hue8Range" oninput = "updateSettings8()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Brightness Contrast:</u></b> <span id = "contrast8Txt">80</span>%</div>
      <input type = "range" min = "0" max = "100" step = "5" value = "80" id = "contrast8Range" oninput = "updateSettings8()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Hue Variation:</u></b> <span id = "hueVariation8Txt">30</span>%</div>
      <input type = "range" min = "0" max = "100" step = "5" value = "30" id = "hueVariation8Range" oninput = "updateSettings8()">
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(10/27/2021)</i></b> Generative triangular mesh art, from <a href = "https://generativeartistry.com/tutorials/triangular-mesh" target = "_blank">https://generativeartistry.com/tutorials/triangular-mesh</a>.<br><b><i>Update: (Later that day)</i></b> Added more settings for shaping and coloring the mesh that weren't in the tutorial, and sliders for everything.</div>
<hr><hr>
<script>
  const ctx8 = canvas8.getContext("2d");
  canvas8.width = canvas8.height = 1000;
  
  let gridSize8 = 10;
  let triangleSize8 = canvas8.width / gridSize8;
  let jitter8 = 0.25;
  let drawMode8 = 3; // 1: Outline, 2: Fill, 3: Outline + Fill
  let lineWidth8 = 3;
  let grayscale8 = false;
  let hue8 = 240;
  let contrast8 = 0.8;
  let hueVariation8 = 0.3;
  let superJitter8 = false;
  let whiteOutline8 = false;
  
  function drawOneTriangle8(a, b, c) {
    ctx8.lineWidth = lineWidth8;
    ctx8.lineCap = ctx8.lineJoin = "round";
    let color = "";
    let brightness = (0.5 + randBetween(-contrast8 / 2, contrast8 / 2)) * 100;
    let hue = hue8 + randBetween(-180 * hueVariation8, 180 * hueVariation8);
    color = grayscale8 ? `hsl(0deg, 0%, ${brightness}%)` : `hsl(${hue}deg, 100%, ${brightness}%)`;
    ctx8.strokeStyle = drawMode8 === 2 ? color : whiteOutline8 ? "white" : "black";
    ctx8.fillStyle = color;
    ctx8.beginPath();
    ctx8.moveTo(a.x, a.y);
    ctx8.lineTo(b.x, b.y);
    ctx8.lineTo(c.x, c.y);
    ctx8.lineTo(a.x, a.y);
    if (drawMode8 !== 1) ctx8.fill();
    ctx8.stroke();
  }
  
  let lines8 = [];
  function resetLines8() {
    triangleSize8 = canvas8.width / gridSize8;
    lines8 = [];
    let odd = false;
    for (let y = -triangleSize8; y <= canvas8.height + triangleSize8; y += triangleSize8) {
      odd = !odd;
      let line = [];
      for (let x = -triangleSize8; x <= canvas8.width + triangleSize8; x += triangleSize8) {
        line.push({
          x: x + (triangleSize8 * randBetween(-jitter8, jitter8)) + (odd ? triangleSize8 / 2 : 0),
          y: y + (triangleSize8 * randBetween(-jitter8, jitter8))
        });
      }
      lines8.push(line);
    }
    drawTriangles8();
  }
  
  function drawTriangles8() {
    ctx8.fillStyle = whiteOutline8 ? "black" : "white";
    ctx8.fillRect(0, 0, canvas8.width, canvas8.height);
    
    let line = [];
    let odd = true;
    for (let y = 0; y < lines8.length - 1; y++) {
      odd = !odd;
      line = [];
      for (let i = 0; i < lines8[y].length; i++) {
        line.push(odd ? lines8[y][i] : lines8[y + 1][i]);
        line.push(odd ? lines8[y + 1][i] : lines8[y][i]);
      }
      for (let i = 0; i < line.length - 2; i++) {
        drawOneTriangle8(line[i], line[i + 1], line[i + 2]);
      }
    }
  }
  resetLines8();
  
  function updateSettings8() {
    gridSize8 = Number(gridSize8Range.value);
    gridSize8Txt.innerHTML = gridSize8Range.value + "x" + gridSize8Range.value;
    
    superJitter8 = superJitter8Checkbox.checked;
    
    jitter8 = (Number(jitter8Range.value) / 100) * (superJitter8 ? 10 : 1);
    jitter8Txt.innerHTML = Number(jitter8Range.value) * (superJitter8 ? 10 : 1);
    
    if (drawMode8Radio1.checked) drawMode8 = 1;
    else if (drawMode8Radio2.checked) drawMode8 = 2;
    else if (drawMode8Radio3.checked) drawMode8 = 3;
    
    grayscale8 = grayscale8Checkbox.checked;
    
    whiteOutline8 = whiteOutline8Checkbox.checked;
    
    lineWidth8 = lineWidth8Txt.innerHTML = Number(lineWidth8Range.value);
    
    hue8 = hue8Txt.innerHTML = Number(hue8Range.value);
    
    contrast8 = Number(contrast8Range.value) / 100;
    contrast8Txt.innerHTML = contrast8Range.value;
    
    hueVariation8 = Number(hueVariation8Range.value) / 100;
    hueVariation8Txt.innerHTML = hueVariation8Range.value;
    
    resetLines8();
  }
</script>
<canvas id = "canvas7" style = "background-color: black; width: 400px; height: 400px"></canvas>
<button onclick = "startCanvas7()">Start/Stop</button>
<button onclick = "reset7()">Reset Waves</button>
<button onclick = "globalSign7 *= -1">Change Direction</button>
<div style = "color: dimgray; margin: 5px; font-size: 11px"><i><b>FPS: <span id = "fps7Txt"></span></b></i></div>
<div><b><u>Wave Amplitude:</u></b> <span id = "amplitude7Txt">100</span>%</div>
<input type = "range" min = "20" max = "200" step = "10" value = "100" id = "amplitude7Range" oninput = "updateSettings7()">
<div><b><u>Wave Frequency:</u></b> <span id = "frequency7Txt">100</span>%</div>
<input type = "range" min = "10" max = "300" step = "10" value = "100" id = "frequency7Range" oninput = "updateSettings7()">
<div><b><u>Wave Period:</u></b> <span id = "period7Txt">50</span> frames</div>
<input type = "range" min = "5" max = "200" step = "1" value = "50" id = "period7Range" oninput = "updateSettings7()">
<div><b><u>Number of Waves:</u></b> <span id = "numWaves7Txt">10</span> copies</div>
<input type = "range" min = "1" max = "20" step = "1" value = "10" id = "numWaves7Range" oninput = "updateSettings7()">
<div><b><u>Wave Spacing:</u></b> <span id = "waveSpacing7Txt">10</span>px</div>
<input type = "range" min = "5" max = "50" step = "1" value = "10" id = "waveSpacing7Range" oninput = "updateSettings7()">
<div class = "desc"><b><i>(10/26/2021)</i></b> Additive sine waves visualization, I wanted it to look like some interesting generative art but it ended up being pretty dull.<br><b><i>Update: (Later that day)</i></b> Added more settings and sliders for everything, as well as an FPS counter.</div>
<hr><hr>
<script>
  const ctx7 = canvas7.getContext("2d");
  canvas7.width = canvas7.height = 1000;
  let canvas7Running = false;
  
  let currX7 = 0;
  let frequency7 = 1;
  let amplitude7 = 100;
  let period7 = 50;
  let numWaves7 = 10;
  let waveSpacing7 = 10;
  let globalSign7 = 1;
  
  let waves7 = [];
  for (let i = 0; i < 4; i++) waves7.push({a: randBetween(0.5, 1.5), f: randBetween(0.5, 4)});//waves7.push({a: 1, f: randBetween(0.5, 4)});
  
  function sineWave7(x) {
    let sum = 0;
    for (let i = 0; i < waves7.length; i++) sum += waves7[i].a * Math.sin(waves7[i].f * x);
    return sum;
  }
  
  let lastFrame7Time = 0;
  let lastFps7DisplayTime = 1000;
  
  function frame7() {
    if (Date.now() - lastFps7DisplayTime >= 500) {
      fps7Txt.innerHTML = (1000 / (Date.now() - lastFrame7Time)).toFixed(1);//Math.floor(1000 / (Date.now() - lastFrame7Time));
      lastFps7DisplayTime = Date.now();
    }
    lastFrame7Time = Date.now();
    
    ctx7.clearRect(0, 0, canvas7.width, canvas7.height);
    
    currX7 += (1 / period7) * globalSign7;
    /*for (let i = 0; i < waves7.length; i++) {
      waves7[i].f = i + Math.sin(currX7) + 1.5;
    }*/
    
    ctx7.lineWidth = 3;
    ctx7.lineCap = ctx7.lineJoin = "round";
    for (let j = 0; j < numWaves7; j++) {
      ctx7.strokeStyle = `hsl(${(j / numWaves7) * 360}deg, 100%, 50%)`;
      ctx7.beginPath();
      for (let i = -j * waveSpacing7; i < canvas7.width; i += 3) {
        let x = (i / canvas7.width) * Math.PI * 2 * frequency7;
        ctx7.lineTo(i + (j * waveSpacing7), (canvas7.height / 2) + (amplitude7 * sineWave7(x - currX7)));
      }
      ctx7.stroke();
    }
    
    if (canvas7Running) requestAnimationFrame(frame7);
  }
  frame7();
  
  function reset7() {
    waves7 = [];
    for (let i = 0; i < 4; i++) waves7.push({a: 1, f: randBetween(0.5, 4)});
    if (!canvas7Running) frame7();
  }
  
  function startCanvas7() {
    if (canvas7Running) canvas7Running = false;
    else {
      canvas7Running = true;
      frame7();
    }
  }
  
  function updateSettings7() {
    amplitude7 = amplitude7Txt.innerHTML = Number(amplitude7Range.value);
    frequency7 = Number(frequency7Range.value) / 100;
    frequency7Txt.innerHTML = Number(frequency7Range.value);
    period7 = period7Txt.innerHTML = Number(period7Range.value);
    numWaves7 = numWaves7Txt.innerHTML = Number(numWaves7Range.value);
    waveSpacing7 = waveSpacing7Txt.innerHTML = Number(waveSpacing7Range.value);
  }
</script>
<canvas id = "canvas6" style = "width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas6()">Start/Stop</button>
<button onclick = "square6Array = []; square6Array.push(new Square6(0, 0, canvas6.width, 1)); drawSquares6()">Reset</button>
<div class = "desc"><b><i>(10/24/2021)</i></b> Just simple square splitting where the mouse moves. It's not perfect, like I want it to not immediately split down to the lowest layer, and it gets laggy around ~2,000 squares.</div>
<hr><hr>
<script>
  const ctx6 = canvas6.getContext("2d");
  canvas6.width = canvas6.height = 1000;
  let canvas6Rect = canvas6.getBoundingClientRect();
  let canvas6Ratio = canvas6.width / 500;
  let canvas6Running = false;
  
  let Mouse6 = {
    x: 0,
    y: 0,
    touchingIndex: null
  };
  
  let maxLayers6 = 7;
  let maxSquares6 = 2000;
  
  function Square6(x, y, size, layer, index) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.layer = layer;
    square6Array.push(this);
    //let lr = Mouse6.x >= this.x && Mouse6.x <= this.x + this.size;
    //let tb = Mouse6.y >= this.y && Mouse6.y <= this.y + this.size;
    //if (lr && tb) Mouse6.touchingIndex = square6Array.indexOf(this);
  }
  Square6.prototype.draw = function() {
    ctx6.lineWidth = 5;
    ctx6.strokeRect(this.x, this.y, this.size, this.size);
  };
  Square6.prototype.split = function() {
    if (this.layer > maxLayers6) return;
    
    square6Array.splice(square6Array.indexOf(this), 1);
    
    let halfSize = this.size / 2;
    new Square6(this.x, this.y, halfSize, this.layer + 1);
    new Square6(this.x + halfSize, this.y, halfSize, this.layer + 1);
    new Square6(this.x, this.y + halfSize, halfSize, this.layer + 1);
    new Square6(this.x + halfSize, this.y + halfSize, halfSize, this.layer + 1);
  };
  let square6Array = [];
  square6Array.push(new Square6(0, 0, canvas6.width, 1));
  
  function drawSquares6() {
    ctx6.clearRect(0, 0, canvas6.width, canvas6.height);
    for (let i = 0; i < square6Array.length; i++) square6Array[i].draw();
  }
  drawSquares6();
  
  function startCanvas6() {
    canvas6Running = !canvas6Running;
  }
  
  canvas6.addEventListener("mousemove", e => {
    if (!canvas6Running) return;
    canvas6Rect = canvas6.getBoundingClientRect();
    let eX = (e.clientX - canvas6Rect.left) * canvas6Ratio;
    let eY = (e.clientY - canvas6Rect.top) * canvas6Ratio;
    Mouse6.x = eX;
    Mouse6.y = eY;
    for (let i = 0; i < square6Array.length; i++) {
      let lr = Mouse6.x >= square6Array[i].x && Mouse6.x <= square6Array[i].x + square6Array[i].size;
      let tb = Mouse6.y >= square6Array[i].y && Mouse6.y <= square6Array[i].y + square6Array[i].size;
      //console.log(Mouse6.touchingIndex, i);
      if (lr && tb) {
        square6Array[i].split();
        drawSquares6();
        return;
      }
    }
  });
</script>
<canvas id = "canvas5" style = "background-color: black; width: 500px; height: 500px"></canvas>
<button onclick = "startCanvas5()">Start/Stop</button>
<button onclick = "reset5()">Reset</button>
<button onclick = "addPoints5()">Add Points</button>
<table>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Number of Gravity Wells:</u></b> <span id = "numBlackHoles5Txt">25</span></div>
      <input type = "range" min = "0" max = "15" value = "12" id = "numBlackHoles5Range" oninput = "updateSettings5()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Gravity Well Strength:</u></b> <span id = "blackHole5PowerTxt">150</span>%</div>
      <input type = "range" min = "50" max = "500" step = "50" value = "150" id = "blackHole5PowerRange" oninput = "updateSettings5()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Friction:</u></b> <span id = "friction5Txt">10</span>%</div>
      <input type = "range" min = "5" max = "50" step = "5" value = "10" id = "friction5Range" oninput = "updateSettings5()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Point Spawning:</u></b></div>
      <input type = "radio" name = "point5SpawningRadio" id = "point5SpawningRadio1" oninput = "updateSettings5()" CHECKED>
      <label for = "point5SpawningRadio1">Points spawn at edges</label>
      <br>
      <input type = "radio" name = "point5SpawningRadio" id = "point5SpawningRadio2" oninput = "updateSettings5()">
      <label for = "point5SpawningRadio2">Points spawn randomly on canvas</label>
    </td>
    <td style = "padding: 10px">
      <div><b><u>Point Spawn Velocity:</u></b> <span id = "spawningVelocity5Txt">0</span></div>
      <input type = "range" min = "0" max = "10" step = "1" value = "0" id = "spawningVelocity5Range" oninput = "updateSettings5()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Line Width:</u></b> <span id = "lineWidth5Txt">0.5</span>px</div>
      <input type = "range" min = "0" max = "12" step = "1" value = "4" id = "lineWidth5Range" oninput = "updateSettings5()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Line Opacity:</u></b> <span id = "opacity5Txt">100</span>%</div>
      <input type = "range" min = "0" max = "15" step = "1" value = "15" id = "opacity5Range" oninput = "updateSettings5()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Line Hue:</u></b> <span id = "hue5Txt">0</span>&deg;</div>
      <input type = "range" min = "0" max = "360" step = "15" value = "0" id = "hue5Range" oninput = "updateSettings5()">
    </td>
    <td style = "padding: 10px">
      <div><b><u>Line Brightness:</u></b> <span id = "brightness5Txt">60</span>%</div>
      <input type = "range" min = "0" max = "100" step = "10" value = "60" id = "brightness5Range" oninput = "updateSettings5()">
    </td>
  </tr>
  <tr>
    <td style = "padding: 10px">
      <div><b><u>Color Variation:</u></b> <span id = "colorVariation5Txt">40</span>%</div>
      <input type = "range" min = "0" max = "100" step = "10" value = "40" id = "colorVariation5Range" oninput = "updateSettings5()">
    </td>
  </tr>
</table>
<div class = "desc"><b><i>(10/23/2021)</i></b> Art generator where points are spawned in that are attracted to various gravity wells around the canvas, leaving a trial behind them.<br><b><i>(10/24/2021)</i></b> Added more settings and sliders for everything.<br><b><i><mark>Actually finished! (5/18/2022)</mark> Moved to <a href = "gravity-wells.html" target = "_blank">gravity-wells.html</a>.</i></b></div>
<hr><hr>
<script>
  const ctx5 = canvas5.getContext("2d");
  canvas5.width = canvas5.height = 1000;
  let canvas5Running = false;
  
  let friction5 = 0.1;
  let numBlackHoles5 = 25;
  let numPoints5 = 1000;
  let minDist5 = 5;
  let minAcceleration5 = 0.01;
  let blackHole5Power = 15;
  let brightness5 = 60;
  let lineWidth5 = 0.5;
  let opacity5 = 1;
  let edgeSpawning5 = true;
  let hue5 = 0;
  let stepsPerFrame5 = 1;
  let spawningVelocity5 = 0;
  let colorVariation5 = 0.4;
  
  function randCanvas5EdgePos() {
    let r = Math.floor(Math.random() * 4);
    if (r === 0) return {x: Math.random() * canvas5.width, y: 0};
    else if (r === 1) return {x: canvas5.width, y: Math.random() * canvas5.height};
    else if (r === 2) return {x: Math.random() * canvas5.width, y: canvas5.height};
    else return {x: 0, y: Math.random() * canvas5.height};
  }
  
  function Point5() {
    let p = randCanvas5EdgePos();
    this.x = edgeSpawning5 ? p.x : Math.random() * canvas5.width;
    this.y = edgeSpawning5 ? p.y : Math.random() * canvas5.height;
    let a = Math.random() * Math.PI * 2;
    this.vx = spawningVelocity5 * Math.cos(a);
    this.vy = spawningVelocity5 * Math.sin(a);
    this.stopped = false;
    let hue = hue5 + (Math.random() * colorVariation5 * 0.5 * 360 * randSign());
    this.color = `hsl(${hue}deg, 100%, ${brightness5}%)`;
  }
  Point5.prototype.render = function() {
    let lastX = this.x;
    let lastY = this.y;
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 1 - friction5;
    this.vy *= 1 - friction5;
    for (let i = 0; i < blackHole5Array.length; i++) {
      let dx = blackHole5Array[i].x - this.x;
      let dy = blackHole5Array[i].y - this.y;
      let distSq = (dx * dx) + (dy * dy);
      let dist = Math.sqrt(distSq);
      if (dist <= minDist5) {
        this.stopped = true;
        this.x = blackHole5Array[i].x;
        this.y = blackHole5Array[i].y;
      }
      let invDist = 1 / dist;
      let angle = Math.atan2(dy, dx);
      let velocity = blackHole5Array[i].powerRatio * blackHole5Power * invDist;
      velocity = Math.max(velocity, minAcceleration5);
      this.vx += velocity * Math.cos(angle);
      this.vy += velocity * Math.sin(angle);
    }
    ctx5.strokeStyle = this.color;
    ctx5.lineWidth = lineWidth5;
    ctx5.globalAlpha = opacity5;
    ctx5.lineCap = ctx5.lineJoin = "round";
    ctx5.beginPath();
    ctx5.moveTo(lastX, lastY);
    ctx5.lineTo(this.x, this.y);
    ctx5.stroke();
  };
  let point5Array = [];
  for (let i = 0; i < numPoints5; i++) point5Array.push(new Point5());
  
  function BlackHole5() {
    this.x = Math.random() * canvas5.width;
    this.y = Math.random() * canvas5.height;
    this.powerRatio = randBetween(0.5, 1);
  }
  let blackHole5Array = [];
  for (let i = 0; i < numBlackHoles5; i++) blackHole5Array.push(new BlackHole5());
  
  function frame5() {
    for (let j = 0; j < stepsPerFrame5; j++) {
      for (let i = 0; i < point5Array.length; i++) {
        point5Array[i].render();
        if (point5Array[i].stopped) {
          point5Array.splice(i, 1);
          i--;
        }
      }
    }
    
    if (canvas5Running) requestAnimationFrame(frame5);
  }
  frame5();
  
  function addPoints5() {
    while (point5Array.length < numPoints5) point5Array.push(new Point5());
    if (!canvas5Running) frame5();
  }
  
  function reset5() {
    ctx5.clearRect(0, 0, canvas5.width, canvas5.height);
    blackHole5Array = [];
    while (blackHole5Array.length < numBlackHoles5) blackHole5Array.push(new BlackHole5());
    point5Array = [];
    while (point5Array.length < numPoints5) point5Array.push(new Point5());
    if (!canvas5Running) frame5();
  }
  
  let numBlackHoles5RangeArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 40, 50];
  let lineWidth5RangeArray = [0.1, 0.2, 0.3, 0.4, 0.5, 1, 2, 3, 4, 5, 10, 15, 20];
  let opacity5RangeArray = [1, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 100];
  
  function updateSettings5() {
    numBlackHoles5 = numBlackHoles5Txt.innerHTML = numBlackHoles5RangeArray[Number(numBlackHoles5Range.value)];
    blackHole5PowerTxt.innerHTML = Number(blackHole5PowerRange.value);
    blackHole5Power = Number(blackHole5PowerRange.value) / 10;
    friction5Txt.innerHTML = Number(friction5Range.value);
    friction5 = Number(friction5Range.value) / 100;
    edgeSpawning5 = point5SpawningRadio1.checked;
    spawningVelocity5 = spawningVelocity5Txt.innerHTML = Number(spawningVelocity5Range.value);
    lineWidth5 = lineWidth5Txt.innerHTML = lineWidth5RangeArray[Number(lineWidth5Range.value)];
    opacity5Txt.innerHTML = opacity5RangeArray[Number(opacity5Range.value)];
    opacity5 = opacity5RangeArray[Number(opacity5Range.value)] / 100;
    hue5 = hue5Txt.innerHTML = Number(hue5Range.value);
    brightness5 = brightness5Txt.innerHTML = Number(brightness5Range.value);
    colorVariation5Txt.innerHTML = Number(colorVariation5Range.value)
    colorVariation5 = Number(colorVariation5Range.value) / 100;
    
    while (blackHole5Array.length < numBlackHoles5) blackHole5Array.push(new BlackHole5());
    
    if (!canvas5Running) frame5();
  }
  
  function startCanvas5() {
    if (canvas5Running) canvas5Running = false;
    else {
      canvas5Running = true;
      frame5();
    }
  }
</script>
<canvas id = "canvas4"></canvas>
<button onclick = "startCanvas4()">Start/Stop</button>
<button onclick = "reset4()">Reset</button>
<div class = "desc"><b><i>(10/22/2021)</i></b> An attempt to make interesting spiral tiling with different settings for grow speed and turn speed, but I couldn't get it working right for when each spiral should stop drawing, so it doesn't look very interesting right now.</div>
<hr><hr>
<script>
  const ctx4 = canvas4.getContext("2d");
  canvas4.width = canvas4.height = 1000;
  let canvas4Running = false;
  
  let gridSize4 = 10;
  let tileSize4 = canvas4.width / gridSize4;
  let turnSpeed4 = 0.1;
  let growSpeed4 = 1;
  let stopped4 = false;
  
  function Spiral4(x, y, turnSign) {
    this.x = x;
    this.y = y;
    this.turnSign = turnSign;
    this.angle = 0;
    this.radius = 0;
  }
  Spiral4.prototype.render = function() {
    let lastX = this.x + (this.radius * Math.cos(this.angle));
    let lastY = this.y + (this.radius * Math.sin(this.angle));
    
    this.radius += growSpeed4;
    if (this.radius >= tileSize4 / 2) {
      stopped4 = true;
      return;
    }
    this.angle += turnSpeed4 * this.turnSign;
    ctx4.lineWidth = 3;
    ctx4.lineCap = ctx4.lineJoin = "round";
    ctx4.beginPath();
    ctx4.moveTo(lastX, lastY);
    ctx4.lineTo(this.x + (this.radius * Math.cos(this.angle)), this.y + (this.radius * Math.sin(this.angle)));
    ctx4.stroke();
  };
  let spiral4Array = [];
  for (let x = 0; x < gridSize4; x++) {
    for (let y = 0; y < gridSize4; y++) {
      spiral4Array.push(new Spiral4((x + 0.5) * tileSize4, (y + 0.5) * tileSize4, 1));
      spiral4Array.push(new Spiral4((x + 0.5) * tileSize4, (y + 0.5) * tileSize4, -1));
    }
  }
  
  function frame4() {
    if (!stopped4) {
      for (let i = 0; i < spiral4Array.length; i++) spiral4Array[i].render();
    }
    
    if (canvas4Running) requestAnimationFrame(frame4);
  }
  frame4();
  
  function reset4() {
    ctx4.clearRect(0, 0, canvas4.width, canvas4.height);
    spiral4Array = [];
    for (let x = 0; x < gridSize4; x++) {
      for (let y = 0; y < gridSize4; y++) {
        spiral4Array.push(new Spiral4((x + 0.5) * tileSize4, (y + 0.5) * tileSize4, 1));
        spiral4Array.push(new Spiral4((x + 0.5) * tileSize4, (y + 0.5) * tileSize4, -1));
      }
    }
    stopped4 = false;
    if (!canvas4Running) frame4();
  }
  
  function startCanvas4() {
    if (canvas4Running) canvas4Running = false;
    else {
      canvas4Running = true;
      frame4();
    }
  }
</script>
<canvas id = "canvas3"></canvas>
<button onclick = "startCanvas3()">Start/Stop</button>
<button onclick = "randomizeDots3()">Randomize &theta;</button>
<button onclick = "cosDots3()">&theta; = cos(&theta;)</button>
<div><b><u>Average Angle:</u></b> <span id = "dot3AngleTxt">0.000000</span> radians</div>
<div><b><u>Percent Error:</u></b> <span id = "error3Txt">100.000000</span>%</div>
<div class = "desc"><b><i>(10/18/2021)</i></b> Extremely simple (and probably not very helpful) visualization showing how the <a href = "https://en.wikipedia.org/wiki/Dottie_number" target = "_blank">Dottie number</a> (&#8776;0.739085 radians) shows up from repeatedly taking the cosine of any angle.</div>
<hr><hr>
<script>
  const ctx3 = canvas3.getContext("2d");
  canvas3.width = canvas3.height = 1000;
  let canvas3Running = false;
  
  let clearOpacity3 = 0.05;
  const DOTTIE_NUMBER = 0.739085;
  
  function Dot3() {
    this.x = Math.random() * canvas3.width;
    this.y = Math.random() * canvas3.height;
    this.lastX = this.x;
    this.lastY = this.y;
    this.velocity = 5;
    this.angle = 0;
    this.size = 2;
  };
  Dot3.prototype.render = function() {
    this.lastX = this.x;
    this.lastY = this.y;
    this.x += this.velocity * Math.cos(this.angle);
    this.y += this.velocity * Math.sin(this.angle);
    
    if (this.x > canvas3.width || this.x < 0) this.x = this.lastX = (this.x + canvas3.width) % canvas3.width;
    if (this.y > canvas3.height || this.y < 0) this.y = this.lastY = (this.y + canvas3.height) % canvas3.height;
    
    ctx3.lineWidth = this.size;
    ctx3.lineCap = ctx3.lineJoin = "round";
    ctx3.beginPath();
    ctx3.moveTo(this.lastX, this.lastY);
    ctx3.lineTo(this.x, this.y);
    ctx3.stroke();
  };
  let dot3Array = [];
  for (let i = 0; i < 50; i++) dot3Array.push(new Dot3());
  function randomizeDots3() {
    let sum = 0;
    for (let i = 0; i < dot3Array.length; i++) {
      dot3Array[i].angle = Math.random() * Math.PI * 2;
      sum += dot3Array[i].angle;
    }
    sum /= dot3Array.length;
    sum = (sum + (Math.PI * 2)) % (Math.PI * 2);
    sum = Number(sum.toFixed(6));
    dot3AngleTxt.innerHTML = sum;
    error3Txt.innerHTML = Math.abs((((sum - DOTTIE_NUMBER) / DOTTIE_NUMBER) * 100)).toFixed(6);
  }
  function cosDots3() {
    let sum = 0;
    for (let i = 0; i < dot3Array.length; i++) {
      dot3Array[i].angle = Math.cos(dot3Array[i].angle);
      sum += dot3Array[i].angle;
    }
    sum /= dot3Array.length;
    sum = (sum + (Math.PI * 2)) % (Math.PI * 2);
    sum = Number(sum.toFixed(6));
    dot3AngleTxt.innerHTML = sum;
    error3Txt.innerHTML = Math.abs((((sum - DOTTIE_NUMBER) / DOTTIE_NUMBER) * 100)).toFixed(6);
  }
  
  function frame3() {
    ctx3.fillStyle = `rgba(255, 255, 255, ${clearOpacity3})`;
    ctx3.fillRect(0, 0, canvas3.width, canvas3.height);
    
    for (let i = 0; i < dot3Array.length; i++) dot3Array[i].render();
    
    if (canvas3Running) requestAnimationFrame(frame3);
  }
  frame3();
  
  function startCanvas3() {
    if (canvas3Running) canvas3Running = false;
    else {
      canvas3Running = true;
      frame3();
    }
  }
</script>
<canvas id = "canvas2" style = "background-color: black"></canvas>
<button onclick = "startCanvas2()">Start/Stop</button>
<button onclick = "particle2Array = []">Clear</button>
<button onclick = "flowing2 = !flowing2">Toggle Flow</button>
<div><b><u>Flow Rate:</u></b> <span id = "flow2Txt">500</span>%</div>
<input type = "range" min = "0" max = "15" value = "12" step = "1" id = "flow2Range" oninput = "updateSettings2()">
<div class = "desc"><b><i>(10/18/2021)</i></b> Simple Plinko board simulation, showing random data distribution.</div>
<hr><hr>
<script>
  const ctx2 = canvas2.getContext("2d");
  canvas2.width = canvas2.height = 1000;
  let canvas2Running = false;
  
  let particle2Radius = 3;
  let peg2Radius = 10;
  let gravity2 = 0.1;
  let bounciness2 = 0.5;
  let stepsPerFrame2 = 1;
  let flow2 = 5;
  let hue2 = 240;
  let clearOpacity2 = 0.3;
  let flowing2 = true;
  const MAX_PARTICLES2 = 1200;
  
  function Particle2() {
    this.x = (canvas2.width / 2) + randBetween(-10, 10);
    this.y = -particle2Radius - (Math.random() * 5);
    this.vx = 0;
    this.vy = 0;
    this.dead = false;
    this.bounciness = bounciness2 * randBetween(0.75, 1);
    //hue2 = Math.random() * 360;
    this.color = `hsl(${hue2}deg, 100%, ${randBetween(20, 80)}%)`;
  }
  Particle2.prototype.render = function() {
    let lastX = this.x;
    let lastY = this.y;
    for (let i = 0; i < stepsPerFrame2; i++) {
      this.x += this.vx;
      this.y += this.vy;
      this.vy += gravity2;
      
      for (let i = 0; i < peg2Array.length; i++) {
        let dx = this.x - peg2Array[i].x;
        let dy = this.y - peg2Array[i].y;
        let distSq = (dx * dx) + (dy * dy);
        let rad = particle2Radius + peg2Radius;
        let radSq = rad * rad;
        if (distSq <= radSq) {
          let angle = Math.atan2(dy, dx);
          let collX = Math.cos(angle);
          let collY = Math.sin(angle);
          let speed = ((this.vx * collX) + (this.vy * collY)) * 2;
          this.vx -= this.bounciness * speed * collX;
          this.vy -= this.bounciness * speed * collY;
          this.x = peg2Array[i].x + (rad * collX);
          this.y = peg2Array[i].y + (rad * collY);
        }
      }
      
      if (this.y - particle2Radius >= canvas2.height) {
        this.dead = true;
        let _x = this.x.toMultipleOf(Rows2.tileSize) / Rows2.tileSize;
        if (_x < 0) return;
        if (_x >= Rows2.array.length) return;
        //Rows2.array[_x]++;
      }
    }
    
    ctx2.strokeStyle = this.color;
    ctx2.lineWidth = particle2Radius * 2;
    ctx2.lineJoin = ctx2.lineCap = "round";
    ctx2.beginPath();
    ctx2.moveTo(lastX, lastY);
    ctx2.lineTo(this.x, this.y);
    ctx2.stroke();
  };
  let particle2Array = [];
  
  function Peg2(x, y) {
    this.x = x;
    this.y = y;
  }
  Peg2.prototype.render = function() {
    ctx2.fillStyle = "white";
    ctx2.fillCircle(this.x, this.y, peg2Radius);
  };
  let peg2Array = [];
  for (let y = 0; y <= 8; y++) {
    for (let x = 0; x <= 10; x++) {
      let _x = y % 2 === 0 ? x : x + 0.5;
      peg2Array.push(new Peg2(_x * (canvas2.width / 10), 100 + (y * (canvas2.height / 10))));
    }
  }
  
  let Rows2 = {
    array: [],
    tileSize: 5,
    opacity: 0.5
  };
  Rows2.render = function() {
    ctx2.globalAlpha = this.opacity;
    ctx2.fillStyle = "white";
    for (let i = 0; i < this.array.length; i++) {
      let h = this.array[i] * this.tileSize;
      ctx2.fillRect(i * this.tileSize, canvas2.height - h, this.tileSize, h);
    }
    ctx2.globalAlpha = 1;
  };
  
  for (let i = 0; i < canvas2.width / Rows2.tileSize; i++) Rows2.array.push(0);
  
  function frame2() {
    ctx2.fillStyle = `rgba(0, 0, 0, ${clearOpacity2})`;
    ctx2.fillRect(0, 0, canvas2.width, canvas2.height);
    
    if (flowing2 && (particle2Array.length < MAX_PARTICLES2)) {
      if (flow2 >= 1) {
        for (let i = 0; i < flow2; i++) particle2Array.push(new Particle2());
      }
      else {
        if (Math.random() <= flow2) particle2Array.push(new Particle2());
      }
    }
    
    while (particle2Array.length > MAX_PARTICLES2) particle2Array.pop();
    
    //Rows2.render();
    
    for (let i = 0; i < particle2Array.length; i++) {
      particle2Array[i].render();
      if (particle2Array[i].dead) {
        particle2Array.splice(i, 1);
        i--;
      }
    }
    for (let i = 0; i < peg2Array.length; i++) peg2Array[i].render();
    
    if (canvas2Running) requestAnimationFrame(frame2);
  }
  frame2();
  
  function startCanvas2() {
    if (canvas2Running) canvas2Running = false;
    else {
      canvas2Running = true;
      frame2();
    }
  }
  
  let flow2RangeArray = [1, 5, 10, 20, 30, 40, 50, 75, 100, 200, 300, 400, 500, 600, 700, 800];
  
  function updateSettings2() {
    flow2 = flow2Txt.innerHTML = flow2RangeArray[Number(flow2Range.value)];
    flow2 = flow2RangeArray[Number(flow2Range.value)] / 100;
  }
</script>
<canvas id = "canvas1" style = "background-color: black"></canvas>
<button onclick = "startCanvas1()">Start/Stop</button>
<div class = "desc"><b><i>(10/17/2021)</i></b> Holomorphic Dynamics visualization of escape paths. The yellow point is the starting value, and the blue point is the <b><i>c</i></b> value for the equation <b><i>z_n+1 = (z_n)^2 + c</i></b>. The red lines show the paths of the point through several iterations in the complex plane, scaled from -1 to 1. The mouse cursor drags either point.</div>
<hr><hr>
<script>
  const ctx1 = canvas1.getContext("2d");
  canvas1.width = canvas1.height = 1000;
  let canvas1Running = false;
  let canvas1Rect = canvas1.getBoundingClientRect();
  let canvas1Ratio = canvas1.width / 300;
  
  let Mouse1 = {
    down: false
  };
  
  let scale1 = canvas1.width / 2;
  
  function gridToActual1(x, y) {
    return {x: (x * scale1) + (canvas1.width / 2), y: (canvas1.height / 2) - (y * scale1)};
  }
  function actualToGrid1(x, y) {
    return {x: (x - (canvas1.width / 2)) / scale1, y: ((canvas1.height / 2) - y) / scale1};
  }
  
  let HolomorphicDynamic = {
    constant: {
      a: -0.52,
      b: 0.58
    },
    start: {
      a: 0,
      b: 0
    },
    iterations: 25
  };
  HolomorphicDynamic.square = function(z) {
    return {a: (z.a * z.a) - (z.b * z.b), b: 2 * z.a * z.b};
  };
  HolomorphicDynamic.draw = function() {
    let curr = this.start;
    ctx1.lineWidth = 3;
    ctx1.strokeStyle = "red";
    ctx1.beginPath();
    let p = gridToActual1(this.start.a, this.start.b);
    ctx1.moveTo(p.x, p.y);
    for (let i = 0; i < this.iterations; i++) {
      let sq = this.square(curr);
      curr = {a: sq.a + this.constant.a, b: sq.b + this.constant.b};
      
      if (!(Math.abs(curr.a) >= 1000 || Math.abs(curr.b) >= 1000)) {
        let p = gridToActual1(curr.a, curr.b);
        ctx1.lineTo(p.x, p.y);
      }
    }
    ctx1.stroke();
    
    ctx1.font = "bold 30px arial";
    p = gridToActual1(this.constant.a, this.constant.b);
    ctx1.fillStyle = "blue";
    ctx1.fillCircle(p.x, p.y, 10);
    ctx1.fillStyle = "rgba(255, 255, 255, 0.75)";
    ctx1.fillText(`(${this.constant.a.toFixed(2)} ${this.constant.b >= 0 ? "+" : "-"} ${Math.abs(this.constant.b).toFixed(2)}i)`, p.x + 15, p.y + 10);
    
    p = gridToActual1(this.start.a, this.start.b);
    ctx1.fillStyle = "yellow";
    ctx1.fillCircle(p.x, p.y, 10);
    ctx1.fillStyle = "rgba(255, 255, 255, 0.75)";
    ctx1.fillText(`(${this.start.a.toFixed(2)} ${this.start.b >= 0 ? "+" : "-"} ${Math.abs(this.start.b).toFixed(2)}i)`, p.x + 15, p.y + 10);
  };
  
  function frame1() {
    ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
    
    ctx1.lineWidth = 3;
    ctx1.strokeStyle = "white";
    ctx1.lineCap = ctx1.lineJoin = "round";
    ctx1.beginPath();
    ctx1.moveTo(0, canvas1.height / 2);
    ctx1.lineTo(canvas1.width, canvas1.height / 2);
    ctx1.stroke();
    ctx1.beginPath();
    ctx1.moveTo(canvas1.width / 2, 0);
    ctx1.lineTo(canvas1.width / 2, canvas1.height);
    ctx1.stroke();
    
    HolomorphicDynamic.draw();
    
    if (canvas1Running) requestAnimationFrame(frame1);
  }
  frame1();
  
  function startCanvas1() {
    if (canvas1Running) canvas1Running = false;
    else {
      canvas1Running = true;
      frame1();
    }
  }
  
  canvas1.addEventListener("mousedown", e => {
    if (!canvas1Running) return;
    e.preventDefault();
    Mouse1.down = true;
    canvas1Rect = canvas1.getBoundingClientRect();
    let eX = (e.clientX - canvas1Rect.left) * canvas1Ratio;
    let eY = (e.clientY - canvas1Rect.top) * canvas1Ratio;
    let c = gridToActual1(HolomorphicDynamic.constant.a, HolomorphicDynamic.constant.b);
    let s = gridToActual1(HolomorphicDynamic.start.a, HolomorphicDynamic.start.b);
    let dx1 = eX - c.x;
    let dx2 = eX - s.x;
    let dy1 = eY - c.y;
    let dy2 = eY - s.y;
    let distSqC = (dx1 * dx1) + (dy1 * dy1);
    let distSqS = (dx2 * dx2) + (dy2 * dy2);
    let p = actualToGrid1(eX, eY);
    if (distSqC < distSqS) {
      HolomorphicDynamic.constant.a = p.x;
      HolomorphicDynamic.constant.b = p.y;
    }
    else {
      HolomorphicDynamic.start.a = p.x;
      HolomorphicDynamic.start.b = p.y;
    }
  });
  window.addEventListener("mouseup", e => {
    if (!canvas1Running) return;
    Mouse1.down = false;
  });
  canvas1.addEventListener("mousemove", e => {
    if (!canvas1Running || !Mouse1.down) return;
    e.preventDefault();
    canvas1Rect = canvas1.getBoundingClientRect();
    let eX = (e.clientX - canvas1Rect.left) * canvas1Ratio;
    let eY = (e.clientY - canvas1Rect.top) * canvas1Ratio;
    let c = gridToActual1(HolomorphicDynamic.constant.a, HolomorphicDynamic.constant.b);
    let s = gridToActual1(HolomorphicDynamic.start.a, HolomorphicDynamic.start.b);
    let dx1 = eX - c.x;
    let dx2 = eX - s.x;
    let dy1 = eY - c.y;
    let dy2 = eY - s.y;
    let distSqC = (dx1 * dx1) + (dy1 * dy1);
    let distSqS = (dx2 * dx2) + (dy2 * dy2);
    let p = actualToGrid1(eX, eY);
    if (distSqC < distSqS) {
      HolomorphicDynamic.constant.a = p.x;
      HolomorphicDynamic.constant.b = p.y;
    }
    else {
      HolomorphicDynamic.start.a = p.x;
      HolomorphicDynamic.start.b = p.y;
    }
  });
</script>




</body>
</html>
