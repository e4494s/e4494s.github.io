const ctx83 = canvas83.getContext("2d");
  canvas83.width = canvas83.height = 1000;
  let canvas83Running = false;
  
  let gridSize83 = 6;
  let tileSize83 = canvas83.width / gridSize83;
  let hue83 = 120;
  let brightness83 = 50;
  let lineWidth83 = 1;
  let turnSpeed83 = 3;
  let alternateDirections83 = true;
  let globalSign83 = 1;
  
  let clear83 = false;
  let loop83 = true;
  let turbo83 = false;
  
  ctx83.translate(canvas83.width / 2, canvas83.height / 2);
  ctx83.rotate(Math.PI / 4);
  ctx83.fillStyle = "black";
  ctx83.fillRect(-canvas83.width, -canvas83.height, canvas83.width * 2, canvas83.height * 2);
  
  function Square83(x, y, initialSize, turnSign) {
    this.x = x;
    this.y = y;
    this.initialSize = initialSize * Math.SQRT1_2;
    this.size = this.initialSize;
    this.angle = 0;
    this.turnSign = turnSign;
    this.lastSize = this.size;
    this.lastAngle = this.angle;
  }
  Square83.prototype.render = function() {
    if (this.size < 0.25) clear83 = true;
    if (this.size < 0.001) this.size = this.lastSize = 0;
    this.angle = (this.angle + 90) % 90;
    let diff = ((this.angle - this.lastAngle) + 90) % 90;
    this.size = this.lastSize / (Math.sin(toRad(90 - diff)) + Math.cos(toRad(90 - diff)));
    let currA = this.angle + 45;
    ctx83.beginPath();
    for (let i = 0; i <= 4; i++) {
      currA += 90;
      ctx83.lineTo(this.x + (this.size * Math.cos(toRad(currA))), this.y + (this.size * Math.sin(toRad(currA))));
    }
    ctx83.stroke();
    this.lastAngle = this.angle;
    this.lastSize = this.size;
    this.angle += turnSpeed83 * this.turnSign;
  };
  let square83Array = [];
  for (let x = -3; x < gridSize83 + 3; x++) {
    for (let y = -3; y < gridSize83 + 3; y++) {
      let turnSign = ((x + y) % 2 === 0) ? 1 : -1;
      if (!alternateDirections83) turnSign = 1;
      turnSign *= globalSign83;
      square83Array.push(new Square83((x * tileSize83) + (tileSize83 / 2) - (canvas83.width / 2), (y * tileSize83) + (tileSize83 / 2) - (canvas83.height / 2), tileSize83, turnSign));
    }
  }
  
  function frame83() {
    let iterations = turbo83 ? 5 : 1;
    ctx83.strokeStyle = `hsl(${hue83}deg, 100%, ${brightness83}%)`;
    ctx83.lineWidth = lineWidth83;
    
    for (let j = 0; j < iterations; j++) {
      for (let i = 0; i < square83Array.length; i++) square83Array[i].render();
      
      if (clear83 && loop83) reset83();
    }
    
    currentAngle83Txt.innerHTML = square83Array[0].size === 0 ? 0 : square83Array[0].lastAngle;
    
    if (canvas83Running) setTimeout(() => requestAnimationFrame(frame83), 25);
  }
  reset83();
  
  function reset83() {
    ctx83.fillStyle = "black";
    ctx83.fillRect(-canvas83.width, -canvas83.height, canvas83.width * 2, canvas83.height * 2);
    clear83 = false;
    for (let i = 0; i < square83Array.length; i++) {
      square83Array[i].size = square83Array[i].initialSize;
      square83Array[i].angle = 0;
      square83Array[i].lastSize = square83Array[i].size;
      square83Array[i].lastAngle = square83Array[i].angle;
    }
    if (!canvas83Running) frame83();
  }
  
  function startCanvas83() {
    if (canvas83Running) canvas83Running = false;
    else {
      canvas83Running = true;
      frame83();
    }
  }
  
  function exportCanvas83() {
    canvas83Img.src = canvas83.toDataURL();
  }
  
  let turnSpeed83RangeArray = [0.5, 1, 1.5, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45];
  turnSpeed83Range.max = turnSpeed83RangeArray.length - 1;
  
  function updateSettings83() {
    gridSize83 = Number(gridSize83Range.value);
    gridSize83Txt.innerHTML = gridSize83Range.value + "x" + gridSize83Range.value;
    tileSize83 = canvas83.width / gridSize83;
    
    turnSpeed83 = turnSpeed83Txt.innerHTML = turnSpeed83RangeArray[Number(turnSpeed83Range.value)];
    
    hue83 = hue83Txt.innerHTML = Number(hue83Range.value);
    
    brightness83 = brightness83Txt.innerHTML = Number(brightness83Range.value);
    
    lineWidth83 = lineWidth83Txt.innerHTML = Number(lineWidth83Range.value) / 100;
    
    alternateDirections83 = alternateDirections83Checkbox.checked;
    
    square83Array = [];
    for (let x = -3; x < gridSize83 + 3; x++) {
      for (let y = -3; y < gridSize83 + 3; y++) {
        let turnSign = ((x + y) % 2 === 0) ? 1 : -1;
        if (!alternateDirections83) turnSign = 1;
        turnSign *= globalSign83;
        square83Array.push(new Square83((x * tileSize83) + (tileSize83 / 2) - (canvas83.width / 2), (y * tileSize83) + (tileSize83 / 2) - (canvas83.height / 2), tileSize83, turnSign));
      }
    }
    
    reset83();
  }
